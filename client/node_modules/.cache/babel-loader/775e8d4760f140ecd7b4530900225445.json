{"ast":null,"code":"// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\nconst semver = require('semver');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst Edge = require('./edge.js');\n\nconst Inventory = require('./inventory.js');\n\nconst OverrideSet = require('./override-set.js');\n\nconst {\n  normalize\n} = require('read-package-json-fast');\n\nconst {\n  getPaths: getBinPaths\n} = require('bin-links');\n\nconst npa = require('npm-package-arg');\n\nconst debug = require('./debug.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst treeCheck = require('./tree-check.js');\n\nconst walkUp = require('walk-up-path');\n\nconst {\n  resolve,\n  relative,\n  dirname,\n  basename\n} = require('path');\n\nconst util = require('util');\n\nconst _package = Symbol('_package');\n\nconst _parent = Symbol('_parent');\n\nconst _target = Symbol.for('_target');\n\nconst _fsParent = Symbol('_fsParent');\n\nconst _loadDepType = Symbol('_loadDepType');\n\nconst _loadWorkspaces = Symbol('_loadWorkspaces');\n\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges'); // overridden by Link class\n\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _root = Symbol('_root');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nconst _changePath = Symbol.for('_changePath'); // used by Link class as well\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _global = Symbol.for('global');\n\nconst _workspaces = Symbol('_workspaces');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst _meta = Symbol('_meta');\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst printableTree = require('./printable.js');\n\nconst CaseInsensitiveMap = require('./case-insensitive-map.js');\n\nconst querySelectorAll = require('./query-selector-all.js');\n\nclass Node {\n  constructor(options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      installLinks = false,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      overrides,\n      loadOverrides = false,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null\n    } = options; // true if part of a global install\n\n    this[_global] = global;\n    this[_workspaces] = null;\n    this.errors = error ? [error] : []; // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n\n    this.sourceReference = sourceReference;\n    const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});\n    this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null; // should be equal if not a link\n\n    this.path = path ? resolve(path) : null;\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package');\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath);\n    this.resolved = resolved || null;\n\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved);\n\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved;\n      }\n    }\n\n    this.integrity = integrity || pkg._integrity || null;\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;\n    this.installLinks = installLinks;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this.children = new CaseInsensitiveMap();\n    this.fsChildren = new Set();\n    this.inventory = new Inventory({});\n    this.tops = new Set();\n    this.linksIn = new Set(linksIn || []); // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n\n    if (!dummy) {\n      this.dev = dev;\n      this.optional = optional;\n      this.devOptional = devOptional;\n      this.peer = peer;\n      this.extraneous = extraneous;\n      this.dummy = false;\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true;\n      this.dev = false;\n      this.optional = false;\n      this.devOptional = false;\n      this.peer = false;\n      this.extraneous = false;\n    }\n\n    this.edgesIn = new Set();\n    this.edgesOut = new CaseInsensitiveMap(); // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {};\n\n    if (overrides) {\n      this.overrides = overrides;\n    } else if (loadOverrides) {\n      const overrides = this[_package].overrides || {};\n\n      if (Object.keys(overrides).length > 0) {\n        this.overrides = new OverrideSet({\n          overrides: this[_package].overrides\n        });\n      }\n    } // only relevant for the root and top nodes\n\n\n    this.meta = meta; // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n    // will also assign root if present on the parent\n\n    this[_parent] = null;\n    this.parent = parent || null;\n    this[_fsParent] = null;\n    this.fsParent = fsParent || null; // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n\n    if (!parent && !fsParent) {\n      this.root = root || null;\n    } // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n\n\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c,\n          parent: this\n        });\n      }\n    }\n\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c,\n          fsParent: this\n        });\n      }\n    } // now load all the dep edges\n\n\n    this[_loadDeps]();\n  }\n\n  get meta() {\n    return this[_meta];\n  }\n\n  set meta(meta) {\n    this[_meta] = meta;\n\n    if (meta) {\n      meta.add(this);\n    }\n  }\n\n  get global() {\n    return this.root[_global];\n  } // true for packages installed directly in the global node_modules folder\n\n\n  get globalTop() {\n    return this.global && this.parent && this.parent.isProjectRoot;\n  }\n\n  get workspaces() {\n    return this[_workspaces];\n  }\n\n  set workspaces(workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach();\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps]();\n  }\n\n  get binPaths() {\n    if (!this.parent) {\n      return [];\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop\n    });\n  }\n\n  get hasInstallScript() {\n    const {\n      hasInstallScript,\n      scripts\n    } = this.package;\n    const {\n      install,\n      preinstall,\n      postinstall\n    } = scripts || {};\n    return !!(hasInstallScript || install || preinstall || postinstall);\n  }\n\n  get version() {\n    return this[_package].version || '';\n  }\n\n  get packageName() {\n    return this[_package].name || null;\n  }\n\n  get pkgid() {\n    const {\n      name = '',\n      version = ''\n    } = this.package; // root package will prefer package name over folder name,\n    // and never be called an alias.\n\n    const {\n      isProjectRoot\n    } = this;\n    const myname = isProjectRoot ? name || this.name : this.name;\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : '';\n    return `${myname}@${alias}${version}`;\n  }\n\n  get package() {\n    return this[_package];\n  }\n\n  set package(pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach();\n    }\n\n    this[_explanation] = null;\n    /* istanbul ignore next - should be impossible */\n\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object');\n      });\n      pkg = {};\n    }\n\n    this[_package] = pkg;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps](); // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n\n\n    this.edgesIn.forEach(edge => edge.reload(true));\n  } // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n\n\n  explain() {\n    let edge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (this[_explanation]) {\n      return this[_explanation];\n    }\n\n    return this[_explanation] = this[_explain](edge, seen);\n  }\n\n  [_explain](edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path\n      };\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version\n    };\n\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [new Error('invalid package: lacks name and/or version')];\n      why.package = this.package;\n    }\n\n    if (this.root.sourceReference) {\n      const {\n        name,\n        version\n      } = this.root.package;\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path\n      };\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen);\n    }\n\n    if (seen.includes(this)) {\n      return why;\n    }\n\n    why.location = this.location;\n    why.isWorkspace = this.isWorkspace; // make a new list each time.  we can revisit, but not loop.\n\n    seen = seen.concat(this);\n    why.dependents = [];\n\n    if (edge) {\n      why.dependents.push(edge.explain(seen));\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = [];\n\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue;\n        }\n\n        edges.push(edge);\n      }\n\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen));\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen));\n    }\n\n    return why;\n  }\n\n  isDescendantOf(node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getBundler() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null;\n    }\n\n    path.push(this);\n    const parent = this[_parent];\n\n    if (!parent) {\n      return null;\n    }\n\n    const pBundler = parent.getBundler(path);\n\n    if (pBundler) {\n      return pBundler;\n    }\n\n    const ppkg = parent.package;\n    const bd = ppkg && ppkg.bundleDependencies; // explicit bundling\n\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent;\n    } // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n\n\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path);\n\n      if (!eBundler) {\n        continue;\n      }\n\n      if (eBundler === parent) {\n        return eBundler;\n      }\n    }\n\n    return null;\n  }\n\n  get inBundle() {\n    return !!this.getBundler();\n  } // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n\n\n  get inDepBundle() {\n    const bundler = this.getBundler();\n    return !!bundler && bundler !== this.root;\n  }\n\n  get isWorkspace() {\n    if (this.isProjectRoot) {\n      return false;\n    }\n\n    const {\n      root\n    } = this;\n    const {\n      type,\n      to\n    } = root.edgesOut.get(this.packageName) || {};\n    return type === 'workspace' && to && (to.target === this || to === this);\n  }\n\n  get isRoot() {\n    return this === this.root;\n  }\n\n  get isProjectRoot() {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target;\n  }\n\n  get isRegistryDependency() {\n    if (this.edgesIn.size === 0) {\n      return false;\n    }\n\n    for (const edge of this.edgesIn) {\n      if (!npa(edge.spec).registry) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  *ancestry() {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc;\n    }\n  }\n\n  set root(root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root;\n    }\n\n    root = root || this; // delete from current root inventory\n\n    this[_delistFromMeta](); // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n\n\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root;\n    } // temporarily become a root node\n\n\n    this[_root] = this; // break all linksIn, we're going to re-set them if needed later\n\n    for (const link of this.linksIn) {\n      link[_target] = null;\n      this.linksIn.delete(link);\n    } // temporarily break this link as well, we'll re-set if possible later\n\n\n    const {\n      target\n    } = this;\n\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this);\n\n        if (target.root === this) {\n          target[_delistFromMeta]();\n        }\n      }\n\n      this[_target] = null;\n    } // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n\n\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    if (root === this) {\n      this[_refreshLocation]();\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path);\n      const current = root.inventory.get(loc); // clobber whatever is there now\n\n      if (current) {\n        current.root = null;\n      }\n\n      this[_root] = root; // set this.location and add to inventory\n\n      this[_refreshLocation](); // try to find our parent/fsParent in the new root inventory\n\n\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue;\n        }\n\n        const ploc = relpath(root.realpath, p);\n        const parent = root.inventory.get(ploc);\n\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath\n              });\n            });\n            continue;\n          }\n\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`;\n          const isParent = this.location === childLoc;\n\n          if (isParent) {\n            const oldChild = parent.children.get(this.name);\n\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null;\n            }\n\n            if (this.parent) {\n              this.parent.children.delete(this.name);\n\n              this.parent[_reloadNamedEdges](this.name);\n            }\n\n            parent.children.set(this.name, this);\n            this[_parent] = parent; // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name);\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this);\n            }\n\n            parent.fsChildren.add(this);\n            this[_fsParent] = parent;\n          }\n\n          break;\n        }\n      } // if it doesn't have a parent, it's a top node\n\n\n      if (!this.parent) {\n        root.tops.add(this);\n      } else {\n        root.tops.delete(this);\n      } // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n\n\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`;\n\n      const isChild = n => n.location === nmloc + n.name; // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n\n\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path));\n      };\n\n      const isKid = n => isChild(n) || isFsChild(n); // only walk top nodes, since anything else already has a parent.\n\n\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue;\n        } // set up the internal parentage links\n\n\n        if (this.isLink) {\n          child.root = null;\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child);\n          }\n\n          child[_fsParent] = null;\n\n          if (isChild(child)) {\n            this.children.set(child.name, child);\n            child[_parent] = this;\n            root.tops.delete(child);\n          } else {\n            this.fsChildren.add(child);\n            child[_fsParent] = this;\n          }\n        }\n      } // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n\n\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue;\n        }\n        /* istanbul ignore next - should be impossible */\n\n\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root');\n          }\n        });\n\n        if (this.isLink) {\n          const target = node.target;\n          this[_target] = target;\n          this[_package] = target.package;\n          target.linksIn.add(this); // reload edges here, because now we have a target\n\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name);\n          }\n\n          break;\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this;\n            node[_package] = this.package;\n            this.linksIn.add(node);\n\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name);\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath\n              });\n            });\n          }\n        }\n      }\n    } // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n\n\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload();\n      }\n    } // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n\n\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload();\n      }\n    } // now make sure our family comes along for the ride!\n\n\n    const family = new Set([...this.fsChildren, ...this.children.values(), ...this.inventory.values()].filter(n => n !== this));\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]();\n\n        child[_parent] = null;\n        this.children.delete(child.name);\n        child[_fsParent] = null;\n        this.fsChildren.delete(child);\n\n        for (const l of child.linksIn) {\n          l[_target] = null;\n          child.linksIn.delete(l);\n        }\n      }\n    }\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root;\n      }\n    } // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n\n\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root;\n    }\n\n    if (!this.overrides && this.parent && this.parent.overrides) {\n      this.overrides = this.parent.overrides.getNodeRule(this);\n    } // tree should always be valid upon root setter completion.\n\n\n    treeCheck(this);\n    treeCheck(root);\n  }\n\n  get root() {\n    return this[_root] || this;\n  }\n\n  [_loadWorkspaces]() {\n    if (!this[_workspaces]) {\n      return;\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({\n        from: this,\n        name,\n        spec: `file:${path.replace(/#/g, '%23')}`,\n        type: 'workspace'\n      });\n    }\n  }\n\n  [_loadDeps]() {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies;\n\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {};\n      const peerDependencies = {};\n      const peerOptional = {};\n\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep;\n        } else {\n          peerDependencies[name] = dep;\n        }\n      }\n\n      this[_loadDepType](peerDependencies, 'peer');\n\n      this[_loadDepType](peerOptional, 'peerOptional');\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod');\n\n    this[_loadDepType](this.package.optionalDependencies, 'optional');\n\n    const {\n      globalTop,\n      isTop,\n      path,\n      sourceReference\n    } = this;\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath\n    } = sourceReference || {};\n    const thisDev = isTop && !globalTop && path;\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath;\n\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev');\n    }\n  }\n\n  [_loadDepType](deps, type) {\n    const ad = this.package.acceptDependencies || {}; // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name);\n\n      if (!current || current.type !== 'workspace') {\n        new Edge({\n          from: this,\n          name,\n          spec,\n          accept: ad[name],\n          type\n        });\n      }\n    }\n  }\n\n  get fsParent() {\n    const parent = this[_fsParent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent');\n      }\n    });\n    return parent;\n  }\n\n  set fsParent(fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null;\n      }\n\n      return;\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent');\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path');\n      } // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n\n\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath\n          }\n        });\n      }\n    });\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target;\n    } // setting a thing to its own fsParent is not normal, but no-op for safety\n\n\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return;\n    } // nothing to do\n\n\n    if (this[_fsParent] === fsParent) {\n      return;\n    }\n\n    const oldFsParent = this[_fsParent];\n    const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name); // this is actually the parent, set that instead\n\n    if (newPath === nmPath) {\n      this.parent = fsParent;\n      return;\n    }\n\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    const oldParent = this.parent;\n    const oldName = this.name;\n\n    if (this.parent) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) {\n      this[_changePath](newPath);\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName);\n    } // clobbers anything at that path, resets all appropriate references\n\n\n    this.root = fsParent.root;\n  } // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n\n\n  canReplaceWith(node) {\n    let ignorePeers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (node.name !== this.name) {\n      return false;\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false;\n    } // XXX need to check for two root nodes?\n\n\n    if (node.overrides !== this.overrides) {\n      return false;\n    }\n\n    ignorePeers = new Set(ignorePeers); // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid);\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop && edge.from.parent === this.parent && edge.peer && ignorePeers.has(edge.from.name);\n\n      if (ignored) {\n        continue;\n      } // only care about edges that don't originate from this node\n\n\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canReplace(node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers);\n  } // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n\n\n  canDedupe() {\n    let preferDedupe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false;\n    } // it's a top level pkg, or a dep of one\n\n\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false;\n    } // no one wants it, remove it\n\n\n    if (this.edgesIn.size === 0) {\n      return true;\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name); // nothing else, need this one\n\n    if (!other) {\n      return false;\n    } // if it's the same thing, then always fine to remove\n\n\n    if (other.matches(this)) {\n      return true;\n    } // if the other thing can't replace this, then skip it\n\n\n    if (!other.canReplace(this)) {\n      return false;\n    } // if we prefer dedupe, or if the version is greater/equal, take the other\n\n\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  satisfies(requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this);\n    }\n\n    const parsed = npa(requested);\n    const {\n      name = this.name,\n      rawSpec: spec\n    } = parsed;\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({\n        path: this.root.realpath\n      }),\n      type: 'prod',\n      name,\n      spec\n    }));\n  }\n\n  matches(node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true;\n    } // if the names don't match, they're different things, even if\n    // the package contents are identical.\n\n\n    if (node.name !== this.name) {\n      return false;\n    } // if they're links, they match if the targets match\n\n\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target);\n    } // if they're two project root nodes, they're different if the paths differ\n\n\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path;\n    } // if the integrity matches, then they're the same.\n\n\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity;\n    } // if no integrity, check resolved\n\n\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved;\n    } // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n\n\n    return this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version;\n  } // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n\n\n  replaceWith(node) {\n    node.replace(this);\n  }\n\n  replace(node) {\n    this[_delistFromMeta](); // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n\n\n    const nameMatch = node.parent && node.parent.children.get(this.name) === node;\n\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name);\n    } else {\n      this.path = node.path;\n      this.name = node.name;\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path;\n    }\n\n    this[_refreshLocation](); // keep children when a node replaces another\n\n\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this;\n      }\n\n      if (node.isLink && node.target) {\n        node.target.root = null;\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root;\n    }\n\n    treeCheck(this);\n  }\n\n  get inShrinkwrap() {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);\n  }\n\n  get parent() {\n    const parent = this[_parent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent');\n      }\n    });\n    return parent;\n  } // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n\n\n  set parent(parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null;\n      }\n\n      return;\n    }\n\n    if (parent.isLink) {\n      parent = parent.target;\n    } // setting a thing to its own parent is not normal, but no-op for safety\n\n\n    if (this === parent) {\n      return;\n    }\n\n    const oldParent = this[_parent]; // nothing to do\n\n    if (oldParent === parent) {\n      return;\n    } // ok now we know something is actually changing, and parent is not a link\n\n\n    const newPath = resolve(parent.path, 'node_modules', this.name);\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    if (oldParent) {\n      oldParent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) {\n      this[_changePath](newPath);\n    }\n\n    if (parent.overrides) {\n      this.overrides = parent.overrides.getNodeRule(this);\n    } // clobbers anything at that path, resets all appropriate references\n\n\n    this.root = parent.root;\n  } // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n\n\n  [_delistFromMeta]() {\n    const root = this.root;\n\n    if (!root.realpath || !this.path) {\n      return;\n    }\n\n    root.inventory.delete(this);\n    root.tops.delete(this);\n\n    if (root.meta) {\n      root.meta.delete(this.path);\n    }\n    /* istanbul ignore next - should be impossible */\n\n\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist');\n      }\n    });\n  } // update this.path/realpath and the paths of all children/fsChildren\n\n\n  [_changePath](newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]();\n\n    const oldPath = this.path;\n    this.path = newPath;\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/;\n    const nameChange = newPath.match(namePattern);\n\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/');\n    } // if we move a link target, update link realpaths\n\n\n    if (!this.isLink) {\n      this.realpath = newPath;\n\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]();\n\n        link.realpath = newPath;\n\n        link[_refreshLocation]();\n      }\n    } // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n\n\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)));\n    }\n\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name));\n    }\n\n    this[_refreshLocation]();\n  } // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n\n\n  [_refreshLocation]() {\n    const root = this.root;\n    const loc = relpath(root.realpath, this.path);\n    this.location = loc;\n    root.inventory.add(this);\n\n    if (root.meta) {\n      root.meta.add(this);\n    }\n  }\n\n  assertRootOverrides() {\n    if (!this.isProjectRoot || !this.overrides) {\n      return;\n    }\n\n    for (const edge of this.edgesOut.values()) {\n      // if these differ an override has been applied, those are not allowed\n      // for top level dependencies so throw an error\n      if (edge.spec !== edge.rawSpec && !edge.spec.startsWith('$')) {\n        throw Object.assign(new Error(`Override for ${edge.name}@${edge.rawSpec} conflicts with direct dependency`), {\n          code: 'EOVERRIDE'\n        });\n      }\n    }\n  }\n\n  addEdgeOut(edge) {\n    if (this.overrides) {\n      edge.overrides = this.overrides.getEdgeRule(edge);\n    }\n\n    this.edgesOut.set(edge.name, edge);\n  }\n\n  addEdgeIn(edge) {\n    if (edge.overrides) {\n      this.overrides = edge.overrides;\n    }\n\n    this.edgesIn.add(edge); // try to get metadata from the yarn.lock file\n\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge);\n    }\n  }\n\n  [_reloadNamedEdges](name) {\n    let rootLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.location;\n    const edge = this.edgesOut.get(name); // if we don't have an edge, do nothing, but keep descending\n\n    const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;\n    const sameResolved = edge && this.resolve(name) === edge.to;\n    const recheck = rootLocResolved || !sameResolved;\n\n    if (edge && recheck) {\n      edge.reload(true);\n    }\n\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n  }\n\n  get isLink() {\n    return false;\n  }\n\n  get target() {\n    return this;\n  }\n\n  set target(n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path\n      });\n    });\n  }\n\n  get depth() {\n    return this.isTop ? 0 : this.parent.depth + 1;\n  }\n\n  get isTop() {\n    return !this.parent || this.globalTop;\n  }\n\n  get top() {\n    return this.isTop ? this : this.parent.top;\n  }\n\n  get isFsTop() {\n    return !this.fsParent;\n  }\n\n  get fsTop() {\n    return this.isFsTop ? this : this.fsParent.fsTop;\n  }\n\n  get resolveParent() {\n    return this.parent || this.fsParent;\n  }\n\n  resolve(name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve');\n      }\n    });\n    const mine = this.children.get(name);\n\n    if (mine) {\n      return mine;\n    }\n\n    const resolveParent = this.resolveParent;\n\n    if (resolveParent) {\n      return resolveParent.resolve(name);\n    }\n\n    return null;\n  }\n\n  inNodeModules() {\n    const rp = this.realpath;\n    const name = this.name;\n    const scoped = name.charAt(0) === '@';\n    const d = dirname(rp);\n    const nm = scoped ? dirname(d) : d;\n    const dir = dirname(nm);\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);\n    return base === name && basename(nm) === 'node_modules' ? dir : false;\n  } // maybe accept both string value or array of strings\n  // seems to be what dom API does\n\n\n  querySelectorAll(query) {\n    return querySelectorAll(this, query);\n  }\n\n  toJSON() {\n    return printableTree(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Node;","map":{"version":3,"names":["semver","require","nameFromFolder","Edge","Inventory","OverrideSet","normalize","getPaths","getBinPaths","npa","debug","gatherDepSet","treeCheck","walkUp","resolve","relative","dirname","basename","util","_package","Symbol","_parent","_target","for","_fsParent","_loadDepType","_loadWorkspaces","_reloadNamedEdges","_loadDeps","_root","_refreshLocation","_changePath","_delistFromMeta","_global","_workspaces","_explain","_explanation","_meta","relpath","consistentResolve","printableTree","CaseInsensitiveMap","querySelectorAll","Node","constructor","options","root","path","realpath","parent","error","meta","fsParent","resolved","integrity","name","children","fsChildren","installLinks","legacyPeerDeps","linksIn","hasShrinkwrap","overrides","loadOverrides","extraneous","dev","optional","devOptional","peer","global","dummy","sourceReference","errors","pkg","package","TypeError","isLink","_resolved","test","_where","_integrity","_hasShrinkwrap","Set","inventory","tops","edgesIn","edgesOut","Object","keys","length","c","add","globalTop","isProjectRoot","workspaces","has","get","detach","binPaths","top","hasInstallScript","scripts","install","preinstall","postinstall","version","packageName","pkgid","myname","alias","edge","values","Error","forEach","reload","explain","seen","location","why","isTop","whileInstalling","includes","isWorkspace","concat","dependents","push","edges","valid","from","size","map","link","isDescendantOf","node","p","resolveParent","getBundler","pBundler","ppkg","bd","bundleDependencies","Array","isArray","eBundler","inBundle","inDepBundle","bundler","type","to","target","isRoot","isRegistryDependency","spec","registry","ancestry","anc","delete","loc","current","ploc","assign","parentReal","childLoc","isParent","oldChild","set","nmloc","isChild","n","isFsChild","startsWith","isKid","child","query","family","filter","l","getNodeRule","entries","replace","pd","peerDependencies","pm","peerDependenciesMeta","peerOptional","dep","dependencies","optionalDependencies","srcGlobalTop","srcTop","srcPath","thisDev","srcDev","devDependencies","deps","ad","acceptDependencies","accept","indexOf","oldFsParent","newPath","nmPath","pathChange","oldParent","oldName","canReplaceWith","ignorePeers","depSet","e","ignored","satisfiedBy","canReplace","canDedupe","preferDedupe","inShrinkwrap","other","matches","gte","satisfies","requested","parsed","rawSpec","replaceWith","nameMatch","kid","oldPath","namePattern","nameChange","match","assertRootOverrides","code","addEdgeOut","getEdgeRule","addEdgeIn","addEdge","rootLoc","rootLocResolved","sameResolved","recheck","depth","isFsTop","fsTop","mine","inNodeModules","rp","scoped","charAt","d","nm","dir","base","toJSON","inspect","custom","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js"],"sourcesContent":["// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver')\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst OverrideSet = require('./override-set.js')\nconst { normalize } = require('read-package-json-fast')\nconst { getPaths: getBinPaths } = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst { resolve, relative, dirname, basename } = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\nconst CaseInsensitiveMap = require('./case-insensitive-map.js')\n\nconst querySelectorAll = require('./query-selector-all.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      installLinks = false,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      overrides,\n      loadOverrides = false,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package')\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved\n      }\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.installLinks = installLinks\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new CaseInsensitiveMap()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new CaseInsensitiveMap()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    if (overrides) {\n      this.overrides = overrides\n    } else if (loadOverrides) {\n      const overrides = this[_package].overrides || {}\n      if (Object.keys(overrides).length > 0) {\n        this.overrides = new OverrideSet({\n          overrides: this[_package].overrides,\n        })\n      }\n    }\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent) {\n      this.root = root || null\n    }\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c, parent: this })\n      }\n    }\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c, fsParent: this })\n      }\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta) {\n      meta.add(this)\n    }\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach()\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent) {\n      return []\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const { hasInstallScript, scripts } = this.package\n    const { install, preinstall, postinstall } = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get packageName () {\n    return this[_package].name || null\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach()\n    }\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const { name, version } = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen)\n    }\n\n    if (seen.includes(this)) {\n      return why\n    }\n\n    why.location = this.location\n    why.isWorkspace = this.isWorkspace\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge) {\n      why.dependents.push(edge.explain(seen))\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue\n        }\n\n        edges.push(edge)\n      }\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen))\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen))\n    }\n\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true\n      }\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null\n    }\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent) {\n      return null\n    }\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler) {\n      return pBundler\n    }\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent\n    }\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler) {\n        continue\n      }\n\n      if (eBundler === parent) {\n        return eBundler\n      }\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot) {\n      return false\n    }\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.packageName) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target\n  }\n\n  get isRegistryDependency () {\n    if (this.edgesIn.size === 0) {\n      return false\n    }\n    for (const edge of this.edgesIn) {\n      if (!npa(edge.spec).registry) {\n        return false\n      }\n    }\n    return true\n  }\n\n  * ancestry () {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc\n    }\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root\n    }\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root\n    }\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this) {\n          target[_delistFromMeta]()\n        }\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this) {\n      this[_refreshLocation]()\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current) {\n        current.root = null\n      }\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue\n        }\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null\n            }\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name)\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this)\n            }\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent) {\n        root.tops.add(this)\n      } else {\n        root.tops.delete(this)\n      }\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) &&\n          n !== this &&\n          !n.parent &&\n          (!n.fsParent ||\n            n.fsParent === this ||\n            dirname(this.path).startsWith(n.fsParent.path))\n      }\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue\n        }\n\n        // set up the internal parentage links\n        if (this.isLink) {\n          child.root = null\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child)\n          }\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue\n        }\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root')\n          }\n        })\n\n        if (this.isLink) {\n          const target = node.target\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name)\n          }\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name)\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload()\n      }\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload()\n      }\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root\n      }\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root\n    }\n\n    if (!this.overrides && this.parent && this.parent.overrides) {\n      this.overrides = this.parent.overrides.getNodeRule(this)\n    }\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces]) {\n      return\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({ from: this, name, spec: `file:${path.replace(/#/g, '%23')}`, type: 'workspace' })\n    }\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep\n        } else {\n          peerDependencies[name] = dep\n        }\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    const { globalTop, isTop, path, sourceReference } = this\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath,\n    } = sourceReference || {}\n    const thisDev = isTop && !globalTop && path\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev')\n    }\n  }\n\n  [_loadDepType] (deps, type) {\n    const ad = this.package.acceptDependencies || {}\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name)\n      if (!current || current.type !== 'workspace') {\n        new Edge({ from: this, name, spec, accept: ad[name], type })\n      }\n    }\n  }\n\n  get fsParent () {\n    const parent = this[_fsParent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent')\n      }\n    })\n    return parent\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null\n      }\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent')\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path')\n      }\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target\n    }\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return\n    }\n\n    // nothing to do\n    if (this[_fsParent] === fsParent) {\n      return\n    }\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false\n    }\n\n    // XXX need to check for two root nodes?\n    if (node.overrides !== this.overrides) {\n      return false\n    }\n\n    ignorePeers = new Set(ignorePeers)\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop &&\n        edge.from.parent === this.parent &&\n        edge.peer &&\n        ignorePeers.has(edge.from.name)\n      if (ignored) {\n        continue\n      }\n\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  canReplace (node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers)\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe (preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false\n    }\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false\n    }\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0) {\n      return true\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name)\n\n    // nothing else, need this one\n    if (!other) {\n      return false\n    }\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this)) {\n      return true\n    }\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this)) {\n      return false\n    }\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true\n    }\n\n    return false\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this)\n    }\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true\n    }\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name) {\n      return false\n    }\n\n    // if they're links, they match if the targets match\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target)\n    }\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path\n    }\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity\n    }\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved\n    }\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName &&\n      this.packageName === node.packageName &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n\n    // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n    const nameMatch = node.parent &&\n      node.parent.children.get(this.name) === node\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name)\n    } else {\n      this.path = node.path\n      this.name = node.name\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path\n    }\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this\n      }\n      if (node.isLink && node.target) {\n        node.target.root = null\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root\n    }\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent &&\n      (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    const parent = this[_parent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent')\n      }\n    })\n    return parent\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null\n      }\n      return\n    }\n\n    if (parent.isLink) {\n      parent = parent.target\n    }\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent) {\n      return\n    }\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent) {\n      return\n    }\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (parent.overrides) {\n      this.overrides = parent.overrides.getNodeRule(this)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path) {\n      return\n    }\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta) {\n      root.meta.delete(this.path)\n    }\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist')\n      }\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n    }\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    }\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name))\n    }\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta) {\n      root.meta.add(this)\n    }\n  }\n\n  assertRootOverrides () {\n    if (!this.isProjectRoot || !this.overrides) {\n      return\n    }\n\n    for (const edge of this.edgesOut.values()) {\n      // if these differ an override has been applied, those are not allowed\n      // for top level dependencies so throw an error\n      if (edge.spec !== edge.rawSpec && !edge.spec.startsWith('$')) {\n        throw Object.assign(new Error(`Override for ${edge.name}@${edge.rawSpec} conflicts with direct dependency`), { code: 'EOVERRIDE' })\n      }\n    }\n  }\n\n  addEdgeOut (edge) {\n    if (this.overrides) {\n      edge.overrides = this.overrides.getEdgeRule(edge)\n    }\n\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    if (edge.overrides) {\n      this.overrides = edge.overrides\n    }\n\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge)\n    }\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck) {\n      edge.reload(true)\n    }\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return this\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent || this.globalTop\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get isFsTop () {\n    return !this.fsParent\n  }\n\n  get fsTop () {\n    return this.isFsTop ? this : this.fsParent.fsTop\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve')\n      }\n    })\n    const mine = this.children.get(name)\n    if (mine) {\n      return mine\n    }\n    const resolveParent = this.resolveParent\n    if (resolveParent) {\n      return resolveParent.resolve(name)\n    }\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  // maybe accept both string value or array of strings\n  // seems to be what dom API does\n  querySelectorAll (query) {\n    return querySelectorAll(this, query)\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,0BAAD,CAA9B;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,WAAD,CAApB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,gBAAD,CAAzB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAM;EAAEK;AAAF,IAAgBL,OAAO,CAAC,wBAAD,CAA7B;;AACA,MAAM;EAAEM,QAAQ,EAAEC;AAAZ,IAA4BP,OAAO,CAAC,WAAD,CAAzC;;AACA,MAAMQ,GAAG,GAAGR,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMS,KAAK,GAAGT,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMU,YAAY,GAAGV,OAAO,CAAC,qBAAD,CAA5B;;AACA,MAAMW,SAAS,GAAGX,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMY,MAAM,GAAGZ,OAAO,CAAC,cAAD,CAAtB;;AAEA,MAAM;EAAEa,OAAF;EAAWC,QAAX;EAAqBC,OAArB;EAA8BC;AAA9B,IAA2ChB,OAAO,CAAC,MAAD,CAAxD;;AACA,MAAMiB,IAAI,GAAGjB,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMkB,QAAQ,GAAGC,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,MAAM,CAAC,SAAD,CAAtB;;AACA,MAAME,OAAO,GAAGF,MAAM,CAACG,GAAP,CAAW,SAAX,CAAhB;;AACA,MAAMC,SAAS,GAAGJ,MAAM,CAAC,WAAD,CAAxB;;AACA,MAAMK,YAAY,GAAGL,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMM,eAAe,GAAGN,MAAM,CAAC,iBAAD,CAA9B;;AACA,MAAMO,iBAAiB,GAAGP,MAAM,CAAC,mBAAD,CAAhC,C,CACA;;;AACA,MAAMQ,SAAS,GAAGR,MAAM,CAACG,GAAP,CAAW,yBAAX,CAAlB;;AACA,MAAMM,KAAK,GAAGT,MAAM,CAAC,OAAD,CAApB;;AACA,MAAMU,gBAAgB,GAAGV,MAAM,CAACG,GAAP,CAAW,kBAAX,CAAzB;;AACA,MAAMQ,WAAW,GAAGX,MAAM,CAACG,GAAP,CAAW,aAAX,CAApB,C,CACA;;;AACA,MAAMS,eAAe,GAAGZ,MAAM,CAACG,GAAP,CAAW,iBAAX,CAAxB;;AACA,MAAMU,OAAO,GAAGb,MAAM,CAACG,GAAP,CAAW,QAAX,CAAhB;;AACA,MAAMW,WAAW,GAAGd,MAAM,CAAC,aAAD,CAA1B;;AACA,MAAMe,QAAQ,GAAGf,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMgB,YAAY,GAAGhB,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMiB,KAAK,GAAGjB,MAAM,CAAC,OAAD,CAApB;;AAEA,MAAMkB,OAAO,GAAGrC,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMsC,iBAAiB,GAAGtC,OAAO,CAAC,yBAAD,CAAjC;;AAEA,MAAMuC,aAAa,GAAGvC,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMwC,kBAAkB,GAAGxC,OAAO,CAAC,2BAAD,CAAlC;;AAEA,MAAMyC,gBAAgB,GAAGzC,OAAO,CAAC,yBAAD,CAAhC;;AAEA,MAAM0C,IAAN,CAAW;EACTC,WAAW,CAAEC,OAAF,EAAW;IACpB;IACA,MAAM;MACJC,IADI;MAEJC,IAFI;MAGJC,QAHI;MAIJC,MAJI;MAKJC,KALI;MAMJC,IANI;MAOJC,QAPI;MAQJC,QARI;MASJC,SATI;MAUJ;MACAC,IAXI;MAYJC,QAZI;MAaJC,UAbI;MAcJC,YAAY,GAAG,KAdX;MAeJC,cAAc,GAAG,KAfb;MAgBJC,OAhBI;MAiBJC,aAjBI;MAkBJC,SAlBI;MAmBJC,aAAa,GAAG,KAnBZ;MAoBJC,UAAU,GAAG,IApBT;MAqBJC,GAAG,GAAG,IArBF;MAsBJC,QAAQ,GAAG,IAtBP;MAuBJC,WAAW,GAAG,IAvBV;MAwBJC,IAAI,GAAG,IAxBH;MAyBJC,MAAM,GAAG,KAzBL;MA0BJC,KAAK,GAAG,KA1BJ;MA2BJC,eAAe,GAAG;IA3Bd,IA4BF1B,OA5BJ,CAFoB,CAgCpB;;IACA,KAAKZ,OAAL,IAAgBoC,MAAhB;IAEA,KAAKnC,WAAL,IAAoB,IAApB;IAEA,KAAKsC,MAAL,GAActB,KAAK,GAAG,CAACA,KAAD,CAAH,GAAa,EAAhC,CArCoB,CAuCpB;IACA;;IACA,KAAKqB,eAAL,GAAuBA,eAAvB;IAEA,MAAME,GAAG,GAAGF,eAAe,GAAGA,eAAe,CAACG,OAAnB,GACvBpE,SAAS,CAACuC,OAAO,CAAC4B,GAAR,IAAe,EAAhB,CADb;IAGA,KAAKlB,IAAL,GAAYA,IAAI,IACdrD,cAAc,CAAC6C,IAAI,IAAI0B,GAAG,CAAClB,IAAZ,IAAoBP,QAArB,CADJ,IAEVyB,GAAG,CAAClB,IAFM,IAGV,IAHF,CA9CoB,CAmDpB;;IACA,KAAKR,IAAL,GAAYA,IAAI,GAAGjC,OAAO,CAACiC,IAAD,CAAV,GAAmB,IAAnC;;IAEA,IAAI,CAAC,KAAKQ,IAAN,KAAe,CAAC,KAAKR,IAAN,IAAc,KAAKA,IAAL,KAAc/B,OAAO,CAAC,KAAK+B,IAAN,CAAlD,CAAJ,EAAoE;MAClE,MAAM,IAAI4B,SAAJ,CAAc,iDAAd,CAAN;IACD;;IAED,KAAK3B,QAAL,GAAgB,CAAC,KAAK4B,MAAN,GAAe,KAAK7B,IAApB,GAA2BjC,OAAO,CAACkC,QAAD,CAAlD;IAEA,KAAKK,QAAL,GAAgBA,QAAQ,IAAI,IAA5B;;IACA,IAAI,CAAC,KAAKA,QAAV,EAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMA,QAAQ,GAAGd,iBAAiB,CAACkC,GAAG,CAACI,SAAL,CAAlC;;MACA,IAAIxB,QAAQ,IAAI,EAAE,SAASyB,IAAT,CAAczB,QAAd,KAA2BoB,GAAG,CAACM,MAAjC,CAAhB,EAA0D;QACxD,KAAK1B,QAAL,GAAgBA,QAAhB;MACD;IACF;;IACD,KAAKC,SAAL,GAAiBA,SAAS,IAAImB,GAAG,CAACO,UAAjB,IAA+B,IAAhD;IACA,KAAKnB,aAAL,GAAqBA,aAAa,IAAIY,GAAG,CAACQ,cAArB,IAAuC,KAA5D;IACA,KAAKvB,YAAL,GAAoBA,YAApB;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IAEA,KAAKH,QAAL,GAAgB,IAAIf,kBAAJ,EAAhB;IACA,KAAKgB,UAAL,GAAkB,IAAIyB,GAAJ,EAAlB;IACA,KAAKC,SAAL,GAAiB,IAAI/E,SAAJ,CAAc,EAAd,CAAjB;IACA,KAAKgF,IAAL,GAAY,IAAIF,GAAJ,EAAZ;IACA,KAAKtB,OAAL,GAAe,IAAIsB,GAAJ,CAAQtB,OAAO,IAAI,EAAnB,CAAf,CA1FoB,CA4FpB;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAI,CAACU,KAAL,EAAY;MACV,KAAKL,GAAL,GAAWA,GAAX;MACA,KAAKC,QAAL,GAAgBA,QAAhB;MACA,KAAKC,WAAL,GAAmBA,WAAnB;MACA,KAAKC,IAAL,GAAYA,IAAZ;MACA,KAAKJ,UAAL,GAAkBA,UAAlB;MACA,KAAKM,KAAL,GAAa,KAAb;IACD,CAPD,MAOO;MACL;MACA;MACA;MACA,KAAKA,KAAL,GAAa,IAAb;MACA,KAAKL,GAAL,GAAW,KAAX;MACA,KAAKC,QAAL,GAAgB,KAAhB;MACA,KAAKC,WAAL,GAAmB,KAAnB;MACA,KAAKC,IAAL,GAAY,KAAZ;MACA,KAAKJ,UAAL,GAAkB,KAAlB;IACD;;IAED,KAAKqB,OAAL,GAAe,IAAIH,GAAJ,EAAf;IACA,KAAKI,QAAL,GAAgB,IAAI7C,kBAAJ,EAAhB,CAvHoB,CAyHpB;IACA;;IACA,KAAKtB,QAAL,IAAiBsD,GAAG,IAAI,OAAOA,GAAP,KAAe,QAAtB,GAAiCA,GAAjC,GAAuC,EAAxD;;IAEA,IAAIX,SAAJ,EAAe;MACb,KAAKA,SAAL,GAAiBA,SAAjB;IACD,CAFD,MAEO,IAAIC,aAAJ,EAAmB;MACxB,MAAMD,SAAS,GAAG,KAAK3C,QAAL,EAAe2C,SAAf,IAA4B,EAA9C;;MACA,IAAIyB,MAAM,CAACC,IAAP,CAAY1B,SAAZ,EAAuB2B,MAAvB,GAAgC,CAApC,EAAuC;QACrC,KAAK3B,SAAL,GAAiB,IAAIzD,WAAJ,CAAgB;UAC/ByD,SAAS,EAAE,KAAK3C,QAAL,EAAe2C;QADK,CAAhB,CAAjB;MAGD;IACF,CAtImB,CAwIpB;;;IACA,KAAKX,IAAL,GAAYA,IAAZ,CAzIoB,CA2IpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;;IACA,KAAK9B,OAAL,IAAgB,IAAhB;IACA,KAAK4B,MAAL,GAAcA,MAAM,IAAI,IAAxB;IAEA,KAAKzB,SAAL,IAAkB,IAAlB;IACA,KAAK4B,QAAL,GAAgBA,QAAQ,IAAI,IAA5B,CA9JoB,CAgKpB;IACA;IACA;;IACA,IAAI,CAACH,MAAD,IAAW,CAACG,QAAhB,EAA0B;MACxB,KAAKN,IAAL,GAAYA,IAAI,IAAI,IAApB;IACD,CArKmB,CAuKpB;IACA;;;IACA,IAAIU,QAAJ,EAAc;MACZ,KAAK,MAAMkC,CAAX,IAAgBlC,QAAhB,EAA0B;QACxB,IAAIb,IAAJ,CAAS,EAAE,GAAG+C,CAAL;UAAQzC,MAAM,EAAE;QAAhB,CAAT;MACD;IACF;;IACD,IAAIQ,UAAJ,EAAgB;MACd,KAAK,MAAMiC,CAAX,IAAgBjC,UAAhB,EAA4B;QAC1B,IAAId,IAAJ,CAAS,EAAE,GAAG+C,CAAL;UAAQtC,QAAQ,EAAE;QAAlB,CAAT;MACD;IACF,CAlLmB,CAoLpB;;;IACA,KAAKxB,SAAL;EACD;;EAEO,IAAJuB,IAAI,GAAI;IACV,OAAO,KAAKd,KAAL,CAAP;EACD;;EAEO,IAAJc,IAAI,CAAEA,IAAF,EAAQ;IACd,KAAKd,KAAL,IAAcc,IAAd;;IACA,IAAIA,IAAJ,EAAU;MACRA,IAAI,CAACwC,GAAL,CAAS,IAAT;IACD;EACF;;EAES,IAANtB,MAAM,GAAI;IACZ,OAAO,KAAKvB,IAAL,CAAUb,OAAV,CAAP;EACD,CAtMQ,CAwMT;;;EACa,IAAT2D,SAAS,GAAI;IACf,OAAO,KAAKvB,MAAL,IAAe,KAAKpB,MAApB,IAA8B,KAAKA,MAAL,CAAY4C,aAAjD;EACD;;EAEa,IAAVC,UAAU,GAAI;IAChB,OAAO,KAAK5D,WAAL,CAAP;EACD;;EAEa,IAAV4D,UAAU,CAAEA,UAAF,EAAc;IAC1B;IACA,IAAI,KAAK5D,WAAL,CAAJ,EAAuB;MACrB,KAAK,MAAMqB,IAAX,IAAmB,KAAKrB,WAAL,EAAkBsD,IAAlB,EAAnB,EAA6C;QAC3C,IAAI,CAACM,UAAU,CAACC,GAAX,CAAexC,IAAf,CAAL,EAA2B;UACzB,KAAK+B,QAAL,CAAcU,GAAd,CAAkBzC,IAAlB,EAAwB0C,MAAxB;QACD;MACF;IACF;;IAED,KAAK/D,WAAL,IAAoB4D,UAApB;;IACA,KAAKpE,eAAL;;IACA,KAAKE,SAAL;EACD;;EAEW,IAARsE,QAAQ,GAAI;IACd,IAAI,CAAC,KAAKjD,MAAV,EAAkB;MAChB,OAAO,EAAP;IACD;;IAED,OAAOzC,WAAW,CAAC;MACjBiE,GAAG,EAAE,KAAKtD,QAAL,CADY;MAEjB4B,IAAI,EAAE,KAAKA,IAFM;MAGjBsB,MAAM,EAAE,KAAKA,MAHI;MAIjB8B,GAAG,EAAE,KAAKP;IAJO,CAAD,CAAlB;EAMD;;EAEmB,IAAhBQ,gBAAgB,GAAI;IACtB,MAAM;MAAEA,gBAAF;MAAoBC;IAApB,IAAgC,KAAK3B,OAA3C;IACA,MAAM;MAAE4B,OAAF;MAAWC,UAAX;MAAuBC;IAAvB,IAAuCH,OAAO,IAAI,EAAxD;IACA,OAAO,CAAC,EAAED,gBAAgB,IAAIE,OAApB,IAA+BC,UAA/B,IAA6CC,WAA/C,CAAR;EACD;;EAEU,IAAPC,OAAO,GAAI;IACb,OAAO,KAAKtF,QAAL,EAAesF,OAAf,IAA0B,EAAjC;EACD;;EAEc,IAAXC,WAAW,GAAI;IACjB,OAAO,KAAKvF,QAAL,EAAeoC,IAAf,IAAuB,IAA9B;EACD;;EAEQ,IAALoD,KAAK,GAAI;IACX,MAAM;MAAEpD,IAAI,GAAG,EAAT;MAAakD,OAAO,GAAG;IAAvB,IAA8B,KAAK/B,OAAzC,CADW,CAEX;IACA;;IACA,MAAM;MAAEmB;IAAF,IAAoB,IAA1B;IACA,MAAMe,MAAM,GAAGf,aAAa,GAAGtC,IAAI,IAAI,KAAKA,IAAhB,GACxB,KAAKA,IADT;IAEA,MAAMsD,KAAK,GAAG,CAAChB,aAAD,IAAkBtC,IAAlB,IAA0BqD,MAAM,KAAKrD,IAArC,GAA6C,OAAMA,IAAK,GAAxD,GACV,EADJ;IAEA,OAAQ,GAAEqD,MAAO,IAAGC,KAAM,GAAEJ,OAAQ,EAApC;EACD;;EAEU,IAAP/B,OAAO,GAAI;IACb,OAAO,KAAKvD,QAAL,CAAP;EACD;;EAEU,IAAPuD,OAAO,CAAED,GAAF,EAAO;IAChB;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,MAAMqC,IAAX,IAAmB,KAAKxB,QAAL,CAAcyB,MAAd,EAAnB,EAA2C;MACzCD,IAAI,CAACb,MAAL;IACD;;IAED,KAAK7D,YAAL,IAAqB,IAArB;IACA;;IACA,IAAI,CAACqC,GAAD,IAAQ,OAAOA,GAAP,KAAe,QAA3B,EAAqC;MACnC/D,KAAK,CAAC,MAAM;QACV,MAAM,IAAIsG,KAAJ,CAAU,oCAAV,CAAN;MACD,CAFI,CAAL;MAGAvC,GAAG,GAAG,EAAN;IACD;;IACD,KAAKtD,QAAL,IAAiBsD,GAAjB;;IACA,KAAK/C,eAAL;;IACA,KAAKE,SAAL,IArBgB,CAsBhB;IACA;;;IACA,KAAKyD,OAAL,CAAa4B,OAAb,CAAqBH,IAAI,IAAIA,IAAI,CAACI,MAAL,CAAY,IAAZ,CAA7B;EACD,CApSQ,CAsST;EACA;;;EACAC,OAAO,GAA0B;IAAA,IAAxBL,IAAwB,uEAAjB,IAAiB;IAAA,IAAXM,IAAW,uEAAJ,EAAI;;IAC/B,IAAI,KAAKhF,YAAL,CAAJ,EAAwB;MACtB,OAAO,KAAKA,YAAL,CAAP;IACD;;IAED,OAAO,KAAKA,YAAL,IAAqB,KAAKD,QAAL,EAAe2E,IAAf,EAAqBM,IAArB,CAA5B;EACD;;EAEQ,CAARjF,QAAQ,EAAG2E,IAAH,EAASM,IAAT,EAAe;IACtB,IAAI,KAAKvB,aAAL,IAAsB,CAAC,KAAKtB,eAAhC,EAAiD;MAC/C,OAAO;QACL8C,QAAQ,EAAE,KAAKtE;MADV,CAAP;IAGD;;IAED,MAAMuE,GAAG,GAAG;MACV/D,IAAI,EAAE,KAAKsC,aAAL,IAAsB,KAAK0B,KAA3B,GAAmC,KAAKb,WAAxC,GAAsD,KAAKnD,IADvD;MAEVkD,OAAO,EAAE,KAAK/B,OAAL,CAAa+B;IAFZ,CAAZ;;IAIA,IAAI,KAAKjC,MAAL,CAAYiB,MAAZ,IAAsB,CAAC,KAAKiB,WAA5B,IAA2C,CAAC,KAAKhC,OAAL,CAAa+B,OAA7D,EAAsE;MACpEa,GAAG,CAAC9C,MAAJ,GAAa,KAAKA,MAAL,CAAYiB,MAAZ,GAAqB,KAAKjB,MAA1B,GAAmC,CAC9C,IAAIwC,KAAJ,CAAU,4CAAV,CAD8C,CAAhD;MAGAM,GAAG,CAAC5C,OAAJ,GAAc,KAAKA,OAAnB;IACD;;IAED,IAAI,KAAK5B,IAAL,CAAUyB,eAAd,EAA+B;MAC7B,MAAM;QAAEhB,IAAF;QAAQkD;MAAR,IAAoB,KAAK3D,IAAL,CAAU4B,OAApC;MACA4C,GAAG,CAACE,eAAJ,GAAsB;QACpBjE,IADoB;QAEpBkD,OAFoB;QAGpB1D,IAAI,EAAE,KAAKD,IAAL,CAAUyB,eAAV,CAA0BxB;MAHZ,CAAtB;IAKD;;IAED,IAAI,KAAKwB,eAAT,EAA0B;MACxB,OAAO,KAAKA,eAAL,CAAqB4C,OAArB,CAA6BL,IAA7B,EAAmCM,IAAnC,CAAP;IACD;;IAED,IAAIA,IAAI,CAACK,QAAL,CAAc,IAAd,CAAJ,EAAyB;MACvB,OAAOH,GAAP;IACD;;IAEDA,GAAG,CAACD,QAAJ,GAAe,KAAKA,QAApB;IACAC,GAAG,CAACI,WAAJ,GAAkB,KAAKA,WAAvB,CApCsB,CAsCtB;;IACAN,IAAI,GAAGA,IAAI,CAACO,MAAL,CAAY,IAAZ,CAAP;IAEAL,GAAG,CAACM,UAAJ,GAAiB,EAAjB;;IACA,IAAId,IAAJ,EAAU;MACRQ,GAAG,CAACM,UAAJ,CAAeC,IAAf,CAAoBf,IAAI,CAACK,OAAL,CAAaC,IAAb,CAApB;IACD,CAFD,MAEO;MACL;MACA;MACA,MAAMU,KAAK,GAAG,EAAd;;MACA,KAAK,MAAMhB,IAAX,IAAmB,KAAKzB,OAAxB,EAAiC;QAC/B,IAAI,CAACyB,IAAI,CAACiB,KAAN,IAAe,CAACjB,IAAI,CAACkB,IAAL,CAAUnC,aAA9B,EAA6C;UAC3C;QACD;;QAEDiC,KAAK,CAACD,IAAN,CAAWf,IAAX;MACD;;MACD,KAAK,MAAMA,IAAX,IAAmBgB,KAAnB,EAA0B;QACxBR,GAAG,CAACM,UAAJ,CAAeC,IAAf,CAAoBf,IAAI,CAACK,OAAL,CAAaC,IAAb,CAApB;MACD;IACF;;IAED,IAAI,KAAKxD,OAAL,CAAaqE,IAAjB,EAAuB;MACrBX,GAAG,CAAC1D,OAAJ,GAAc,CAAC,GAAG,KAAKA,OAAT,EAAkBsE,GAAlB,CAAsBC,IAAI,IAAIA,IAAI,CAAChG,QAAD,CAAJ,CAAe2E,IAAf,EAAqBM,IAArB,CAA9B,CAAd;IACD;;IAED,OAAOE,GAAP;EACD;;EAEDc,cAAc,CAAEC,IAAF,EAAQ;IACpB,KAAK,IAAIC,CAAC,GAAG,IAAb,EAAmBA,CAAnB,EAAsBA,CAAC,GAAGA,CAAC,CAACC,aAA5B,EAA2C;MACzC,IAAID,CAAC,KAAKD,IAAV,EAAgB;QACd,OAAO,IAAP;MACD;IACF;;IACD,OAAO,KAAP;EACD;;EAEDG,UAAU,GAAa;IAAA,IAAXzF,IAAW,uEAAJ,EAAI;;IACrB;IACA,IAAIA,IAAI,CAAC0E,QAAL,CAAc,IAAd,CAAJ,EAAyB;MACvB,OAAO,IAAP;IACD;;IAED1E,IAAI,CAAC8E,IAAL,CAAU,IAAV;IAEA,MAAM5E,MAAM,GAAG,KAAK5B,OAAL,CAAf;;IACA,IAAI,CAAC4B,MAAL,EAAa;MACX,OAAO,IAAP;IACD;;IAED,MAAMwF,QAAQ,GAAGxF,MAAM,CAACuF,UAAP,CAAkBzF,IAAlB,CAAjB;;IACA,IAAI0F,QAAJ,EAAc;MACZ,OAAOA,QAAP;IACD;;IAED,MAAMC,IAAI,GAAGzF,MAAM,CAACyB,OAApB;IACA,MAAMiE,EAAE,GAAGD,IAAI,IAAIA,IAAI,CAACE,kBAAxB,CAnBqB,CAoBrB;;IACA,IAAIC,KAAK,CAACC,OAAN,CAAcH,EAAd,KAAqBA,EAAE,CAAClB,QAAH,CAAY,KAAKlE,IAAjB,CAAzB,EAAiD;MAC/C,OAAON,MAAP;IACD,CAvBoB,CAyBrB;IACA;IACA;IACA;;;IACA,KAAK,MAAM6D,IAAX,IAAmB,KAAKzB,OAAxB,EAAiC;MAC/B,MAAM0D,QAAQ,GAAGjC,IAAI,CAACkB,IAAL,CAAUQ,UAAV,CAAqBzF,IAArB,CAAjB;;MACA,IAAI,CAACgG,QAAL,EAAe;QACb;MACD;;MAED,IAAIA,QAAQ,KAAK9F,MAAjB,EAAyB;QACvB,OAAO8F,QAAP;MACD;IACF;;IAED,OAAO,IAAP;EACD;;EAEW,IAARC,QAAQ,GAAI;IACd,OAAO,CAAC,CAAC,KAAKR,UAAL,EAAT;EACD,CAzaQ,CA2aT;EACA;EACA;;;EACe,IAAXS,WAAW,GAAI;IACjB,MAAMC,OAAO,GAAG,KAAKV,UAAL,EAAhB;IACA,OAAO,CAAC,CAACU,OAAF,IAAaA,OAAO,KAAK,KAAKpG,IAArC;EACD;;EAEc,IAAX4E,WAAW,GAAI;IACjB,IAAI,KAAK7B,aAAT,EAAwB;MACtB,OAAO,KAAP;IACD;;IACD,MAAM;MAAE/C;IAAF,IAAW,IAAjB;IACA,MAAM;MAAEqG,IAAF;MAAQC;IAAR,IAAetG,IAAI,CAACwC,QAAL,CAAcU,GAAd,CAAkB,KAAKU,WAAvB,KAAuC,EAA5D;IACA,OAAOyC,IAAI,KAAK,WAAT,IAAwBC,EAAxB,KAA+BA,EAAE,CAACC,MAAH,KAAc,IAAd,IAAsBD,EAAE,KAAK,IAA5D,CAAP;EACD;;EAES,IAANE,MAAM,GAAI;IACZ,OAAO,SAAS,KAAKxG,IAArB;EACD;;EAEgB,IAAb+C,aAAa,GAAI;IACnB;IACA;IACA;IACA,OAAO,SAAS,KAAK/C,IAAd,IAAsB,SAAS,KAAKA,IAAL,CAAUuG,MAAhD;EACD;;EAEuB,IAApBE,oBAAoB,GAAI;IAC1B,IAAI,KAAKlE,OAAL,CAAa4C,IAAb,KAAsB,CAA1B,EAA6B;MAC3B,OAAO,KAAP;IACD;;IACD,KAAK,MAAMnB,IAAX,IAAmB,KAAKzB,OAAxB,EAAiC;MAC/B,IAAI,CAAC5E,GAAG,CAACqG,IAAI,CAAC0C,IAAN,CAAH,CAAeC,QAApB,EAA8B;QAC5B,OAAO,KAAP;MACD;IACF;;IACD,OAAO,IAAP;EACD;;EAES,CAARC,QAAQ,GAAI;IACZ,KAAK,IAAIC,GAAG,GAAG,IAAf,EAAqBA,GAArB,EAA0BA,GAAG,GAAGA,GAAG,CAACpB,aAApC,EAAmD;MACjD,MAAMoB,GAAN;IACD;EACF;;EAEO,IAAJ7G,IAAI,CAAEA,IAAF,EAAQ;IACd;IACA;IACA,OAAOA,IAAI,IAAIA,IAAI,CAACA,IAAL,KAAcA,IAA7B,EAAmC;MACjCA,IAAI,GAAGA,IAAI,CAACA,IAAZ;IACD;;IAEDA,IAAI,GAAGA,IAAI,IAAI,IAAf,CAPc,CASd;;IACA,KAAKd,eAAL,IAVc,CAYd;IACA;IACA;;;IACA,IAAI,CAAC,KAAKe,IAAN,IAAc,CAACD,IAAI,CAACE,QAApB,IAAgC,CAACF,IAAI,CAACC,IAA1C,EAAgD;MAC9C,OAAO,KAAKlB,KAAL,IAAciB,IAArB;IACD,CAjBa,CAmBd;;;IACA,KAAKjB,KAAL,IAAc,IAAd,CApBc,CAsBd;;IACA,KAAK,MAAMsG,IAAX,IAAmB,KAAKvE,OAAxB,EAAiC;MAC/BuE,IAAI,CAAC7G,OAAD,CAAJ,GAAgB,IAAhB;MACA,KAAKsC,OAAL,CAAagG,MAAb,CAAoBzB,IAApB;IACD,CA1Ba,CA4Bd;;;IACA,MAAM;MAAEkB;IAAF,IAAa,IAAnB;;IACA,IAAI,KAAKzE,MAAT,EAAiB;MACf,IAAIyE,MAAJ,EAAY;QACVA,MAAM,CAACzF,OAAP,CAAegG,MAAf,CAAsB,IAAtB;;QACA,IAAIP,MAAM,CAACvG,IAAP,KAAgB,IAApB,EAA0B;UACxBuG,MAAM,CAACrH,eAAD,CAAN;QACD;MACF;;MACD,KAAKV,OAAL,IAAgB,IAAhB;IACD,CAtCa,CAwCd;IACA;IACA;;;IACA,IAAI,KAAK2B,MAAL,IAAe,KAAKA,MAAL,CAAYH,IAAZ,KAAqBA,IAAxC,EAA8C;MAC5C,KAAKG,MAAL,CAAYO,QAAZ,CAAqBoG,MAArB,CAA4B,KAAKrG,IAAjC;MACA,KAAKlC,OAAL,IAAgB,IAAhB;IACD;;IACD,IAAI,KAAK+B,QAAL,IAAiB,KAAKA,QAAL,CAAcN,IAAd,KAAuBA,IAA5C,EAAkD;MAChD,KAAKM,QAAL,CAAcK,UAAd,CAAyBmG,MAAzB,CAAgC,IAAhC;MACA,KAAKpI,SAAL,IAAkB,IAAlB;IACD;;IAED,IAAIsB,IAAI,KAAK,IAAb,EAAmB;MACjB,KAAKhB,gBAAL;IACD,CAFD,MAEO;MACL;MACA,MAAM+H,GAAG,GAAGvH,OAAO,CAACQ,IAAI,CAACE,QAAN,EAAgB,KAAKD,IAArB,CAAnB;MACA,MAAM+G,OAAO,GAAGhH,IAAI,CAACqC,SAAL,CAAea,GAAf,CAAmB6D,GAAnB,CAAhB,CAHK,CAKL;;MACA,IAAIC,OAAJ,EAAa;QACXA,OAAO,CAAChH,IAAR,GAAe,IAAf;MACD;;MAED,KAAKjB,KAAL,IAAciB,IAAd,CAVK,CAWL;;MACA,KAAKhB,gBAAL,IAZK,CAcL;;;MACA,KAAK,MAAMwG,CAAX,IAAgBzH,MAAM,CAACG,OAAO,CAAC,KAAK+B,IAAN,CAAR,CAAtB,EAA4C;QAC1C,IAAIuF,CAAC,KAAK,KAAKvF,IAAf,EAAqB;UACnB;QACD;;QACD,MAAMgH,IAAI,GAAGzH,OAAO,CAACQ,IAAI,CAACE,QAAN,EAAgBsF,CAAhB,CAApB;QACA,MAAMrF,MAAM,GAAGH,IAAI,CAACqC,SAAL,CAAea,GAAf,CAAmB+D,IAAnB,CAAf;;QACA,IAAI9G,MAAJ,EAAY;UACV;UACA,IAAIA,MAAM,CAAC2B,MAAX,EAAmB;YACjBlE,KAAK,CAAC,MAAM;cACV,MAAM6E,MAAM,CAACyE,MAAP,CAAc,IAAIhD,KAAJ,CAAU,6BAAV,CAAd,EAAwD;gBAC5DjE,IAAI,EAAE,KAAKA,IADiD;gBAE5DE,MAAM,EAAEA,MAAM,CAACF,IAF6C;gBAG5DkH,UAAU,EAAEhH,MAAM,CAACD;cAHyC,CAAxD,CAAN;YAKD,CANI,CAAL;YAOA;UACD;;UACD,MAAMkH,QAAQ,GAAI,GAAEH,IAAK,GAAEA,IAAI,GAAG,GAAH,GAAS,EAAG,gBAAe,KAAKxG,IAAK,EAApE;UACA,MAAM4G,QAAQ,GAAG,KAAK9C,QAAL,KAAkB6C,QAAnC;;UACA,IAAIC,QAAJ,EAAc;YACZ,MAAMC,QAAQ,GAAGnH,MAAM,CAACO,QAAP,CAAgBwC,GAAhB,CAAoB,KAAKzC,IAAzB,CAAjB;;YACA,IAAI6G,QAAQ,IAAIA,QAAQ,KAAK,IAA7B,EAAmC;cACjCA,QAAQ,CAACtH,IAAT,GAAgB,IAAhB;YACD;;YACD,IAAI,KAAKG,MAAT,EAAiB;cACf,KAAKA,MAAL,CAAYO,QAAZ,CAAqBoG,MAArB,CAA4B,KAAKrG,IAAjC;;cACA,KAAKN,MAAL,CAAYtB,iBAAZ,EAA+B,KAAK4B,IAApC;YACD;;YACDN,MAAM,CAACO,QAAP,CAAgB6G,GAAhB,CAAoB,KAAK9G,IAAzB,EAA+B,IAA/B;YACA,KAAKlC,OAAL,IAAgB4B,MAAhB,CAVY,CAWZ;YACA;;YACA,IAAI,CAAC,KAAK2B,MAAV,EAAkB;cAChB3B,MAAM,CAACtB,iBAAD,CAAN,CAA0B,KAAK4B,IAA/B;YACD;UACF,CAhBD,MAgBO;YACL;AACZ;YACY,IAAI,KAAKH,QAAT,EAAmB;cACjB,KAAKA,QAAL,CAAcK,UAAd,CAAyBmG,MAAzB,CAAgC,IAAhC;YACD;;YACD3G,MAAM,CAACQ,UAAP,CAAkBkC,GAAlB,CAAsB,IAAtB;YACA,KAAKnE,SAAL,IAAkByB,MAAlB;UACD;;UACD;QACD;MACF,CA9DI,CAgEL;;;MACA,IAAI,CAAC,KAAKA,MAAV,EAAkB;QAChBH,IAAI,CAACsC,IAAL,CAAUO,GAAV,CAAc,IAAd;MACD,CAFD,MAEO;QACL7C,IAAI,CAACsC,IAAL,CAAUwE,MAAV,CAAiB,IAAjB;MACD,CArEI,CAuEL;MACA;MACA;MACA;MACA;;;MACA,MAAMU,KAAK,GAAI,GAAE,KAAKjD,QAAS,GAAE,KAAKA,QAAL,GAAgB,GAAhB,GAAsB,EAAG,eAA1D;;MACA,MAAMkD,OAAO,GAAGC,CAAC,IAAIA,CAAC,CAACnD,QAAF,KAAeiD,KAAK,GAAGE,CAAC,CAACjH,IAA9C,CA7EK,CA8EL;;;MACA,MAAMkH,SAAS,GAAGD,CAAC,IAAI;QACrB,OAAOxJ,OAAO,CAACwJ,CAAC,CAACzH,IAAH,CAAP,CAAgB2H,UAAhB,CAA2B,KAAK3H,IAAhC,KACLyH,CAAC,KAAK,IADD,IAEL,CAACA,CAAC,CAACvH,MAFE,KAGJ,CAACuH,CAAC,CAACpH,QAAH,IACCoH,CAAC,CAACpH,QAAF,KAAe,IADhB,IAECpC,OAAO,CAAC,KAAK+B,IAAN,CAAP,CAAmB2H,UAAnB,CAA8BF,CAAC,CAACpH,QAAF,CAAWL,IAAzC,CALG,CAAP;MAMD,CAPD;;MAQA,MAAM4H,KAAK,GAAGH,CAAC,IAAID,OAAO,CAACC,CAAD,CAAP,IAAcC,SAAS,CAACD,CAAD,CAA1C,CAvFK,CAyFL;;;MACA,KAAK,MAAMI,KAAX,IAAoB9H,IAAI,CAACsC,IAAzB,EAA+B;QAC7B,IAAI,CAACuF,KAAK,CAACC,KAAD,CAAV,EAAmB;UACjB;QACD,CAH4B,CAK7B;;;QACA,IAAI,KAAKhG,MAAT,EAAiB;UACfgG,KAAK,CAAC9H,IAAN,GAAa,IAAb;QACD,CAFD,MAEO;UACL;UACA,IAAI8H,KAAK,CAACxH,QAAV,EAAoB;YAClBwH,KAAK,CAACxH,QAAN,CAAeK,UAAf,CAA0BmG,MAA1B,CAAiCgB,KAAjC;UACD;;UACDA,KAAK,CAACpJ,SAAD,CAAL,GAAmB,IAAnB;;UACA,IAAI+I,OAAO,CAACK,KAAD,CAAX,EAAoB;YAClB,KAAKpH,QAAL,CAAc6G,GAAd,CAAkBO,KAAK,CAACrH,IAAxB,EAA8BqH,KAA9B;YACAA,KAAK,CAACvJ,OAAD,CAAL,GAAiB,IAAjB;YACAyB,IAAI,CAACsC,IAAL,CAAUwE,MAAV,CAAiBgB,KAAjB;UACD,CAJD,MAIO;YACL,KAAKnH,UAAL,CAAgBkC,GAAhB,CAAoBiF,KAApB;YACAA,KAAK,CAACpJ,SAAD,CAAL,GAAmB,IAAnB;UACD;QACF;MACF,CAjHI,CAmHL;MACA;MACA;;;MACA,KAAK,MAAM6G,IAAX,IAAmBvF,IAAI,CAACqC,SAAL,CAAe0F,KAAf,CAAqB,UAArB,EAAiC,KAAK7H,QAAtC,CAAnB,EAAoE;QAClE,IAAIqF,IAAI,KAAK,IAAb,EAAmB;UACjB;QACD;QAED;;;QACA3H,KAAK,CAAC,MAAM;UACV,IAAI2H,IAAI,CAACvF,IAAL,KAAcA,IAAlB,EAAwB;YACtB,MAAM,IAAIkE,KAAJ,CAAU,yCAAV,CAAN;UACD;QACF,CAJI,CAAL;;QAMA,IAAI,KAAKpC,MAAT,EAAiB;UACf,MAAMyE,MAAM,GAAGhB,IAAI,CAACgB,MAApB;UACA,KAAK/H,OAAL,IAAgB+H,MAAhB;UACA,KAAKlI,QAAL,IAAiBkI,MAAM,CAAC3E,OAAxB;UACA2E,MAAM,CAACzF,OAAP,CAAe+B,GAAf,CAAmB,IAAnB,EAJe,CAKf;;UACA,IAAI,KAAK1C,MAAT,EAAiB;YACf,KAAKA,MAAL,CAAYtB,iBAAZ,EAA+B,KAAK4B,IAApC;UACD;;UACD;QACD,CAVD,MAUO;UACL;UACA,IAAI8E,IAAI,CAACzD,MAAT,EAAiB;YACfyD,IAAI,CAAC/G,OAAD,CAAJ,GAAgB,IAAhB;YACA+G,IAAI,CAAClH,QAAD,CAAJ,GAAiB,KAAKuD,OAAtB;YACA,KAAKd,OAAL,CAAa+B,GAAb,CAAiB0C,IAAjB;;YACA,IAAIA,IAAI,CAACpF,MAAT,EAAiB;cACfoF,IAAI,CAACpF,MAAL,CAAYtB,iBAAZ,EAA+B0G,IAAI,CAAC9E,IAApC;YACD;UACF,CAPD,MAOO;YACL7C,KAAK,CAAC,MAAM;cACV,MAAM6E,MAAM,CAACyE,MAAP,CAAc,IAAIhD,KAAJ,CAAU,+BAAV,CAAd,EAA0D;gBAC9DjE,IAAI,EAAE,KAAKA,IADmD;gBAE9DC,QAAQ,EAAE,KAAKA,QAF+C;gBAG9DF,IAAI,EAAEA,IAAI,CAACE;cAHmD,CAA1D,CAAN;YAKD,CANI,CAAL;UAOD;QACF;MACF;IACF,CAtNa,CAwNd;IACA;;;IACA,KAAK,MAAM8D,IAAX,IAAmB,KAAKzB,OAAxB,EAAiC;MAC/B,IAAIyB,IAAI,CAACkB,IAAL,CAAUlF,IAAV,KAAmBA,IAAvB,EAA6B;QAC3BgE,IAAI,CAACI,MAAL;MACD;IACF,CA9Na,CA+Nd;IACA;;;IACA,KAAK,MAAMJ,IAAX,IAAmB,KAAKxB,QAAL,CAAcyB,MAAd,EAAnB,EAA2C;MACzC,IAAI,CAACD,IAAI,CAACsC,EAAN,IAAYtC,IAAI,CAACsC,EAAL,CAAQtG,IAAR,KAAiBA,IAAjC,EAAuC;QACrCgE,IAAI,CAACI,MAAL;MACD;IACF,CArOa,CAuOd;;;IACA,MAAM4D,MAAM,GAAG,IAAI5F,GAAJ,CAAQ,CACrB,GAAG,KAAKzB,UADa,EAErB,GAAG,KAAKD,QAAL,CAAcuD,MAAd,EAFkB,EAGrB,GAAG,KAAK5B,SAAL,CAAe4B,MAAf,EAHkB,EAIrBgE,MAJqB,CAIdP,CAAC,IAAIA,CAAC,KAAK,IAJG,CAAR,CAAf;;IAMA,KAAK,MAAMI,KAAX,IAAoBE,MAApB,EAA4B;MAC1B,IAAIF,KAAK,CAAC9H,IAAN,KAAeA,IAAnB,EAAyB;QACvB8H,KAAK,CAAC5I,eAAD,CAAL;;QACA4I,KAAK,CAACvJ,OAAD,CAAL,GAAiB,IAAjB;QACA,KAAKmC,QAAL,CAAcoG,MAAd,CAAqBgB,KAAK,CAACrH,IAA3B;QACAqH,KAAK,CAACpJ,SAAD,CAAL,GAAmB,IAAnB;QACA,KAAKiC,UAAL,CAAgBmG,MAAhB,CAAuBgB,KAAvB;;QACA,KAAK,MAAMI,CAAX,IAAgBJ,KAAK,CAAChH,OAAtB,EAA+B;UAC7BoH,CAAC,CAAC1J,OAAD,CAAD,GAAa,IAAb;UACAsJ,KAAK,CAAChH,OAAN,CAAcgG,MAAd,CAAqBoB,CAArB;QACD;MACF;IACF;;IACD,KAAK,MAAMJ,KAAX,IAAoBE,MAApB,EAA4B;MAC1B,IAAIF,KAAK,CAAC9H,IAAN,KAAeA,IAAnB,EAAyB;QACvB8H,KAAK,CAAC9H,IAAN,GAAaA,IAAb;MACD;IACF,CA/Pa,CAiQd;IACA;IACA;;;IACA,IAAI,KAAK8B,MAAL,IAAeyE,MAAf,IAAyB,CAAC,KAAKA,MAA/B,IAAyCvG,IAAI,KAAK,IAAtD,EAA4D;MAC1DuG,MAAM,CAACvG,IAAP,GAAcA,IAAd;IACD;;IAED,IAAI,CAAC,KAAKgB,SAAN,IAAmB,KAAKb,MAAxB,IAAkC,KAAKA,MAAL,CAAYa,SAAlD,EAA6D;MAC3D,KAAKA,SAAL,GAAiB,KAAKb,MAAL,CAAYa,SAAZ,CAAsBmH,WAAtB,CAAkC,IAAlC,CAAjB;IACD,CA1Qa,CA2Qd;;;IACArK,SAAS,CAAC,IAAD,CAAT;IACAA,SAAS,CAACkC,IAAD,CAAT;EACD;;EAEO,IAAJA,IAAI,GAAI;IACV,OAAO,KAAKjB,KAAL,KAAe,IAAtB;EACD;;EAEe,CAAfH,eAAe,IAAK;IACnB,IAAI,CAAC,KAAKQ,WAAL,CAAL,EAAwB;MACtB;IACD;;IAED,KAAK,MAAM,CAACqB,IAAD,EAAOR,IAAP,CAAX,IAA2B,KAAKb,WAAL,EAAkBgJ,OAAlB,EAA3B,EAAwD;MACtD,IAAI/K,IAAJ,CAAS;QAAE6H,IAAI,EAAE,IAAR;QAAczE,IAAd;QAAoBiG,IAAI,EAAG,QAAOzG,IAAI,CAACoI,OAAL,CAAa,IAAb,EAAmB,KAAnB,CAA0B,EAA5D;QAA+DhC,IAAI,EAAE;MAArE,CAAT;IACD;EACF;;EAES,CAATvH,SAAS,IAAK;IACb;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA,MAAMwJ,EAAE,GAAG,KAAK1G,OAAL,CAAa2G,gBAAxB;;IACA,IAAID,EAAE,IAAI,OAAOA,EAAP,KAAc,QAApB,IAAgC,CAAC,KAAKzH,cAA1C,EAA0D;MACxD,MAAM2H,EAAE,GAAG,KAAK5G,OAAL,CAAa6G,oBAAb,IAAqC,EAAhD;MACA,MAAMF,gBAAgB,GAAG,EAAzB;MACA,MAAMG,YAAY,GAAG,EAArB;;MACA,KAAK,MAAM,CAACjI,IAAD,EAAOkI,GAAP,CAAX,IAA0BlG,MAAM,CAAC2F,OAAP,CAAeE,EAAf,CAA1B,EAA8C;QAC5C,IAAIE,EAAE,CAAC/H,IAAD,CAAF,IAAY+H,EAAE,CAAC/H,IAAD,CAAF,CAASW,QAAzB,EAAmC;UACjCsH,YAAY,CAACjI,IAAD,CAAZ,GAAqBkI,GAArB;QACD,CAFD,MAEO;UACLJ,gBAAgB,CAAC9H,IAAD,CAAhB,GAAyBkI,GAAzB;QACD;MACF;;MACD,KAAKhK,YAAL,EAAmB4J,gBAAnB,EAAqC,MAArC;;MACA,KAAK5J,YAAL,EAAmB+J,YAAnB,EAAiC,cAAjC;IACD;;IAED,KAAK/J,YAAL,EAAmB,KAAKiD,OAAL,CAAagH,YAAhC,EAA8C,MAA9C;;IACA,KAAKjK,YAAL,EAAmB,KAAKiD,OAAL,CAAaiH,oBAAhC,EAAsD,UAAtD;;IAEA,MAAM;MAAE/F,SAAF;MAAa2B,KAAb;MAAoBxE,IAApB;MAA0BwB;IAA1B,IAA8C,IAApD;IACA,MAAM;MACJqB,SAAS,EAAEgG,YADP;MAEJrE,KAAK,EAAEsE,MAFH;MAGJ9I,IAAI,EAAE+I;IAHF,IAIFvH,eAAe,IAAI,EAJvB;IAKA,MAAMwH,OAAO,GAAGxE,KAAK,IAAI,CAAC3B,SAAV,IAAuB7C,IAAvC;IACA,MAAMiJ,MAAM,GAAG,CAACzH,eAAD,IAAoBsH,MAAM,IAAI,CAACD,YAAX,IAA2BE,OAA9D;;IACA,IAAIC,OAAO,IAAIC,MAAf,EAAuB;MACrB,KAAKvK,YAAL,EAAmB,KAAKiD,OAAL,CAAauH,eAAhC,EAAiD,KAAjD;IACD;EACF;;EAEY,CAAZxK,YAAY,EAAGyK,IAAH,EAAS/C,IAAT,EAAe;IAC1B,MAAMgD,EAAE,GAAG,KAAKzH,OAAL,CAAa0H,kBAAb,IAAmC,EAA9C,CAD0B,CAE1B;IACA;;IACA,KAAK,MAAM,CAAC7I,IAAD,EAAOiG,IAAP,CAAX,IAA2BjE,MAAM,CAAC2F,OAAP,CAAegB,IAAI,IAAI,EAAvB,CAA3B,EAAuD;MACrD,MAAMpC,OAAO,GAAG,KAAKxE,QAAL,CAAcU,GAAd,CAAkBzC,IAAlB,CAAhB;;MACA,IAAI,CAACuG,OAAD,IAAYA,OAAO,CAACX,IAAR,KAAiB,WAAjC,EAA8C;QAC5C,IAAIhJ,IAAJ,CAAS;UAAE6H,IAAI,EAAE,IAAR;UAAczE,IAAd;UAAoBiG,IAApB;UAA0B6C,MAAM,EAAEF,EAAE,CAAC5I,IAAD,CAApC;UAA4C4F;QAA5C,CAAT;MACD;IACF;EACF;;EAEW,IAAR/F,QAAQ,GAAI;IACd,MAAMH,MAAM,GAAG,KAAKzB,SAAL,CAAf;IACA;;IACAd,KAAK,CAAC,MAAM;MACV,IAAIuC,MAAM,KAAK,IAAf,EAAqB;QACnB,MAAM,IAAI+D,KAAJ,CAAU,8BAAV,CAAN;MACD;IACF,CAJI,CAAL;IAKA,OAAO/D,MAAP;EACD;;EAEW,IAARG,QAAQ,CAAEA,QAAF,EAAY;IACtB,IAAI,CAACA,QAAL,EAAe;MACb,IAAI,KAAK5B,SAAL,CAAJ,EAAqB;QACnB,KAAKsB,IAAL,GAAY,IAAZ;MACD;;MACD;IACD;;IAEDpC,KAAK,CAAC,MAAM;MACV,IAAI0C,QAAQ,KAAK,IAAjB,EAAuB;QACrB,MAAM,IAAI4D,KAAJ,CAAU,kCAAV,CAAN;MACD;;MAED,IAAI5D,QAAQ,CAACJ,QAAT,KAAsB,KAAKA,QAA/B,EAAyC;QACvC,MAAM,IAAIgE,KAAJ,CAAU,+BAAV,CAAN;MACD,CAPS,CASV;MACA;;;MACA,IAAI,CAAC,KAAKxF,SAAL,CAAD,IAAoB,KAAKwB,QAAL,CAAcsJ,OAAd,CAAsBlJ,QAAQ,CAACJ,QAA/B,MAA6C,CAArE,EAAwE;QACtE,MAAMuC,MAAM,CAACyE,MAAP,CAAc,IAAIhD,KAAJ,CAAU,6BAAV,CAAd,EAAwD;UAC5DjE,IAAI,EAAE,KAAKA,IADiD;UAE5DC,QAAQ,EAAE,KAAKA,QAF6C;UAG5DI,QAAQ,EAAE;YACRL,IAAI,EAAEK,QAAQ,CAACL,IADP;YAERC,QAAQ,EAAEI,QAAQ,CAACJ;UAFX;QAHkD,CAAxD,CAAN;MAQD;IACF,CArBI,CAAL;;IAuBA,IAAII,QAAQ,CAACwB,MAAb,EAAqB;MACnBxB,QAAQ,GAAGA,QAAQ,CAACiG,MAApB;IACD,CAjCqB,CAmCtB;;;IACA,IAAI,SAASjG,QAAT,IAAqBA,QAAQ,CAACJ,QAAT,KAAsB,KAAKA,QAApD,EAA8D;MAC5D;IACD,CAtCqB,CAwCtB;;;IACA,IAAI,KAAKxB,SAAL,MAAoB4B,QAAxB,EAAkC;MAChC;IACD;;IAED,MAAMmJ,WAAW,GAAG,KAAK/K,SAAL,CAApB;IACA,MAAMgL,OAAO,GAAG,CAACD,WAAD,GAAe,KAAKxJ,IAApB,GACZjC,OAAO,CAACsC,QAAQ,CAACL,IAAV,EAAgBhC,QAAQ,CAACwL,WAAW,CAACxJ,IAAb,EAAmB,KAAKA,IAAxB,CAAxB,CADX;IAEA,MAAM0J,MAAM,GAAG3L,OAAO,CAACsC,QAAQ,CAACL,IAAV,EAAgB,cAAhB,EAAgC,KAAKQ,IAArC,CAAtB,CAhDsB,CAkDtB;;IACA,IAAIiJ,OAAO,KAAKC,MAAhB,EAAwB;MACtB,KAAKxJ,MAAL,GAAcG,QAAd;MACA;IACD;;IAED,MAAMsJ,UAAU,GAAGF,OAAO,KAAK,KAAKzJ,IAApC,CAxDsB,CA0DtB;;IACA,MAAM4J,SAAS,GAAG,KAAK1J,MAAvB;IACA,MAAM2J,OAAO,GAAG,KAAKrJ,IAArB;;IACA,IAAI,KAAKN,MAAT,EAAiB;MACf,KAAKA,MAAL,CAAYO,QAAZ,CAAqBoG,MAArB,CAA4B,KAAKrG,IAAjC;MACA,KAAKlC,OAAL,IAAgB,IAAhB;IACD;;IACD,IAAI,KAAK+B,QAAT,EAAmB;MACjB,KAAKA,QAAL,CAAcK,UAAd,CAAyBmG,MAAzB,CAAgC,IAAhC;MACA,KAAKpI,SAAL,IAAkB,IAAlB;IACD,CApEqB,CAsEtB;;;IACA,IAAIkL,UAAJ,EAAgB;MACd,KAAK3K,WAAL,EAAkByK,OAAlB;IACD;;IAED,IAAIG,SAAJ,EAAe;MACbA,SAAS,CAAChL,iBAAD,CAAT,CAA6BiL,OAA7B;IACD,CA7EqB,CA+EtB;;;IACA,KAAK9J,IAAL,GAAYM,QAAQ,CAACN,IAArB;EACD,CAz4BQ,CA24BT;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA+J,cAAc,CAAExE,IAAF,EAA0B;IAAA,IAAlByE,WAAkB,uEAAJ,EAAI;;IACtC,IAAIzE,IAAI,CAAC9E,IAAL,KAAc,KAAKA,IAAvB,EAA6B;MAC3B,OAAO,KAAP;IACD;;IAED,IAAI8E,IAAI,CAAC3B,WAAL,KAAqB,KAAKA,WAA9B,EAA2C;MACzC,OAAO,KAAP;IACD,CAPqC,CAStC;;;IACA,IAAI2B,IAAI,CAACvE,SAAL,KAAmB,KAAKA,SAA5B,EAAuC;MACrC,OAAO,KAAP;IACD;;IAEDgJ,WAAW,GAAG,IAAI5H,GAAJ,CAAQ4H,WAAR,CAAd,CAdsC,CAgBtC;IACA;IACA;;IACA,MAAMC,MAAM,GAAGpM,YAAY,CAAC,CAAC,IAAD,CAAD,EAASqM,CAAC,IAAIA,CAAC,CAAC5D,EAAF,KAAS,IAAT,IAAiB4D,CAAC,CAACjF,KAAjC,CAA3B;;IAEA,KAAK,MAAMjB,IAAX,IAAmB,KAAKzB,OAAxB,EAAiC;MAC/B;MACA;MACA;MACA,MAAM4H,OAAO,GAAG,CAAC,KAAK1F,KAAN,IACdT,IAAI,CAACkB,IAAL,CAAU/E,MAAV,KAAqB,KAAKA,MADZ,IAEd6D,IAAI,CAAC1C,IAFS,IAGd0I,WAAW,CAAC/G,GAAZ,CAAgBe,IAAI,CAACkB,IAAL,CAAUzE,IAA1B,CAHF;;MAIA,IAAI0J,OAAJ,EAAa;QACX;MACD,CAV8B,CAY/B;;;MACA,IAAI,CAACF,MAAM,CAAChH,GAAP,CAAWe,IAAI,CAACkB,IAAhB,CAAD,IAA0B,CAAClB,IAAI,CAACoG,WAAL,CAAiB7E,IAAjB,CAA/B,EAAuD;QACrD,OAAO,KAAP;MACD;IACF;;IAED,OAAO,IAAP;EACD;;EAED8E,UAAU,CAAE9E,IAAF,EAAQyE,WAAR,EAAqB;IAC7B,OAAOzE,IAAI,CAACwE,cAAL,CAAoB,IAApB,EAA0BC,WAA1B,CAAP;EACD,CAh8BQ,CAk8BT;EACA;EACA;;;EACAM,SAAS,GAAwB;IAAA,IAAtBC,YAAsB,uEAAP,KAAO;;IAC/B;IACA,IAAI,KAAKpE,WAAL,IAAoB,KAAKqE,YAA7B,EAA2C;MACzC,OAAO,KAAP;IACD,CAJ8B,CAM/B;;;IACA,IAAI,CAAC,KAAK/E,aAAN,IAAuB,CAAC,KAAKA,aAAL,CAAmBA,aAA/C,EAA8D;MAC5D,OAAO,KAAP;IACD,CAT8B,CAW/B;;;IACA,IAAI,KAAKlD,OAAL,CAAa4C,IAAb,KAAsB,CAA1B,EAA6B;MAC3B,OAAO,IAAP;IACD;;IAED,MAAMsF,KAAK,GAAG,KAAKhF,aAAL,CAAmBA,aAAnB,CAAiCzH,OAAjC,CAAyC,KAAKyC,IAA9C,CAAd,CAhB+B,CAkB/B;;IACA,IAAI,CAACgK,KAAL,EAAY;MACV,OAAO,KAAP;IACD,CArB8B,CAuB/B;;;IACA,IAAIA,KAAK,CAACC,OAAN,CAAc,IAAd,CAAJ,EAAyB;MACvB,OAAO,IAAP;IACD,CA1B8B,CA4B/B;;;IACA,IAAI,CAACD,KAAK,CAACJ,UAAN,CAAiB,IAAjB,CAAL,EAA6B;MAC3B,OAAO,KAAP;IACD,CA/B8B,CAiC/B;;;IACA,IAAIE,YAAY,IAAIrN,MAAM,CAACyN,GAAP,CAAWF,KAAK,CAAC9G,OAAjB,EAA0B,KAAKA,OAA/B,CAApB,EAA6D;MAC3D,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD;;EAEDiH,SAAS,CAAEC,SAAF,EAAa;IACpB,IAAIA,SAAS,YAAYxN,IAAzB,EAA+B;MAC7B,OAAO,KAAKoD,IAAL,KAAcoK,SAAS,CAACpK,IAAxB,IAAgCoK,SAAS,CAACT,WAAV,CAAsB,IAAtB,CAAvC;IACD;;IAED,MAAMU,MAAM,GAAGnN,GAAG,CAACkN,SAAD,CAAlB;IACA,MAAM;MAAEpK,IAAI,GAAG,KAAKA,IAAd;MAAoBsK,OAAO,EAAErE;IAA7B,IAAsCoE,MAA5C;IACA,OAAO,KAAKrK,IAAL,KAAcA,IAAd,IAAsB,KAAKmK,SAAL,CAAe,IAAIvN,IAAJ,CAAS;MACnD6H,IAAI,EAAE,IAAIrF,IAAJ,CAAS;QAAEI,IAAI,EAAE,KAAKD,IAAL,CAAUE;MAAlB,CAAT,CAD6C;MAEnDmG,IAAI,EAAE,MAF6C;MAGnD5F,IAHmD;MAInDiG;IAJmD,CAAT,CAAf,CAA7B;EAMD;;EAEDgE,OAAO,CAAEnF,IAAF,EAAQ;IACb;IACA,IAAIA,IAAI,KAAK,IAAb,EAAmB;MACjB,OAAO,IAAP;IACD,CAJY,CAMb;IACA;;;IACA,IAAIA,IAAI,CAAC9E,IAAL,KAAc,KAAKA,IAAvB,EAA6B;MAC3B,OAAO,KAAP;IACD,CAVY,CAYb;;;IACA,IAAI,KAAKqB,MAAT,EAAiB;MACf,OAAOyD,IAAI,CAACzD,MAAL,IAAe,KAAKyE,MAAL,CAAYmE,OAAZ,CAAoBnF,IAAI,CAACgB,MAAzB,CAAtB;IACD,CAfY,CAiBb;;;IACA,IAAI,KAAKxD,aAAL,IAAsBwC,IAAI,CAACxC,aAA/B,EAA8C;MAC5C,OAAO,KAAK9C,IAAL,KAAcsF,IAAI,CAACtF,IAA1B;IACD,CApBY,CAsBb;;;IACA,IAAI,KAAKO,SAAL,IAAkB+E,IAAI,CAAC/E,SAA3B,EAAsC;MACpC,OAAO,KAAKA,SAAL,KAAmB+E,IAAI,CAAC/E,SAA/B;IACD,CAzBY,CA2Bb;;;IACA,IAAI,KAAKD,QAAL,IAAiBgF,IAAI,CAAChF,QAA1B,EAAoC;MAClC,OAAO,KAAKA,QAAL,KAAkBgF,IAAI,CAAChF,QAA9B;IACD,CA9BY,CAgCb;IACA;;;IACA,OAAO,KAAKqD,WAAL,IAAoB2B,IAAI,CAAC3B,WAAzB,IACL,KAAKA,WAAL,KAAqB2B,IAAI,CAAC3B,WADrB,IAEL,KAAKD,OAFA,IAEW4B,IAAI,CAAC5B,OAFhB,IAGL,KAAKA,OAAL,KAAiB4B,IAAI,CAAC5B,OAHxB;EAID,CAniCQ,CAqiCT;EACA;EACA;;;EACAqH,WAAW,CAAEzF,IAAF,EAAQ;IACjBA,IAAI,CAAC8C,OAAL,CAAa,IAAb;EACD;;EAEDA,OAAO,CAAE9C,IAAF,EAAQ;IACb,KAAKrG,eAAL,IADa,CAGb;IACA;IACA;IACA;;;IACA,MAAM+L,SAAS,GAAG1F,IAAI,CAACpF,MAAL,IAChBoF,IAAI,CAACpF,MAAL,CAAYO,QAAZ,CAAqBwC,GAArB,CAAyB,KAAKzC,IAA9B,MAAwC8E,IAD1C;;IAEA,IAAI0F,SAAJ,EAAe;MACb,KAAKhL,IAAL,GAAYjC,OAAO,CAACuH,IAAI,CAACpF,MAAL,CAAYF,IAAb,EAAmB,cAAnB,EAAmC,KAAKQ,IAAxC,CAAnB;IACD,CAFD,MAEO;MACL,KAAKR,IAAL,GAAYsF,IAAI,CAACtF,IAAjB;MACA,KAAKQ,IAAL,GAAY8E,IAAI,CAAC9E,IAAjB;IACD;;IAED,IAAI,CAAC,KAAKqB,MAAV,EAAkB;MAChB,KAAK5B,QAAL,GAAgB,KAAKD,IAArB;IACD;;IACD,KAAKjB,gBAAL,IAnBa,CAqBb;;;IACA,IAAI,CAAC,KAAK8C,MAAV,EAAkB;MAChB,KAAK,MAAMoJ,GAAX,IAAkB3F,IAAI,CAAC7E,QAAL,CAAcuD,MAAd,EAAlB,EAA0C;QACxCiH,GAAG,CAAC/K,MAAJ,GAAa,IAAb;MACD;;MACD,IAAIoF,IAAI,CAACzD,MAAL,IAAeyD,IAAI,CAACgB,MAAxB,EAAgC;QAC9BhB,IAAI,CAACgB,MAAL,CAAYvG,IAAZ,GAAmB,IAAnB;MACD;IACF;;IAED,IAAI,CAACuF,IAAI,CAACiB,MAAV,EAAkB;MAChB,KAAKxG,IAAL,GAAYuF,IAAI,CAACvF,IAAjB;IACD;;IAEDlC,SAAS,CAAC,IAAD,CAAT;EACD;;EAEe,IAAZ0M,YAAY,GAAI;IAClB,OAAO,KAAKrK,MAAL,KACJ,KAAKA,MAAL,CAAYY,aAAZ,IAA6B,KAAKZ,MAAL,CAAYqK,YADrC,CAAP;EAED;;EAES,IAANrK,MAAM,GAAI;IACZ,MAAMA,MAAM,GAAG,KAAK5B,OAAL,CAAf;IACA;;IACAX,KAAK,CAAC,MAAM;MACV,IAAIuC,MAAM,KAAK,IAAf,EAAqB;QACnB,MAAM,IAAI+D,KAAJ,CAAU,4BAAV,CAAN;MACD;IACF,CAJI,CAAL;IAKA,OAAO/D,MAAP;EACD,CAhmCQ,CAkmCT;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACU,IAANA,MAAM,CAAEA,MAAF,EAAU;IAClB;IACA,IAAI,CAACA,MAAL,EAAa;MACX;MACA;MACA,IAAI,KAAK5B,OAAL,CAAJ,EAAmB;QACjB,KAAKyB,IAAL,GAAY,IAAZ;MACD;;MACD;IACD;;IAED,IAAIG,MAAM,CAAC2B,MAAX,EAAmB;MACjB3B,MAAM,GAAGA,MAAM,CAACoG,MAAhB;IACD,CAbiB,CAelB;;;IACA,IAAI,SAASpG,MAAb,EAAqB;MACnB;IACD;;IAED,MAAM0J,SAAS,GAAG,KAAKtL,OAAL,CAAlB,CApBkB,CAsBlB;;IACA,IAAIsL,SAAS,KAAK1J,MAAlB,EAA0B;MACxB;IACD,CAzBiB,CA2BlB;;;IACA,MAAMuJ,OAAO,GAAG1L,OAAO,CAACmC,MAAM,CAACF,IAAR,EAAc,cAAd,EAA8B,KAAKQ,IAAnC,CAAvB;IACA,MAAMmJ,UAAU,GAAGF,OAAO,KAAK,KAAKzJ,IAApC,CA7BkB,CA+BlB;;IACA,IAAI4J,SAAJ,EAAe;MACbA,SAAS,CAACnJ,QAAV,CAAmBoG,MAAnB,CAA0B,KAAKrG,IAA/B;MACA,KAAKlC,OAAL,IAAgB,IAAhB;IACD;;IACD,IAAI,KAAK+B,QAAT,EAAmB;MACjB,KAAKA,QAAL,CAAcK,UAAd,CAAyBmG,MAAzB,CAAgC,IAAhC;MACA,KAAKpI,SAAL,IAAkB,IAAlB;IACD,CAvCiB,CAyClB;;;IACA,IAAIkL,UAAJ,EAAgB;MACd,KAAK3K,WAAL,EAAkByK,OAAlB;IACD;;IAED,IAAIvJ,MAAM,CAACa,SAAX,EAAsB;MACpB,KAAKA,SAAL,GAAiBb,MAAM,CAACa,SAAP,CAAiBmH,WAAjB,CAA6B,IAA7B,CAAjB;IACD,CAhDiB,CAkDlB;;;IACA,KAAKnI,IAAL,GAAYG,MAAM,CAACH,IAAnB;EACD,CAhqCQ,CAkqCT;EACA;;;EACgB,CAAfd,eAAe,IAAK;IACnB,MAAMc,IAAI,GAAG,KAAKA,IAAlB;;IACA,IAAI,CAACA,IAAI,CAACE,QAAN,IAAkB,CAAC,KAAKD,IAA5B,EAAkC;MAChC;IACD;;IACDD,IAAI,CAACqC,SAAL,CAAeyE,MAAf,CAAsB,IAAtB;IACA9G,IAAI,CAACsC,IAAL,CAAUwE,MAAV,CAAiB,IAAjB;;IACA,IAAI9G,IAAI,CAACK,IAAT,EAAe;MACbL,IAAI,CAACK,IAAL,CAAUyG,MAAV,CAAiB,KAAK7G,IAAtB;IACD;IACD;;;IACArC,KAAK,CAAC,MAAM;MACV,IAAI,CAAC,GAAGoC,IAAI,CAACqC,SAAL,CAAe4B,MAAf,EAAJ,EAA6BU,QAA7B,CAAsC,IAAtC,CAAJ,EAAiD;QAC/C,MAAM,IAAIT,KAAJ,CAAU,kBAAV,CAAN;MACD;IACF,CAJI,CAAL;EAKD,CAprCQ,CAsrCT;;;EACY,CAAXjF,WAAW,EAAGyK,OAAH,EAAY;IACtB;IACA,KAAKxK,eAAL;;IACA,MAAMiM,OAAO,GAAG,KAAKlL,IAArB;IACA,KAAKA,IAAL,GAAYyJ,OAAZ;IACA,MAAM0B,WAAW,GAAG,6DAApB;IACA,MAAMC,UAAU,GAAG3B,OAAO,CAAC4B,KAAR,CAAcF,WAAd,CAAnB;;IACA,IAAIC,UAAU,IAAI,KAAK5K,IAAL,KAAc4K,UAAU,CAAC,CAAD,CAA1C,EAA+C;MAC7C,KAAK5K,IAAL,GAAY4K,UAAU,CAAC,CAAD,CAAV,CAAchD,OAAd,CAAsB,KAAtB,EAA6B,GAA7B,CAAZ;IACD,CATqB,CAWtB;;;IACA,IAAI,CAAC,KAAKvG,MAAV,EAAkB;MAChB,KAAK5B,QAAL,GAAgBwJ,OAAhB;;MACA,KAAK,MAAMrE,IAAX,IAAmB,KAAKvE,OAAxB,EAAiC;QAC/BuE,IAAI,CAACnG,eAAD,CAAJ;;QACAmG,IAAI,CAACnF,QAAL,GAAgBwJ,OAAhB;;QACArE,IAAI,CAACrG,gBAAD,CAAJ;MACD;IACF,CAnBqB,CAoBtB;;;IACA,KAAK,MAAM8I,KAAX,IAAoB,KAAKnH,UAAzB,EAAqC;MACnCmH,KAAK,CAAC7I,WAAD,CAAL,CAAmBjB,OAAO,CAAC0L,OAAD,EAAUzL,QAAQ,CAACkN,OAAD,EAAUrD,KAAK,CAAC7H,IAAhB,CAAlB,CAA1B;IACD;;IACD,KAAK,MAAM,CAACQ,IAAD,EAAOqH,KAAP,CAAX,IAA4B,KAAKpH,QAAL,CAAc0H,OAAd,EAA5B,EAAqD;MACnDN,KAAK,CAAC7I,WAAD,CAAL,CAAmBjB,OAAO,CAAC0L,OAAD,EAAU,cAAV,EAA0BjJ,IAA1B,CAA1B;IACD;;IAED,KAAKzB,gBAAL;EACD,CAptCQ,CAstCT;EACA;EACA;;;EACiB,CAAhBA,gBAAgB,IAAK;IACpB,MAAMgB,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAM+G,GAAG,GAAGvH,OAAO,CAACQ,IAAI,CAACE,QAAN,EAAgB,KAAKD,IAArB,CAAnB;IAEA,KAAKsE,QAAL,GAAgBwC,GAAhB;IAEA/G,IAAI,CAACqC,SAAL,CAAeQ,GAAf,CAAmB,IAAnB;;IACA,IAAI7C,IAAI,CAACK,IAAT,EAAe;MACbL,IAAI,CAACK,IAAL,CAAUwC,GAAV,CAAc,IAAd;IACD;EACF;;EAED0I,mBAAmB,GAAI;IACrB,IAAI,CAAC,KAAKxI,aAAN,IAAuB,CAAC,KAAK/B,SAAjC,EAA4C;MAC1C;IACD;;IAED,KAAK,MAAMgD,IAAX,IAAmB,KAAKxB,QAAL,CAAcyB,MAAd,EAAnB,EAA2C;MACzC;MACA;MACA,IAAID,IAAI,CAAC0C,IAAL,KAAc1C,IAAI,CAAC+G,OAAnB,IAA8B,CAAC/G,IAAI,CAAC0C,IAAL,CAAUkB,UAAV,CAAqB,GAArB,CAAnC,EAA8D;QAC5D,MAAMnF,MAAM,CAACyE,MAAP,CAAc,IAAIhD,KAAJ,CAAW,gBAAeF,IAAI,CAACvD,IAAK,IAAGuD,IAAI,CAAC+G,OAAQ,mCAApD,CAAd,EAAuG;UAAES,IAAI,EAAE;QAAR,CAAvG,CAAN;MACD;IACF;EACF;;EAEDC,UAAU,CAAEzH,IAAF,EAAQ;IAChB,IAAI,KAAKhD,SAAT,EAAoB;MAClBgD,IAAI,CAAChD,SAAL,GAAiB,KAAKA,SAAL,CAAe0K,WAAf,CAA2B1H,IAA3B,CAAjB;IACD;;IAED,KAAKxB,QAAL,CAAc+E,GAAd,CAAkBvD,IAAI,CAACvD,IAAvB,EAA6BuD,IAA7B;EACD;;EAED2H,SAAS,CAAE3H,IAAF,EAAQ;IACf,IAAIA,IAAI,CAAChD,SAAT,EAAoB;MAClB,KAAKA,SAAL,GAAiBgD,IAAI,CAAChD,SAAtB;IACD;;IAED,KAAKuB,OAAL,CAAaM,GAAb,CAAiBmB,IAAjB,EALe,CAOf;;IACA,IAAI,KAAKhE,IAAL,CAAUK,IAAd,EAAoB;MAClB,KAAKL,IAAL,CAAUK,IAAV,CAAeuL,OAAf,CAAuB5H,IAAvB;IACD;EACF;;EAEiB,CAAjBnF,iBAAiB,EAAG4B,IAAH,EAAkC;IAAA,IAAzBoL,OAAyB,uEAAf,KAAKtH,QAAU;IAClD,MAAMP,IAAI,GAAG,KAAKxB,QAAL,CAAcU,GAAd,CAAkBzC,IAAlB,CAAb,CADkD,CAElD;;IACA,MAAMqL,eAAe,GAAG9H,IAAI,IAAIA,IAAI,CAACsC,EAAb,IACtBtC,IAAI,CAACsC,EAAL,CAAQ/B,QAAR,KAAsB,GAAEsH,OAAQ,iBAAgB7H,IAAI,CAACvD,IAAK,EAD5D;IAEA,MAAMsL,YAAY,GAAG/H,IAAI,IAAI,KAAKhG,OAAL,CAAayC,IAAb,MAAuBuD,IAAI,CAACsC,EAAzD;IACA,MAAM0F,OAAO,GAAGF,eAAe,IAAI,CAACC,YAApC;;IACA,IAAI/H,IAAI,IAAIgI,OAAZ,EAAqB;MACnBhI,IAAI,CAACI,MAAL,CAAY,IAAZ;IACD;;IACD,KAAK,MAAMxB,CAAX,IAAgB,KAAKlC,QAAL,CAAcuD,MAAd,EAAhB,EAAwC;MACtCrB,CAAC,CAAC/D,iBAAD,CAAD,CAAqB4B,IAArB,EAA2BoL,OAA3B;IACD;;IAED,KAAK,MAAMjJ,CAAX,IAAgB,KAAKjC,UAArB,EAAiC;MAC/BiC,CAAC,CAAC/D,iBAAD,CAAD,CAAqB4B,IAArB,EAA2BoL,OAA3B;IACD;EACF;;EAES,IAAN/J,MAAM,GAAI;IACZ,OAAO,KAAP;EACD;;EAES,IAANyE,MAAM,GAAI;IACZ,OAAO,IAAP;EACD;;EAES,IAANA,MAAM,CAAEmB,CAAF,EAAK;IACb9J,KAAK,CAAC,MAAM;MACV,MAAM6E,MAAM,CAACyE,MAAP,CAAc,IAAIhD,KAAJ,CAAU,qCAAV,CAAd,EAAgE;QACpEjE,IAAI,EAAE,KAAKA;MADyD,CAAhE,CAAN;IAGD,CAJI,CAAL;EAKD;;EAEQ,IAALgM,KAAK,GAAI;IACX,OAAO,KAAKxH,KAAL,GAAa,CAAb,GAAiB,KAAKtE,MAAL,CAAY8L,KAAZ,GAAoB,CAA5C;EACD;;EAEQ,IAALxH,KAAK,GAAI;IACX,OAAO,CAAC,KAAKtE,MAAN,IAAgB,KAAK2C,SAA5B;EACD;;EAEM,IAAHO,GAAG,GAAI;IACT,OAAO,KAAKoB,KAAL,GAAa,IAAb,GAAoB,KAAKtE,MAAL,CAAYkD,GAAvC;EACD;;EAEU,IAAP6I,OAAO,GAAI;IACb,OAAO,CAAC,KAAK5L,QAAb;EACD;;EAEQ,IAAL6L,KAAK,GAAI;IACX,OAAO,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAK5L,QAAL,CAAc6L,KAA3C;EACD;;EAEgB,IAAb1G,aAAa,GAAI;IACnB,OAAO,KAAKtF,MAAL,IAAe,KAAKG,QAA3B;EACD;;EAEDtC,OAAO,CAAEyC,IAAF,EAAQ;IACb;AACJ;IACI7C,KAAK,CAAC,MAAM;MACV,IAAI,OAAO6C,IAAP,KAAgB,QAAhB,IAA4B,CAACA,IAAjC,EAAuC;QACrC,MAAM,IAAIyD,KAAJ,CAAU,mCAAV,CAAN;MACD;IACF,CAJI,CAAL;IAKA,MAAMkI,IAAI,GAAG,KAAK1L,QAAL,CAAcwC,GAAd,CAAkBzC,IAAlB,CAAb;;IACA,IAAI2L,IAAJ,EAAU;MACR,OAAOA,IAAP;IACD;;IACD,MAAM3G,aAAa,GAAG,KAAKA,aAA3B;;IACA,IAAIA,aAAJ,EAAmB;MACjB,OAAOA,aAAa,CAACzH,OAAd,CAAsByC,IAAtB,CAAP;IACD;;IACD,OAAO,IAAP;EACD;;EAED4L,aAAa,GAAI;IACf,MAAMC,EAAE,GAAG,KAAKpM,QAAhB;IACA,MAAMO,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAM8L,MAAM,GAAG9L,IAAI,CAAC+L,MAAL,CAAY,CAAZ,MAAmB,GAAlC;IACA,MAAMC,CAAC,GAAGvO,OAAO,CAACoO,EAAD,CAAjB;IACA,MAAMI,EAAE,GAAGH,MAAM,GAAGrO,OAAO,CAACuO,CAAD,CAAV,GAAgBA,CAAjC;IACA,MAAME,GAAG,GAAGzO,OAAO,CAACwO,EAAD,CAAnB;IACA,MAAME,IAAI,GAAGL,MAAM,GAAI,GAAEpO,QAAQ,CAACsO,CAAD,CAAI,IAAGtO,QAAQ,CAACmO,EAAD,CAAK,EAAlC,GAAsCnO,QAAQ,CAACmO,EAAD,CAAjE;IACA,OAAOM,IAAI,KAAKnM,IAAT,IAAiBtC,QAAQ,CAACuO,EAAD,CAAR,KAAiB,cAAlC,GAAmDC,GAAnD,GAAyD,KAAhE;EACD,CA/1CQ,CAi2CT;EACA;;;EACA/M,gBAAgB,CAAEmI,KAAF,EAAS;IACvB,OAAOnI,gBAAgB,CAAC,IAAD,EAAOmI,KAAP,CAAvB;EACD;;EAED8E,MAAM,GAAI;IACR,OAAOnN,aAAa,CAAC,IAAD,CAApB;EACD;;EAEmB,CAAnBtB,IAAI,CAAC0O,OAAL,CAAaC,MAAM,IAAK;IACvB,OAAO,KAAKF,MAAL,EAAP;EACD;;AA72CQ;;AAg3CXG,MAAM,CAACC,OAAP,GAAiBpN,IAAjB"},"metadata":{},"sourceType":"script"}