{"ast":null,"code":"// when an optional dep fails to install, we need to remove the branch of the\n// graph up to the first optionalDependencies, as well as any nodes that are\n// only required by other nodes in the set.\n//\n// This function finds the set of nodes that will need to be removed in that\n// case.\n//\n// Note that this is *only* going to work with trees where calcDepFlags\n// has been called, because we rely on the node.optional flag.\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst optionalSet = node => {\n  if (!node.optional) {\n    return new Set();\n  } // start with the node, then walk up the dependency graph until we\n  // get to the boundaries that define the optional set.  since the\n  // node is optional, we know that all paths INTO this area of the\n  // graph are optional, but there may be non-optional dependencies\n  // WITHIN the area.\n\n\n  const set = new Set([node]);\n\n  for (const node of set) {\n    for (const edge of node.edgesIn) {\n      if (!edge.optional) {\n        set.add(edge.from);\n      }\n    }\n  } // now that we've hit the boundary, gather the rest of the nodes in\n  // the optional section.  that's the set of dependencies that are only\n  // depended upon by other nodes within the set, or optional dependencies\n  // from outside the set.\n\n\n  return gatherDepSet(set, edge => !edge.optional);\n};\n\nmodule.exports = optionalSet;","map":{"version":3,"names":["gatherDepSet","require","optionalSet","node","optional","Set","set","edge","edgesIn","add","from","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/optional-set.js"],"sourcesContent":["// when an optional dep fails to install, we need to remove the branch of the\n// graph up to the first optionalDependencies, as well as any nodes that are\n// only required by other nodes in the set.\n//\n// This function finds the set of nodes that will need to be removed in that\n// case.\n//\n// Note that this is *only* going to work with trees where calcDepFlags\n// has been called, because we rely on the node.optional flag.\n\nconst gatherDepSet = require('./gather-dep-set.js')\nconst optionalSet = node => {\n  if (!node.optional) {\n    return new Set()\n  }\n\n  // start with the node, then walk up the dependency graph until we\n  // get to the boundaries that define the optional set.  since the\n  // node is optional, we know that all paths INTO this area of the\n  // graph are optional, but there may be non-optional dependencies\n  // WITHIN the area.\n  const set = new Set([node])\n  for (const node of set) {\n    for (const edge of node.edgesIn) {\n      if (!edge.optional) {\n        set.add(edge.from)\n      }\n    }\n  }\n\n  // now that we've hit the boundary, gather the rest of the nodes in\n  // the optional section.  that's the set of dependencies that are only\n  // depended upon by other nodes within the set, or optional dependencies\n  // from outside the set.\n  return gatherDepSet(set, edge => !edge.optional)\n}\n\nmodule.exports = optionalSet\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,qBAAD,CAA5B;;AACA,MAAMC,WAAW,GAAGC,IAAI,IAAI;EAC1B,IAAI,CAACA,IAAI,CAACC,QAAV,EAAoB;IAClB,OAAO,IAAIC,GAAJ,EAAP;EACD,CAHyB,CAK1B;EACA;EACA;EACA;EACA;;;EACA,MAAMC,GAAG,GAAG,IAAID,GAAJ,CAAQ,CAACF,IAAD,CAAR,CAAZ;;EACA,KAAK,MAAMA,IAAX,IAAmBG,GAAnB,EAAwB;IACtB,KAAK,MAAMC,IAAX,IAAmBJ,IAAI,CAACK,OAAxB,EAAiC;MAC/B,IAAI,CAACD,IAAI,CAACH,QAAV,EAAoB;QAClBE,GAAG,CAACG,GAAJ,CAAQF,IAAI,CAACG,IAAb;MACD;IACF;EACF,CAjByB,CAmB1B;EACA;EACA;EACA;;;EACA,OAAOV,YAAY,CAACM,GAAD,EAAMC,IAAI,IAAI,CAACA,IAAI,CAACH,QAApB,CAAnB;AACD,CAxBD;;AA0BAO,MAAM,CAACC,OAAP,GAAiBV,WAAjB"},"metadata":{},"sourceType":"script"}