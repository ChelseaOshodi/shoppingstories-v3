{"ast":null,"code":"// file dependencies need their dependencies resolved based on the\n// location where the tarball was found, not the location where they\n// end up getting installed.  directory (ie, symlink) deps also need\n// to be resolved based on their targets, but that's what realpath is\nconst {\n  dirname\n} = require('path');\n\nconst npa = require('npm-package-arg');\n\nconst fromPath = (node, spec, edge) => {\n  if (edge && edge.overrides && edge.overrides.name === edge.name && edge.overrides.value) {\n    // fromPath could be called with a node that has a virtual root, if that happens\n    // we want to make sure we get the real root node when overrides are in use. this\n    // is to allow things like overriding a dependency with a tarball file that's a\n    // relative path from the project root\n    return node.sourceReference ? node.sourceReference.root.realpath : node.root.realpath;\n  }\n\n  return spec && spec.type === 'file' ? dirname(spec.fetchSpec) : node.realpath;\n};\n\nmodule.exports = (node, edge) => fromPath(node, node.resolved && npa(node.resolved), edge);","map":{"version":3,"names":["dirname","require","npa","fromPath","node","spec","edge","overrides","name","value","sourceReference","root","realpath","type","fetchSpec","module","exports","resolved"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/from-path.js"],"sourcesContent":["// file dependencies need their dependencies resolved based on the\n// location where the tarball was found, not the location where they\n// end up getting installed.  directory (ie, symlink) deps also need\n// to be resolved based on their targets, but that's what realpath is\n\nconst { dirname } = require('path')\nconst npa = require('npm-package-arg')\n\nconst fromPath = (node, spec, edge) => {\n  if (edge && edge.overrides && edge.overrides.name === edge.name && edge.overrides.value) {\n    // fromPath could be called with a node that has a virtual root, if that happens\n    // we want to make sure we get the real root node when overrides are in use. this\n    // is to allow things like overriding a dependency with a tarball file that's a\n    // relative path from the project root\n    return node.sourceReference\n      ? node.sourceReference.root.realpath\n      : node.root.realpath\n  }\n\n  return spec && spec.type === 'file' ? dirname(spec.fetchSpec)\n    : node.realpath\n}\n\nmodule.exports = (node, edge) => fromPath(node, node.resolved && npa(node.resolved), edge)\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAM;EAAEA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,iBAAD,CAAnB;;AAEA,MAAME,QAAQ,GAAG,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,KAAsB;EACrC,IAAIA,IAAI,IAAIA,IAAI,CAACC,SAAb,IAA0BD,IAAI,CAACC,SAAL,CAAeC,IAAf,KAAwBF,IAAI,CAACE,IAAvD,IAA+DF,IAAI,CAACC,SAAL,CAAeE,KAAlF,EAAyF;IACvF;IACA;IACA;IACA;IACA,OAAOL,IAAI,CAACM,eAAL,GACHN,IAAI,CAACM,eAAL,CAAqBC,IAArB,CAA0BC,QADvB,GAEHR,IAAI,CAACO,IAAL,CAAUC,QAFd;EAGD;;EAED,OAAOP,IAAI,IAAIA,IAAI,CAACQ,IAAL,KAAc,MAAtB,GAA+Bb,OAAO,CAACK,IAAI,CAACS,SAAN,CAAtC,GACHV,IAAI,CAACQ,QADT;AAED,CAbD;;AAeAG,MAAM,CAACC,OAAP,GAAiB,CAACZ,IAAD,EAAOE,IAAP,KAAgBH,QAAQ,CAACC,IAAD,EAAOA,IAAI,CAACa,QAAL,IAAiBf,GAAG,CAACE,IAAI,CAACa,QAAN,CAA3B,EAA4CX,IAA5C,CAAzC"},"metadata":{},"sourceType":"script"}