{"ast":null,"code":"const debug = require('./debug.js');\n\nconst checkTree = function (tree) {\n  let checkUnreachable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const log = [['START TREE CHECK', tree.path]]; // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n\n  if (!tree.root || !tree.root.inventory) {\n    return tree;\n  }\n\n  const {\n    inventory\n  } = tree.root;\n  const seen = new Set();\n\n  const check = function (node) {\n    let via = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tree;\n    let viaType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'self';\n    log.push(['CHECK', node && node.location, via && via.location, viaType, 'seen=' + seen.has(node), 'promise=' + !!(node && node.then), 'root=' + !!(node && node.isRoot)]);\n\n    if (!node || seen.has(node) || node.then) {\n      return;\n    }\n\n    seen.add(node);\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log\n      });\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node => [node.path, node.location]),\n        log\n      });\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev);\n\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log\n      });\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    const {\n      parent,\n      fsParent,\n      target\n    } = node;\n    check(parent, node, 'parent');\n    check(fsParent, node, 'fsParent');\n    check(target, node, 'target');\n    log.push(['CHILDREN', node.location, ...node.children.keys()]);\n\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children');\n    }\n\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren');\n    }\n\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn');\n    }\n\n    for (const top of node.tops) {\n      check(top, node, 'tops');\n    }\n\n    log.push(['DONE', node.location]);\n  };\n\n  check(tree);\n\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log\n        });\n      }\n    }\n  }\n\n  return tree;\n}; // should only ever run this check in debug mode\n\n\nmodule.exports = tree => tree;\n\ndebug(() => module.exports = checkTree);","map":{"version":3,"names":["debug","require","checkTree","tree","checkUnreachable","log","path","root","inventory","seen","Set","check","node","via","viaType","push","location","has","then","isRoot","add","Object","assign","Error","realpath","otherRoot","size","values","map","dummy","devEdges","edgesOut","filter","e","dev","isTop","length","type","name","spec","error","isLink","parent","fsParent","target","children","keys","kid","fsChildren","link","linksIn","top","tops","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/tree-check.js"],"sourcesContent":["const debug = require('./debug.js')\n\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]]\n\n  // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n  if (!tree.root || !tree.root.inventory) {\n    return tree\n  }\n\n  const { inventory } = tree.root\n  const seen = new Set()\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push([\n      'CHECK',\n      node && node.location,\n      via && via.location,\n      viaType,\n      'seen=' + seen.has(node),\n      'promise=' + !!(node && node.then),\n      'root=' + !!(node && node.isRoot),\n    ])\n\n    if (!node || seen.has(node) || node.then) {\n      return\n    }\n\n    seen.add(node)\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log,\n      })\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node =>\n          [node.path, node.location]),\n        log,\n      })\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev)\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log,\n      })\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const { parent, fsParent, target } = node\n    check(parent, node, 'parent')\n    check(fsParent, node, 'fsParent')\n    check(target, node, 'target')\n    log.push(['CHILDREN', node.location, ...node.children.keys()])\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children')\n    }\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren')\n    }\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn')\n    }\n    for (const top of node.tops) {\n      check(top, node, 'tops')\n    }\n    log.push(['DONE', node.location])\n  }\n  check(tree)\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log,\n        })\n      }\n    }\n  }\n  return tree\n}\n\n// should only ever run this check in debug mode\nmodule.exports = tree => tree\ndebug(() => module.exports = checkTree)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}