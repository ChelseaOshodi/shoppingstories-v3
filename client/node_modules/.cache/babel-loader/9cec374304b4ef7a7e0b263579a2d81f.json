{"ast":null,"code":"const EE = require('events');\n\nconst {\n  resolve\n} = require('path');\n\nconst fs = require('@npmcli/fs');\n\nconst log = require('./log-shim');\n\nconst _timeListener = Symbol('timeListener');\n\nconst _timeEndListener = Symbol('timeEndListener');\n\nconst _init = Symbol('init'); // This is an event emiiter but on/off\n// only listen on a single internal event that gets\n// emitted whenever a timer ends\n\n\nclass Timers extends EE {\n  file = null;\n  #unfinished = new Map();\n  #finished = {};\n  #onTimeEnd = Symbol('onTimeEnd');\n  #initialListener = null;\n  #initialTimer = null;\n\n  constructor() {\n    let {\n      listener = null,\n      start = 'npm'\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.#initialListener = listener;\n    this.#initialTimer = start;\n\n    this[_init]();\n  }\n\n  get unfinished() {\n    return this.#unfinished;\n  }\n\n  get finished() {\n    return this.#finished;\n  }\n\n  [_init]() {\n    this.on();\n\n    if (this.#initialListener) {\n      this.on(this.#initialListener);\n    }\n\n    process.emit('time', this.#initialTimer);\n    this.started = this.#unfinished.get(this.#initialTimer);\n  }\n\n  on(listener) {\n    if (listener) {\n      super.on(this.#onTimeEnd, listener);\n    } else {\n      process.on('time', this[_timeListener]);\n      process.on('timeEnd', this[_timeEndListener]);\n    }\n  }\n\n  off(listener) {\n    if (listener) {\n      super.off(this.#onTimeEnd, listener);\n    } else {\n      this.removeAllListeners(this.#onTimeEnd);\n      process.off('time', this[_timeListener]);\n      process.off('timeEnd', this[_timeEndListener]);\n    }\n  }\n\n  time(name, fn) {\n    process.emit('time', name);\n\n    const end = () => process.emit('timeEnd', name);\n\n    if (typeof fn === 'function') {\n      const res = fn();\n      return res && res.finally ? res.finally(end) : (end(), res);\n    }\n\n    return end;\n  }\n\n  load() {\n    let {\n      dir\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (dir) {\n      this.file = resolve(dir, '_timing.json');\n    }\n  }\n\n  writeFile(fileData) {\n    if (!this.file) {\n      return;\n    }\n\n    try {\n      const globalStart = this.started;\n      const globalEnd = this.#finished.npm || Date.now();\n      const content = { ...fileData,\n        ...this.#finished,\n        // add any unfinished timers with their relative start/end\n        unfinished: [...this.#unfinished.entries()].reduce((acc, _ref) => {\n          let [name, start] = _ref;\n          acc[name] = [start - globalStart, globalEnd - globalStart];\n          return acc;\n        }, {})\n      }; // we append line delimited json to this file...forever\n      // XXX: should we also write a process specific timing file?\n      // with similar rules to the debug log (max files, etc)\n\n      fs.withOwnerSync(this.file, () => fs.appendFileSync(this.file, JSON.stringify(content) + '\\n'), {\n        owner: 'inherit'\n      });\n    } catch (e) {\n      this.file = null;\n      log.warn('timing', `could not write timing file: ${e}`);\n    }\n  }\n\n  [_timeListener] = name => {\n    this.#unfinished.set(name, Date.now());\n  };\n  [_timeEndListener] = name => {\n    if (this.#unfinished.has(name)) {\n      const ms = Date.now() - this.#unfinished.get(name);\n      this.#finished[name] = ms;\n      this.#unfinished.delete(name);\n      this.emit(this.#onTimeEnd, name, ms);\n    } else {\n      log.silly('timing', \"Tried to end timer that doesn't exist:\", name);\n    }\n  };\n}\n\nmodule.exports = Timers;","map":{"version":3,"names":["EE","require","resolve","fs","log","_timeListener","Symbol","_timeEndListener","_init","Timers","file","unfinished","Map","finished","onTimeEnd","initialListener","initialTimer","constructor","listener","start","on","process","emit","started","get","off","removeAllListeners","time","name","fn","end","res","finally","load","dir","writeFile","fileData","globalStart","globalEnd","npm","Date","now","content","entries","reduce","acc","withOwnerSync","appendFileSync","JSON","stringify","owner","e","warn","set","has","ms","delete","silly","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/utils/timers.js"],"sourcesContent":["const EE = require('events')\nconst { resolve } = require('path')\nconst fs = require('@npmcli/fs')\nconst log = require('./log-shim')\n\nconst _timeListener = Symbol('timeListener')\nconst _timeEndListener = Symbol('timeEndListener')\nconst _init = Symbol('init')\n\n// This is an event emiiter but on/off\n// only listen on a single internal event that gets\n// emitted whenever a timer ends\nclass Timers extends EE {\n  file = null\n\n  #unfinished = new Map()\n  #finished = {}\n  #onTimeEnd = Symbol('onTimeEnd')\n  #initialListener = null\n  #initialTimer = null\n\n  constructor ({ listener = null, start = 'npm' } = {}) {\n    super()\n    this.#initialListener = listener\n    this.#initialTimer = start\n    this[_init]()\n  }\n\n  get unfinished () {\n    return this.#unfinished\n  }\n\n  get finished () {\n    return this.#finished\n  }\n\n  [_init] () {\n    this.on()\n    if (this.#initialListener) {\n      this.on(this.#initialListener)\n    }\n    process.emit('time', this.#initialTimer)\n    this.started = this.#unfinished.get(this.#initialTimer)\n  }\n\n  on (listener) {\n    if (listener) {\n      super.on(this.#onTimeEnd, listener)\n    } else {\n      process.on('time', this[_timeListener])\n      process.on('timeEnd', this[_timeEndListener])\n    }\n  }\n\n  off (listener) {\n    if (listener) {\n      super.off(this.#onTimeEnd, listener)\n    } else {\n      this.removeAllListeners(this.#onTimeEnd)\n      process.off('time', this[_timeListener])\n      process.off('timeEnd', this[_timeEndListener])\n    }\n  }\n\n  time (name, fn) {\n    process.emit('time', name)\n    const end = () => process.emit('timeEnd', name)\n    if (typeof fn === 'function') {\n      const res = fn()\n      return res && res.finally ? res.finally(end) : (end(), res)\n    }\n    return end\n  }\n\n  load ({ dir } = {}) {\n    if (dir) {\n      this.file = resolve(dir, '_timing.json')\n    }\n  }\n\n  writeFile (fileData) {\n    if (!this.file) {\n      return\n    }\n\n    try {\n      const globalStart = this.started\n      const globalEnd = this.#finished.npm || Date.now()\n      const content = {\n        ...fileData,\n        ...this.#finished,\n        // add any unfinished timers with their relative start/end\n        unfinished: [...this.#unfinished.entries()].reduce((acc, [name, start]) => {\n          acc[name] = [start - globalStart, globalEnd - globalStart]\n          return acc\n        }, {}),\n      }\n      // we append line delimited json to this file...forever\n      // XXX: should we also write a process specific timing file?\n      // with similar rules to the debug log (max files, etc)\n      fs.withOwnerSync(\n        this.file,\n        () => fs.appendFileSync(this.file, JSON.stringify(content) + '\\n'),\n        { owner: 'inherit' }\n      )\n    } catch (e) {\n      this.file = null\n      log.warn('timing', `could not write timing file: ${e}`)\n    }\n  }\n\n  [_timeListener] = (name) => {\n    this.#unfinished.set(name, Date.now())\n  }\n\n  [_timeEndListener] = (name) => {\n    if (this.#unfinished.has(name)) {\n      const ms = Date.now() - this.#unfinished.get(name)\n      this.#finished[name] = ms\n      this.#unfinished.delete(name)\n      this.emit(this.#onTimeEnd, name, ms)\n    } else {\n      log.silly('timing', \"Tried to end timer that doesn't exist:\", name)\n    }\n  }\n}\n\nmodule.exports = Timers\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}