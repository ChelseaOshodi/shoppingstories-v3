{"ast":null,"code":"/* eslint-disable camelcase */\nconst fs = require('fs');\n\nconst util = require('util');\n\nconst readdir = util.promisify(fs.readdir);\n\nconst reifyFinish = require('../utils/reify-finish.js');\n\nconst log = require('../utils/log-shim.js');\n\nconst {\n  resolve,\n  join\n} = require('path');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst runScript = require('@npmcli/run-script');\n\nconst pacote = require('pacote');\n\nconst checks = require('npm-install-checks');\n\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js');\n\nclass Install extends ArboristWorkspaceCmd {\n  static description = 'Install a package';\n  static name = 'install'; // These are in the order they will show up in when running \"-h\"\n\n  static params = ['save', 'save-exact', 'global', 'global-style', 'legacy-bundling', 'omit', 'strict-peer-deps', 'package-lock', 'foreground-scripts', 'ignore-scripts', 'audit', 'bin-links', 'fund', 'dry-run', ...super.params];\n  static usage = ['[<package-spec> ...]'];\n\n  async completion(opts) {\n    const {\n      partialWord\n    } = opts; // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return [];\n    }\n\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/');\n      const partialName = partialWord.slice(lastSlashIdx + 1);\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/';\n\n      const isDirMatch = async sibling => {\n        if (sibling.slice(0, partialName.length) !== partialName) {\n          return false;\n        }\n\n        try {\n          const contents = await readdir(join(partialPath, sibling));\n          const result = contents.indexOf('package.json') !== -1;\n          return result;\n        } catch (er) {\n          return false;\n        }\n      };\n\n      try {\n        const siblings = await readdir(partialPath);\n        const matches = [];\n\n        for (const sibling of siblings) {\n          if (await isDirMatch(sibling)) {\n            matches.push(sibling);\n          }\n        }\n\n        if (matches.length === 1) {\n          return [join(partialPath, matches[0])];\n        } // no matches\n\n\n        return [];\n      } catch (er) {\n        return []; // invalid dir: no matching\n      }\n    } // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n\n  }\n\n  async exec(args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..');\n    const ignoreScripts = this.npm.config.get('ignore-scripts');\n    const isGlobalInstall = this.npm.global;\n    const where = isGlobalInstall ? globalTop : this.npm.prefix;\n    const forced = this.npm.config.get('force');\n    const scriptShell = this.npm.config.get('script-shell') || undefined; // be very strict about engines when trying to update npm itself\n\n    const npmInstall = args.find(arg => arg.startsWith('npm@') || arg === 'npm');\n\n    if (isGlobalInstall && npmInstall) {\n      const npmOptions = this.npm.flatOptions;\n      const npmManifest = await pacote.manifest(npmInstall, npmOptions);\n\n      try {\n        checks.checkEngine(npmManifest, npmManifest.version, process.version);\n      } catch (e) {\n        if (forced) {\n          log.warn('install',\n          /* eslint-disable-next-line max-len */\n          `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`);\n        } else {\n          throw e;\n        }\n      }\n    } // don't try to install the prefix into itself\n\n\n    args = args.filter(a => resolve(a) !== this.npm.prefix); // `npm i -g` => \"install this package globally\"\n\n    if (where === globalTop && !args.length) {\n      args = ['.'];\n    } // throw usage error if trying to install empty package\n    // name to global space, e.g: `npm i -g \"\"`\n\n\n    if (where === globalTop && !args.every(Boolean)) {\n      throw this.usageError();\n    }\n\n    const opts = { ...this.npm.flatOptions,\n      auditLevel: null,\n      path: where,\n      add: args,\n      workspaces: this.workspaceNames\n    };\n    const arb = new Arborist(opts);\n    await arb.reify(opts);\n\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scripts = ['preinstall', 'install', 'postinstall', 'prepublish', // XXX(npm9) should we remove this finally??\n      'preprepare', 'prepare', 'postprepare'];\n\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: !this.npm.silent,\n          event\n        });\n      }\n    }\n\n    await reifyFinish(this.npm, arb);\n  }\n\n}\n\nmodule.exports = Install;","map":{"version":3,"names":["fs","require","util","readdir","promisify","reifyFinish","log","resolve","join","Arborist","runScript","pacote","checks","ArboristWorkspaceCmd","Install","description","name","params","usage","completion","opts","partialWord","test","lastSlashIdx","lastIndexOf","partialName","slice","partialPath","isDirMatch","sibling","length","contents","result","indexOf","er","siblings","matches","push","exec","args","globalTop","npm","globalDir","ignoreScripts","config","get","isGlobalInstall","global","where","prefix","forced","scriptShell","undefined","npmInstall","find","arg","startsWith","npmOptions","flatOptions","npmManifest","manifest","checkEngine","version","process","e","warn","filter","a","every","Boolean","usageError","auditLevel","path","add","workspaces","workspaceNames","arb","reify","scripts","event","stdio","stdioString","banner","silent","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/install.js"],"sourcesContent":["/* eslint-disable camelcase */\nconst fs = require('fs')\nconst util = require('util')\nconst readdir = util.promisify(fs.readdir)\nconst reifyFinish = require('../utils/reify-finish.js')\nconst log = require('../utils/log-shim.js')\nconst { resolve, join } = require('path')\nconst Arborist = require('@npmcli/arborist')\nconst runScript = require('@npmcli/run-script')\nconst pacote = require('pacote')\nconst checks = require('npm-install-checks')\n\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js')\nclass Install extends ArboristWorkspaceCmd {\n  static description = 'Install a package'\n  static name = 'install'\n\n  // These are in the order they will show up in when running \"-h\"\n  static params = [\n    'save',\n    'save-exact',\n    'global',\n    'global-style',\n    'legacy-bundling',\n    'omit',\n    'strict-peer-deps',\n    'package-lock',\n    'foreground-scripts',\n    'ignore-scripts',\n    'audit',\n    'bin-links',\n    'fund',\n    'dry-run',\n    ...super.params,\n  ]\n\n  static usage = ['[<package-spec> ...]']\n\n  async completion (opts) {\n    const { partialWord } = opts\n    // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return []\n    }\n\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/')\n      const partialName = partialWord.slice(lastSlashIdx + 1)\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/'\n\n      const isDirMatch = async sibling => {\n        if (sibling.slice(0, partialName.length) !== partialName) {\n          return false\n        }\n\n        try {\n          const contents = await readdir(join(partialPath, sibling))\n          const result = (contents.indexOf('package.json') !== -1)\n          return result\n        } catch (er) {\n          return false\n        }\n      }\n\n      try {\n        const siblings = await readdir(partialPath)\n        const matches = []\n        for (const sibling of siblings) {\n          if (await isDirMatch(sibling)) {\n            matches.push(sibling)\n          }\n        }\n        if (matches.length === 1) {\n          return [join(partialPath, matches[0])]\n        }\n        // no matches\n        return []\n      } catch (er) {\n        return [] // invalid dir: no matching\n      }\n    }\n    // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n  }\n\n  async exec (args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..')\n    const ignoreScripts = this.npm.config.get('ignore-scripts')\n    const isGlobalInstall = this.npm.global\n    const where = isGlobalInstall ? globalTop : this.npm.prefix\n    const forced = this.npm.config.get('force')\n    const scriptShell = this.npm.config.get('script-shell') || undefined\n\n    // be very strict about engines when trying to update npm itself\n    const npmInstall = args.find(arg => arg.startsWith('npm@') || arg === 'npm')\n    if (isGlobalInstall && npmInstall) {\n      const npmOptions = this.npm.flatOptions\n      const npmManifest = await pacote.manifest(npmInstall, npmOptions)\n      try {\n        checks.checkEngine(npmManifest, npmManifest.version, process.version)\n      } catch (e) {\n        if (forced) {\n          log.warn(\n            'install',\n            /* eslint-disable-next-line max-len */\n            `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`\n          )\n        } else {\n          throw e\n        }\n      }\n    }\n\n    // don't try to install the prefix into itself\n    args = args.filter(a => resolve(a) !== this.npm.prefix)\n\n    // `npm i -g` => \"install this package globally\"\n    if (where === globalTop && !args.length) {\n      args = ['.']\n    }\n\n    // throw usage error if trying to install empty package\n    // name to global space, e.g: `npm i -g \"\"`\n    if (where === globalTop && !args.every(Boolean)) {\n      throw this.usageError()\n    }\n\n    const opts = {\n      ...this.npm.flatOptions,\n      auditLevel: null,\n      path: where,\n      add: args,\n      workspaces: this.workspaceNames,\n    }\n    const arb = new Arborist(opts)\n    await arb.reify(opts)\n\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scripts = [\n        'preinstall',\n        'install',\n        'postinstall',\n        'prepublish', // XXX(npm9) should we remove this finally??\n        'preprepare',\n        'prepare',\n        'postprepare',\n      ]\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: !this.npm.silent,\n          event,\n        })\n      }\n    }\n    await reifyFinish(this.npm, arb)\n  }\n}\nmodule.exports = Install\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}