{"ast":null,"code":"const Arborist = require('@npmcli/arborist');\n\nconst auditReport = require('npm-audit-report');\n\nconst fetch = require('npm-registry-fetch');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst pMap = require('p-map');\n\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js');\n\nconst auditError = require('../utils/audit-error.js');\n\nconst log = require('../utils/log-shim.js');\n\nconst reifyFinish = require('../utils/reify-finish.js');\n\nconst sortAlphabetically = (a, b) => localeCompare(a.name, b.name);\n\nclass VerifySignatures {\n  constructor(tree, filterSet, npm, opts) {\n    this.tree = tree;\n    this.filterSet = filterSet;\n    this.npm = npm;\n    this.opts = opts;\n    this.keys = new Map();\n    this.invalid = [];\n    this.missing = [];\n    this.checkedPackages = new Set();\n    this.auditedWithKeysCount = 0;\n    this.verifiedCount = 0;\n    this.output = [];\n    this.exitCode = 0;\n  }\n\n  async run() {\n    const start = process.hrtime.bigint(); // Find all deps in tree\n\n    const {\n      edges,\n      registries\n    } = this.getEdgesOut(this.tree.inventory.values(), this.filterSet);\n\n    if (edges.size === 0) {\n      throw new Error('found no installed dependencies to audit');\n    }\n\n    await Promise.all([...registries].map(registry => this.setKeys({\n      registry\n    })));\n    const progress = log.newItem('verifying registry signatures', edges.size);\n\n    const mapper = async edge => {\n      progress.completeWork(1);\n      await this.getVerifiedInfo(edge);\n    };\n\n    await pMap(edges, mapper, {\n      concurrency: 20,\n      stopOnError: true\n    }); // Didn't find any dependencies that could be verified, e.g. only local\n    // deps, missing version, not on a registry etc.\n\n    if (!this.auditedWithKeysCount) {\n      throw new Error('found no dependencies to audit that where installed from ' + 'a supported registry');\n    }\n\n    const invalid = this.invalid.sort(sortAlphabetically);\n    const missing = this.missing.sort(sortAlphabetically);\n    const hasNoInvalidOrMissing = invalid.length === 0 && missing.length === 0;\n\n    if (!hasNoInvalidOrMissing) {\n      this.exitCode = 1;\n    }\n\n    if (this.npm.config.get('json')) {\n      this.appendOutput(JSON.stringify({\n        invalid: this.makeJSON(invalid),\n        missing: this.makeJSON(missing)\n      }, null, 2));\n      return;\n    }\n\n    const end = process.hrtime.bigint();\n    const elapsed = end - start;\n    const auditedPlural = this.auditedWithKeysCount > 1 ? 's' : '';\n    const timing = `audited ${this.auditedWithKeysCount} package${auditedPlural} in ` + `${Math.floor(Number(elapsed) / 1e9)}s`;\n    this.appendOutput(`${timing}\\n`);\n\n    if (this.verifiedCount) {\n      const verifiedBold = this.npm.chalk.bold('verified');\n      const msg = this.verifiedCount === 1 ? `${this.verifiedCount} package has a ${verifiedBold} registry signature\\n` : `${this.verifiedCount} packages have ${verifiedBold} registry signatures\\n`;\n      this.appendOutput(msg);\n    }\n\n    if (missing.length) {\n      const missingClr = this.npm.chalk.bold(this.npm.chalk.red('missing'));\n      const msg = missing.length === 1 ? `package has a ${missingClr} registry signature` : `packages have ${missingClr} registry signatures`;\n      this.appendOutput(`${missing.length} ${msg} but the registry is ` + `providing signing keys:\\n`);\n      this.appendOutput(this.humanOutput(missing));\n    }\n\n    if (invalid.length) {\n      const invalidClr = this.npm.chalk.bold(this.npm.chalk.red('invalid'));\n      const msg = invalid.length === 1 ? `${invalid.length} package has an ${invalidClr} registry signature:\\n` : `${invalid.length} packages have ${invalidClr} registry signatures:\\n`;\n      this.appendOutput(`${missing.length ? '\\n' : ''}${msg}`);\n      this.appendOutput(this.humanOutput(invalid));\n      const tamperMsg = invalid.length === 1 ? `\\nSomeone might have tampered with this package since it was ` + `published on the registry!\\n` : `\\nSomeone might have tampered with these packages since they where ` + `published on the registry!\\n`;\n      this.appendOutput(tamperMsg);\n    }\n  }\n\n  appendOutput() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.output.push(...args.flat());\n  }\n\n  report() {\n    return {\n      report: this.output.join('\\n'),\n      exitCode: this.exitCode\n    };\n  }\n\n  getEdgesOut(nodes, filterSet) {\n    const edges = new Set();\n    const registries = new Set();\n\n    for (const node of nodes) {\n      for (const edge of node.edgesOut.values()) {\n        const filteredOut = edge.from && filterSet && filterSet.size > 0 && !filterSet.has(edge.from.target);\n\n        if (!filteredOut) {\n          const spec = this.getEdgeSpec(edge);\n\n          if (spec) {\n            // Prefetch and cache public keys from used registries\n            registries.add(this.getSpecRegistry(spec));\n          }\n\n          edges.add(edge);\n        }\n      }\n    }\n\n    return {\n      edges,\n      registries\n    };\n  }\n\n  async setKeys(_ref) {\n    let {\n      registry\n    } = _ref;\n    const keys = await fetch.json('/-/npm/v1/keys', { ...this.npm.flatOptions,\n      registry\n    }).then(_ref2 => {\n      let {\n        keys\n      } = _ref2;\n      return keys.map(key => ({ ...key,\n        pemkey: `-----BEGIN PUBLIC KEY-----\\n${key.key}\\n-----END PUBLIC KEY-----`\n      }));\n    }).catch(err => {\n      if (err.code === 'E404') {\n        return null;\n      } else {\n        throw err;\n      }\n    });\n\n    if (keys) {\n      this.keys.set(registry, keys);\n    }\n  }\n\n  getEdgeType(edge) {\n    return edge.optional ? 'optionalDependencies' : edge.peer ? 'peerDependencies' : edge.dev ? 'devDependencies' : 'dependencies';\n  }\n\n  getEdgeSpec(edge) {\n    let name = edge.name;\n\n    try {\n      name = npa(edge.spec).subSpec.name;\n    } catch (_) {}\n\n    try {\n      return npa(`${name}@${edge.spec}`);\n    } catch (_) {// Skip packages with invalid spec\n    }\n  }\n\n  buildRegistryConfig(registry) {\n    const keys = this.keys.get(registry) || [];\n    const parsedRegistry = new URL(registry);\n    const regKey = `//${parsedRegistry.host}${parsedRegistry.pathname}`;\n    return {\n      [`${regKey}:_keys`]: keys\n    };\n  }\n\n  getSpecRegistry(spec) {\n    return fetch.pickRegistry(spec, this.npm.flatOptions);\n  }\n\n  getValidPackageInfo(edge) {\n    const type = this.getEdgeType(edge); // Skip potentially optional packages that are not on disk, as these could\n    // be omitted during install\n\n    if (edge.error === 'MISSING' && type !== 'dependencies') {\n      return;\n    }\n\n    const spec = this.getEdgeSpec(edge); // Skip invalid version requirements\n\n    if (!spec) {\n      return;\n    }\n\n    const node = edge.to || edge;\n    const {\n      version\n    } = node.package || {};\n\n    if (node.isWorkspace || // Skip local workspaces packages\n    !version || // Skip packages that don't have a installed version, e.g. optonal dependencies\n    !spec.registry) {\n      // Skip if not from registry, e.g. git package\n      return;\n    }\n\n    for (const omitType of this.npm.config.get('omit')) {\n      if (node[omitType]) {\n        return;\n      }\n    }\n\n    return {\n      name: spec.name,\n      version,\n      type,\n      location: node.location,\n      registry: this.getSpecRegistry(spec)\n    };\n  }\n\n  async verifySignatures(name, version, registry) {\n    const {\n      _integrity: integrity,\n      _signatures,\n      _resolved: resolved\n    } = await pacote.manifest(`${name}@${version}`, {\n      verifySignatures: true,\n      ...this.buildRegistryConfig(registry),\n      ...this.npm.flatOptions\n    });\n    const signatures = _signatures || [];\n    return {\n      integrity,\n      signatures,\n      resolved\n    };\n  }\n\n  async getVerifiedInfo(edge) {\n    const info = this.getValidPackageInfo(edge);\n\n    if (!info) {\n      return;\n    }\n\n    const {\n      name,\n      version,\n      location,\n      registry,\n      type\n    } = info;\n\n    if (this.checkedPackages.has(location)) {\n      // we already did or are doing this one\n      return;\n    }\n\n    this.checkedPackages.add(location); // We only \"audit\" or verify the signature, or the presence of it, on\n    // packages whose registry returns signing keys\n\n    const keys = this.keys.get(registry) || [];\n\n    if (keys.length) {\n      this.auditedWithKeysCount += 1;\n    }\n\n    try {\n      const {\n        integrity,\n        signatures,\n        resolved\n      } = await this.verifySignatures(name, version, registry); // Currently we only care about missing signatures on registries that provide a public key\n      // We could make this configurable in the future with a strict/paranoid mode\n\n      if (signatures.length) {\n        this.verifiedCount += 1;\n      } else if (keys.length) {\n        this.missing.push({\n          name,\n          version,\n          location,\n          resolved,\n          integrity,\n          registry\n        });\n      }\n    } catch (e) {\n      if (e.code === 'EINTEGRITYSIGNATURE') {\n        const {\n          signature,\n          keyid,\n          integrity,\n          resolved\n        } = e;\n        this.invalid.push({\n          name,\n          type,\n          version,\n          resolved,\n          location,\n          integrity,\n          registry,\n          signature,\n          keyid\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  humanOutput(list) {\n    return list.map(v => `${this.npm.chalk.red(`${v.name}@${v.version}`)} (${v.registry})`).join('\\n');\n  }\n\n  makeJSON(deps) {\n    return deps.map(d => ({\n      name: d.name,\n      version: d.version,\n      location: d.location,\n      resolved: d.resolved,\n      integrity: d.integrity,\n      signature: d.signature,\n      keyid: d.keyid\n    }));\n  }\n\n}\n\nclass Audit extends ArboristWorkspaceCmd {\n  static description = 'Run a security audit';\n  static name = 'audit';\n  static params = ['audit-level', 'dry-run', 'force', 'json', 'package-lock-only', 'omit', 'foreground-scripts', 'ignore-scripts', ...super.params];\n  static usage = ['[fix|signatures]'];\n\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n\n    if (argv.length === 2) {\n      return ['fix'];\n    }\n\n    switch (argv[2]) {\n      case 'fix':\n        return [];\n\n      default:\n        throw Object.assign(new Error(argv[2] + ' not recognized'), {\n          code: 'EUSAGE'\n        });\n    }\n  }\n\n  async exec(args) {\n    if (args[0] === 'signatures') {\n      await this.auditSignatures();\n    } else {\n      await this.auditAdvisories(args);\n    }\n  }\n\n  async auditAdvisories(args) {\n    const reporter = this.npm.config.get('json') ? 'json' : 'detail';\n    const opts = { ...this.npm.flatOptions,\n      audit: true,\n      path: this.npm.prefix,\n      reporter,\n      workspaces: this.workspaceNames\n    };\n    const arb = new Arborist(opts);\n    const fix = args[0] === 'fix';\n    await arb.audit({\n      fix\n    });\n\n    if (fix) {\n      await reifyFinish(this.npm, arb);\n    } else {\n      // will throw if there's an error, because this is an audit command\n      auditError(this.npm, arb.auditReport);\n      const result = auditReport(arb.auditReport, opts);\n      process.exitCode = process.exitCode || result.exitCode;\n      this.npm.output(result.report);\n    }\n  }\n\n  async auditSignatures() {\n    if (this.npm.global) {\n      throw Object.assign(new Error('`npm audit signatures` does not support global packages'), {\n        code: 'EAUDITGLOBAL'\n      });\n    }\n\n    log.verbose('loading installed dependencies');\n    const opts = { ...this.npm.flatOptions,\n      path: this.npm.prefix,\n      workspaces: this.workspaceNames\n    };\n    const arb = new Arborist(opts);\n    const tree = await arb.loadActual();\n    let filterSet = new Set();\n\n    if (opts.workspaces && opts.workspaces.length) {\n      filterSet = arb.workspaceDependencySet(tree, opts.workspaces, this.npm.flatOptions.includeWorkspaceRoot);\n    } else if (!this.npm.flatOptions.workspacesEnabled) {\n      filterSet = arb.excludeWorkspacesDependencySet(tree);\n    }\n\n    const verify = new VerifySignatures(tree, filterSet, this.npm, { ...opts\n    });\n    await verify.run();\n    const result = verify.report();\n    process.exitCode = process.exitCode || result.exitCode;\n    this.npm.output(result.report);\n  }\n\n}\n\nmodule.exports = Audit;","map":{"version":3,"names":["Arborist","require","auditReport","fetch","localeCompare","npa","pacote","pMap","ArboristWorkspaceCmd","auditError","log","reifyFinish","sortAlphabetically","a","b","name","VerifySignatures","constructor","tree","filterSet","npm","opts","keys","Map","invalid","missing","checkedPackages","Set","auditedWithKeysCount","verifiedCount","output","exitCode","run","start","process","hrtime","bigint","edges","registries","getEdgesOut","inventory","values","size","Error","Promise","all","map","registry","setKeys","progress","newItem","mapper","edge","completeWork","getVerifiedInfo","concurrency","stopOnError","sort","hasNoInvalidOrMissing","length","config","get","appendOutput","JSON","stringify","makeJSON","end","elapsed","auditedPlural","timing","Math","floor","Number","verifiedBold","chalk","bold","msg","missingClr","red","humanOutput","invalidClr","tamperMsg","args","push","flat","report","join","nodes","node","edgesOut","filteredOut","from","has","target","spec","getEdgeSpec","add","getSpecRegistry","json","flatOptions","then","key","pemkey","catch","err","code","set","getEdgeType","optional","peer","dev","subSpec","_","buildRegistryConfig","parsedRegistry","URL","regKey","host","pathname","pickRegistry","getValidPackageInfo","type","error","to","version","package","isWorkspace","omitType","location","verifySignatures","_integrity","integrity","_signatures","_resolved","resolved","manifest","signatures","info","e","signature","keyid","list","v","deps","d","Audit","description","params","usage","completion","argv","conf","remain","Object","assign","exec","auditSignatures","auditAdvisories","reporter","audit","path","prefix","workspaces","workspaceNames","arb","fix","result","global","verbose","loadActual","workspaceDependencySet","includeWorkspaceRoot","workspacesEnabled","excludeWorkspacesDependencySet","verify","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/audit.js"],"sourcesContent":["const Arborist = require('@npmcli/arborist')\nconst auditReport = require('npm-audit-report')\nconst fetch = require('npm-registry-fetch')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst pMap = require('p-map')\n\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js')\nconst auditError = require('../utils/audit-error.js')\nconst log = require('../utils/log-shim.js')\nconst reifyFinish = require('../utils/reify-finish.js')\n\nconst sortAlphabetically = (a, b) => localeCompare(a.name, b.name)\n\nclass VerifySignatures {\n  constructor (tree, filterSet, npm, opts) {\n    this.tree = tree\n    this.filterSet = filterSet\n    this.npm = npm\n    this.opts = opts\n    this.keys = new Map()\n    this.invalid = []\n    this.missing = []\n    this.checkedPackages = new Set()\n    this.auditedWithKeysCount = 0\n    this.verifiedCount = 0\n    this.output = []\n    this.exitCode = 0\n  }\n\n  async run () {\n    const start = process.hrtime.bigint()\n\n    // Find all deps in tree\n    const { edges, registries } = this.getEdgesOut(this.tree.inventory.values(), this.filterSet)\n    if (edges.size === 0) {\n      throw new Error('found no installed dependencies to audit')\n    }\n\n    await Promise.all([...registries].map(registry => this.setKeys({ registry })))\n\n    const progress = log.newItem('verifying registry signatures', edges.size)\n    const mapper = async (edge) => {\n      progress.completeWork(1)\n      await this.getVerifiedInfo(edge)\n    }\n    await pMap(edges, mapper, { concurrency: 20, stopOnError: true })\n\n    // Didn't find any dependencies that could be verified, e.g. only local\n    // deps, missing version, not on a registry etc.\n    if (!this.auditedWithKeysCount) {\n      throw new Error('found no dependencies to audit that where installed from ' +\n                      'a supported registry')\n    }\n\n    const invalid = this.invalid.sort(sortAlphabetically)\n    const missing = this.missing.sort(sortAlphabetically)\n\n    const hasNoInvalidOrMissing = invalid.length === 0 && missing.length === 0\n\n    if (!hasNoInvalidOrMissing) {\n      this.exitCode = 1\n    }\n\n    if (this.npm.config.get('json')) {\n      this.appendOutput(JSON.stringify({\n        invalid: this.makeJSON(invalid),\n        missing: this.makeJSON(missing),\n      }, null, 2))\n      return\n    }\n    const end = process.hrtime.bigint()\n    const elapsed = end - start\n\n    const auditedPlural = this.auditedWithKeysCount > 1 ? 's' : ''\n    const timing = `audited ${this.auditedWithKeysCount} package${auditedPlural} in ` +\n      `${Math.floor(Number(elapsed) / 1e9)}s`\n    this.appendOutput(`${timing}\\n`)\n\n    if (this.verifiedCount) {\n      const verifiedBold = this.npm.chalk.bold('verified')\n      const msg = this.verifiedCount === 1 ?\n        `${this.verifiedCount} package has a ${verifiedBold} registry signature\\n` :\n        `${this.verifiedCount} packages have ${verifiedBold} registry signatures\\n`\n      this.appendOutput(msg)\n    }\n\n    if (missing.length) {\n      const missingClr = this.npm.chalk.bold(this.npm.chalk.red('missing'))\n      const msg = missing.length === 1 ?\n        `package has a ${missingClr} registry signature` :\n        `packages have ${missingClr} registry signatures`\n      this.appendOutput(\n        `${missing.length} ${msg} but the registry is ` +\n        `providing signing keys:\\n`\n      )\n      this.appendOutput(this.humanOutput(missing))\n    }\n\n    if (invalid.length) {\n      const invalidClr = this.npm.chalk.bold(this.npm.chalk.red('invalid'))\n      const msg = invalid.length === 1 ?\n        `${invalid.length} package has an ${invalidClr} registry signature:\\n` :\n        `${invalid.length} packages have ${invalidClr} registry signatures:\\n`\n      this.appendOutput(\n        `${missing.length ? '\\n' : ''}${msg}`\n      )\n      this.appendOutput(this.humanOutput(invalid))\n      const tamperMsg = invalid.length === 1 ?\n        `\\nSomeone might have tampered with this package since it was ` +\n        `published on the registry!\\n` :\n        `\\nSomeone might have tampered with these packages since they where ` +\n        `published on the registry!\\n`\n      this.appendOutput(tamperMsg)\n    }\n  }\n\n  appendOutput (...args) {\n    this.output.push(...args.flat())\n  }\n\n  report () {\n    return { report: this.output.join('\\n'), exitCode: this.exitCode }\n  }\n\n  getEdgesOut (nodes, filterSet) {\n    const edges = new Set()\n    const registries = new Set()\n    for (const node of nodes) {\n      for (const edge of node.edgesOut.values()) {\n        const filteredOut =\n          edge.from\n            && filterSet\n            && filterSet.size > 0\n            && !filterSet.has(edge.from.target)\n\n        if (!filteredOut) {\n          const spec = this.getEdgeSpec(edge)\n          if (spec) {\n            // Prefetch and cache public keys from used registries\n            registries.add(this.getSpecRegistry(spec))\n          }\n          edges.add(edge)\n        }\n      }\n    }\n    return { edges, registries }\n  }\n\n  async setKeys ({ registry }) {\n    const keys = await fetch.json('/-/npm/v1/keys', {\n      ...this.npm.flatOptions,\n      registry,\n    }).then(({ keys }) => keys.map((key) => ({\n      ...key,\n      pemkey: `-----BEGIN PUBLIC KEY-----\\n${key.key}\\n-----END PUBLIC KEY-----`,\n    }))).catch(err => {\n      if (err.code === 'E404') {\n        return null\n      } else {\n        throw err\n      }\n    })\n    if (keys) {\n      this.keys.set(registry, keys)\n    }\n  }\n\n  getEdgeType (edge) {\n    return edge.optional ? 'optionalDependencies'\n      : edge.peer ? 'peerDependencies'\n      : edge.dev ? 'devDependencies'\n      : 'dependencies'\n  }\n\n  getEdgeSpec (edge) {\n    let name = edge.name\n    try {\n      name = npa(edge.spec).subSpec.name\n    } catch (_) {\n    }\n    try {\n      return npa(`${name}@${edge.spec}`)\n    } catch (_) {\n      // Skip packages with invalid spec\n    }\n  }\n\n  buildRegistryConfig (registry) {\n    const keys = this.keys.get(registry) || []\n    const parsedRegistry = new URL(registry)\n    const regKey = `//${parsedRegistry.host}${parsedRegistry.pathname}`\n    return {\n      [`${regKey}:_keys`]: keys,\n    }\n  }\n\n  getSpecRegistry (spec) {\n    return fetch.pickRegistry(spec, this.npm.flatOptions)\n  }\n\n  getValidPackageInfo (edge) {\n    const type = this.getEdgeType(edge)\n    // Skip potentially optional packages that are not on disk, as these could\n    // be omitted during install\n    if (edge.error === 'MISSING' && type !== 'dependencies') {\n      return\n    }\n\n    const spec = this.getEdgeSpec(edge)\n    // Skip invalid version requirements\n    if (!spec) {\n      return\n    }\n    const node = edge.to || edge\n    const { version } = node.package || {}\n\n    if (node.isWorkspace || // Skip local workspaces packages\n        !version || // Skip packages that don't have a installed version, e.g. optonal dependencies\n        !spec.registry) { // Skip if not from registry, e.g. git package\n      return\n    }\n\n    for (const omitType of this.npm.config.get('omit')) {\n      if (node[omitType]) {\n        return\n      }\n    }\n\n    return {\n      name: spec.name,\n      version,\n      type,\n      location: node.location,\n      registry: this.getSpecRegistry(spec),\n    }\n  }\n\n  async verifySignatures (name, version, registry) {\n    const {\n      _integrity: integrity,\n      _signatures,\n      _resolved: resolved,\n    } = await pacote.manifest(`${name}@${version}`, {\n      verifySignatures: true,\n      ...this.buildRegistryConfig(registry),\n      ...this.npm.flatOptions,\n    })\n    const signatures = _signatures || []\n    return {\n      integrity,\n      signatures,\n      resolved,\n    }\n  }\n\n  async getVerifiedInfo (edge) {\n    const info = this.getValidPackageInfo(edge)\n    if (!info) {\n      return\n    }\n    const { name, version, location, registry, type } = info\n    if (this.checkedPackages.has(location)) {\n      // we already did or are doing this one\n      return\n    }\n    this.checkedPackages.add(location)\n\n    // We only \"audit\" or verify the signature, or the presence of it, on\n    // packages whose registry returns signing keys\n    const keys = this.keys.get(registry) || []\n    if (keys.length) {\n      this.auditedWithKeysCount += 1\n    }\n\n    try {\n      const { integrity, signatures, resolved } = await this.verifySignatures(\n        name, version, registry\n      )\n\n      // Currently we only care about missing signatures on registries that provide a public key\n      // We could make this configurable in the future with a strict/paranoid mode\n      if (signatures.length) {\n        this.verifiedCount += 1\n      } else if (keys.length) {\n        this.missing.push({\n          name,\n          version,\n          location,\n          resolved,\n          integrity,\n          registry,\n        })\n      }\n    } catch (e) {\n      if (e.code === 'EINTEGRITYSIGNATURE') {\n        const { signature, keyid, integrity, resolved } = e\n        this.invalid.push({\n          name,\n          type,\n          version,\n          resolved,\n          location,\n          integrity,\n          registry,\n          signature,\n          keyid,\n        })\n      } else {\n        throw e\n      }\n    }\n  }\n\n  humanOutput (list) {\n    return list.map(v =>\n      `${this.npm.chalk.red(`${v.name}@${v.version}`)} (${v.registry})`\n    ).join('\\n')\n  }\n\n  makeJSON (deps) {\n    return deps.map(d => ({\n      name: d.name,\n      version: d.version,\n      location: d.location,\n      resolved: d.resolved,\n      integrity: d.integrity,\n      signature: d.signature,\n      keyid: d.keyid,\n    }))\n  }\n}\n\nclass Audit extends ArboristWorkspaceCmd {\n  static description = 'Run a security audit'\n  static name = 'audit'\n  static params = [\n    'audit-level',\n    'dry-run',\n    'force',\n    'json',\n    'package-lock-only',\n    'omit',\n    'foreground-scripts',\n    'ignore-scripts',\n    ...super.params,\n  ]\n\n  static usage = ['[fix|signatures]']\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n\n    if (argv.length === 2) {\n      return ['fix']\n    }\n\n    switch (argv[2]) {\n      case 'fix':\n        return []\n      default:\n        throw Object.assign(new Error(argv[2] + ' not recognized'), {\n          code: 'EUSAGE',\n        })\n    }\n  }\n\n  async exec (args) {\n    if (args[0] === 'signatures') {\n      await this.auditSignatures()\n    } else {\n      await this.auditAdvisories(args)\n    }\n  }\n\n  async auditAdvisories (args) {\n    const reporter = this.npm.config.get('json') ? 'json' : 'detail'\n    const opts = {\n      ...this.npm.flatOptions,\n      audit: true,\n      path: this.npm.prefix,\n      reporter,\n      workspaces: this.workspaceNames,\n    }\n\n    const arb = new Arborist(opts)\n    const fix = args[0] === 'fix'\n    await arb.audit({ fix })\n    if (fix) {\n      await reifyFinish(this.npm, arb)\n    } else {\n      // will throw if there's an error, because this is an audit command\n      auditError(this.npm, arb.auditReport)\n      const result = auditReport(arb.auditReport, opts)\n      process.exitCode = process.exitCode || result.exitCode\n      this.npm.output(result.report)\n    }\n  }\n\n  async auditSignatures () {\n    if (this.npm.global) {\n      throw Object.assign(\n        new Error('`npm audit signatures` does not support global packages'), {\n          code: 'EAUDITGLOBAL',\n        }\n      )\n    }\n\n    log.verbose('loading installed dependencies')\n    const opts = {\n      ...this.npm.flatOptions,\n      path: this.npm.prefix,\n      workspaces: this.workspaceNames,\n    }\n\n    const arb = new Arborist(opts)\n    const tree = await arb.loadActual()\n    let filterSet = new Set()\n    if (opts.workspaces && opts.workspaces.length) {\n      filterSet =\n        arb.workspaceDependencySet(\n          tree,\n          opts.workspaces,\n          this.npm.flatOptions.includeWorkspaceRoot\n        )\n    } else if (!this.npm.flatOptions.workspacesEnabled) {\n      filterSet =\n        arb.excludeWorkspacesDependencySet(tree)\n    }\n\n    const verify = new VerifySignatures(tree, filterSet, this.npm, { ...opts })\n    await verify.run()\n    const result = verify.report()\n    process.exitCode = process.exitCode || result.exitCode\n    this.npm.output(result.report)\n  }\n}\n\nmodule.exports = Audit\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}