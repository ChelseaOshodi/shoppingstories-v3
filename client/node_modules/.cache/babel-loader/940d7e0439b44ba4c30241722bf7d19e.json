{"ast":null,"code":"const {\n  resolve\n} = require('path');\n\nconst semver = require('semver');\n\nconst libnpmdiff = require('libnpmdiff');\n\nconst npa = require('npm-package-arg');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst pacote = require('pacote');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst log = require('../utils/log-shim');\n\nconst readPackage = require('read-package-json-fast');\n\nconst BaseCommand = require('../base-command.js');\n\nclass Diff extends BaseCommand {\n  static description = 'The registry diff command';\n  static name = 'diff';\n  static usage = ['[...<paths>]'];\n  static params = ['diff', 'diff-name-only', 'diff-unified', 'diff-ignore-all-space', 'diff-no-prefix', 'diff-src-prefix', 'diff-dst-prefix', 'diff-text', 'global', 'tag', 'workspace', 'workspaces', 'include-workspace-root'];\n  static ignoreImplicitWorkspace = false;\n\n  async exec(args) {\n    const specs = this.npm.config.get('diff').filter(d => d);\n\n    if (specs.length > 2) {\n      throw this.usageError(`Can't use more than two --diff arguments.`);\n    } // execWorkspaces may have set this already\n\n\n    if (!this.prefix) {\n      this.prefix = this.npm.prefix;\n    } // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n\n\n    if (this.npm.global) {\n      this.top = resolve(this.npm.globalDir, '..');\n    } else {\n      this.top = this.prefix;\n    }\n\n    const [a, b] = await this.retrieveSpecs(specs);\n    log.info('diff', {\n      src: a,\n      dst: b\n    });\n    const res = await libnpmdiff([a, b], { ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top\n    });\n    return this.npm.output(res);\n  }\n\n  async execWorkspaces(args, filters) {\n    await this.setWorkspaces(filters);\n\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath;\n      this.prefix = workspacePath;\n      await this.exec(args);\n    }\n  } // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n\n\n  async packageName(path) {\n    let name;\n\n    try {\n      const pkg = await readPackage(resolve(this.prefix, 'package.json'));\n      name = pkg.name;\n    } catch (e) {\n      log.verbose('diff', 'could not read project dir package.json');\n    }\n\n    if (!name) {\n      throw this.usageError('Needs multiple arguments to compare or run from a project dir.');\n    }\n\n    return name;\n  }\n\n  async retrieveSpecs(_ref) {\n    let [a, b] = _ref;\n\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b]);\n      return this.findVersionsByPackageName(specs);\n    } // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n\n\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix);\n      return [`${pkgName}@${this.npm.config.get('tag')}`, `file:${this.prefix.replace(/#/g, '%23')}`];\n    } // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n\n\n    let noPackageJson;\n    let pkgName;\n\n    try {\n      const pkg = await readPackage(resolve(this.prefix, 'package.json'));\n      pkgName = pkg.name;\n    } catch (e) {\n      log.verbose('diff', 'could not read project dir package.json');\n      noPackageJson = true;\n    }\n\n    const missingPackageJson = this.usageError('Needs multiple arguments to compare or run from a project dir.'); // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n\n    if (semver.validRange(a)) {\n      if (!pkgName) {\n        throw missingPackageJson;\n      }\n\n      return [`${pkgName}@${a}`, `file:${this.prefix.replace(/#/g, '%23')}`];\n    } // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n\n\n    const spec = npa(a);\n\n    if (spec.registry) {\n      let actualTree;\n      let node;\n\n      try {\n        const opts = { ...this.npm.flatOptions,\n          path: this.top\n        };\n        const arb = new Arborist(opts);\n        actualTree = await arb.loadActual(opts);\n        node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      } catch (e) {\n        log.verbose('diff', 'failed to load actual install tree');\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson) {\n          throw missingPackageJson;\n        }\n\n        return [`${spec.name}@${spec.fetchSpec}`, `file:${this.prefix.replace(/#/g, '%23')}`];\n      }\n\n      const tryRootNodeSpec = () => (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec;\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn) {\n          return edge.spec;\n        }\n      };\n\n      const aSpec = `file:${node.realpath.replace(/#/g, '%23')}`; // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n\n      let bSpec;\n\n      if (spec.rawSpec) {\n        bSpec = spec.rawSpec;\n      } else {\n        const bTargetVersion = tryRootNodeSpec() || tryAnySpec(); // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n\n        const packument = await pacote.packument(spec, { ...this.npm.flatOptions,\n          preferOnline: true\n        });\n        bSpec = pickManifest(packument, bTargetVersion, { ...this.npm.flatOptions\n        }).version;\n      }\n\n      return [`${spec.name}@${aSpec}`, `${spec.name}@${bSpec}`];\n    } else if (spec.type === 'directory') {\n      return [`file:${spec.fetchSpec.replace(/#/g, '%23')}`, `file:${this.prefix.replace(/#/g, '%23')}`];\n    } else {\n      throw this.usageError(`Spec type ${spec.type} not supported.`);\n    }\n  }\n\n  async convertVersionsToSpecs(_ref2) {\n    let [a, b] = _ref2;\n    const semverA = semver.validRange(a);\n    const semverB = semver.validRange(b); // both specs are semver versions, assume current project dir name\n\n    if (semverA && semverB) {\n      let pkgName;\n\n      try {\n        const pkg = await readPackage(resolve(this.prefix, 'package.json'));\n        pkgName = pkg.name;\n      } catch (e) {\n        log.verbose('diff', 'could not read project dir package.json');\n      }\n\n      if (!pkgName) {\n        throw this.usageError('Needs to be run from a project dir in order to diff two versions.');\n      }\n\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`];\n    } // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n\n\n    if (!semverA && semverB) {\n      return [a, `${npa(a).name}@${b}`];\n    }\n\n    if (semverA && !semverB) {\n      return [`${npa(b).name}@${a}`, b];\n    } // no valid semver ranges used\n\n\n    return [a, b];\n  }\n\n  async findVersionsByPackageName(specs) {\n    let actualTree;\n\n    try {\n      const opts = { ...this.npm.flatOptions,\n        path: this.top\n      };\n      const arb = new Arborist(opts);\n      actualTree = await arb.loadActual(opts);\n    } catch (e) {\n      log.verbose('diff', 'failed to load actual install tree');\n    }\n\n    return specs.map(i => {\n      const spec = npa(i);\n\n      if (spec.rawSpec) {\n        return i;\n      }\n\n      const node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      const res = !node || !node.package || !node.package.version ? spec.fetchSpec : `file:${node.realpath.replace(/#/g, '%23')}`;\n      return `${spec.name}@${res}`;\n    });\n  }\n\n}\n\nmodule.exports = Diff;","map":{"version":3,"names":["resolve","require","semver","libnpmdiff","npa","Arborist","pacote","pickManifest","log","readPackage","BaseCommand","Diff","description","name","usage","params","ignoreImplicitWorkspace","exec","args","specs","npm","config","get","filter","d","length","usageError","prefix","global","top","globalDir","a","b","retrieveSpecs","info","src","dst","res","flatOptions","diffFiles","where","output","execWorkspaces","filters","setWorkspaces","workspacePath","workspacePaths","packageName","path","pkg","e","verbose","convertVersionsToSpecs","findVersionsByPackageName","pkgName","replace","noPackageJson","missingPackageJson","validRange","spec","registry","actualTree","node","opts","arb","loadActual","inventory","query","values","next","value","package","version","fetchSpec","tryRootNodeSpec","edgesOut","tryAnySpec","edge","edgesIn","aSpec","realpath","bSpec","rawSpec","bTargetVersion","packument","preferOnline","type","semverA","semverB","map","i","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/diff.js"],"sourcesContent":["const { resolve } = require('path')\nconst semver = require('semver')\nconst libnpmdiff = require('libnpmdiff')\nconst npa = require('npm-package-arg')\nconst Arborist = require('@npmcli/arborist')\nconst pacote = require('pacote')\nconst pickManifest = require('npm-pick-manifest')\nconst log = require('../utils/log-shim')\nconst readPackage = require('read-package-json-fast')\nconst BaseCommand = require('../base-command.js')\n\nclass Diff extends BaseCommand {\n  static description = 'The registry diff command'\n  static name = 'diff'\n  static usage = [\n    '[...<paths>]',\n  ]\n\n  static params = [\n    'diff',\n    'diff-name-only',\n    'diff-unified',\n    'diff-ignore-all-space',\n    'diff-no-prefix',\n    'diff-src-prefix',\n    'diff-dst-prefix',\n    'diff-text',\n    'global',\n    'tag',\n    'workspace',\n    'workspaces',\n    'include-workspace-root',\n  ]\n\n  static ignoreImplicitWorkspace = false\n\n  async exec (args) {\n    const specs = this.npm.config.get('diff').filter(d => d)\n    if (specs.length > 2) {\n      throw this.usageError(`Can't use more than two --diff arguments.`)\n    }\n\n    // execWorkspaces may have set this already\n    if (!this.prefix) {\n      this.prefix = this.npm.prefix\n    }\n\n    // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n    if (this.npm.global) {\n      this.top = resolve(this.npm.globalDir, '..')\n    } else {\n      this.top = this.prefix\n    }\n\n    const [a, b] = await this.retrieveSpecs(specs)\n    log.info('diff', { src: a, dst: b })\n\n    const res = await libnpmdiff([a, b], {\n      ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top,\n    })\n    return this.npm.output(res)\n  }\n\n  async execWorkspaces (args, filters) {\n    await this.setWorkspaces(filters)\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath\n      this.prefix = workspacePath\n      await this.exec(args)\n    }\n  }\n\n  // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n  async packageName (path) {\n    let name\n    try {\n      const pkg = await readPackage(resolve(this.prefix, 'package.json'))\n      name = pkg.name\n    } catch (e) {\n      log.verbose('diff', 'could not read project dir package.json')\n    }\n\n    if (!name) {\n      throw this.usageError('Needs multiple arguments to compare or run from a project dir.')\n    }\n\n    return name\n  }\n\n  async retrieveSpecs ([a, b]) {\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b])\n      return this.findVersionsByPackageName(specs)\n    }\n\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix)\n      return [\n        `${pkgName}@${this.npm.config.get('tag')}`,\n        `file:${this.prefix.replace(/#/g, '%23')}`,\n      ]\n    }\n\n    // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n    let noPackageJson\n    let pkgName\n    try {\n      const pkg = await readPackage(resolve(this.prefix, 'package.json'))\n      pkgName = pkg.name\n    } catch (e) {\n      log.verbose('diff', 'could not read project dir package.json')\n      noPackageJson = true\n    }\n\n    const missingPackageJson =\n      this.usageError('Needs multiple arguments to compare or run from a project dir.')\n\n    // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n    if (semver.validRange(a)) {\n      if (!pkgName) {\n        throw missingPackageJson\n      }\n      return [\n        `${pkgName}@${a}`,\n        `file:${this.prefix.replace(/#/g, '%23')}`,\n      ]\n    }\n\n    // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n    const spec = npa(a)\n    if (spec.registry) {\n      let actualTree\n      let node\n      try {\n        const opts = {\n          ...this.npm.flatOptions,\n          path: this.top,\n        }\n        const arb = new Arborist(opts)\n        actualTree = await arb.loadActual(opts)\n        node = actualTree &&\n          actualTree.inventory.query('name', spec.name)\n            .values().next().value\n      } catch (e) {\n        log.verbose('diff', 'failed to load actual install tree')\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson) {\n          throw missingPackageJson\n        }\n        return [\n          `${spec.name}@${spec.fetchSpec}`,\n          `file:${this.prefix.replace(/#/g, '%23')}`,\n        ]\n      }\n\n      const tryRootNodeSpec = () =>\n        (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn) {\n          return edge.spec\n        }\n      }\n\n      const aSpec = `file:${node.realpath.replace(/#/g, '%23')}`\n\n      // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n      let bSpec\n      if (spec.rawSpec) {\n        bSpec = spec.rawSpec\n      } else {\n        const bTargetVersion =\n          tryRootNodeSpec()\n          || tryAnySpec()\n\n        // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n        const packument = await pacote.packument(spec, {\n          ...this.npm.flatOptions,\n          preferOnline: true,\n        })\n        bSpec = pickManifest(\n          packument,\n          bTargetVersion,\n          { ...this.npm.flatOptions }\n        ).version\n      }\n\n      return [\n        `${spec.name}@${aSpec}`,\n        `${spec.name}@${bSpec}`,\n      ]\n    } else if (spec.type === 'directory') {\n      return [\n        `file:${spec.fetchSpec.replace(/#/g, '%23')}`,\n        `file:${this.prefix.replace(/#/g, '%23')}`,\n      ]\n    } else {\n      throw this.usageError(`Spec type ${spec.type} not supported.`)\n    }\n  }\n\n  async convertVersionsToSpecs ([a, b]) {\n    const semverA = semver.validRange(a)\n    const semverB = semver.validRange(b)\n\n    // both specs are semver versions, assume current project dir name\n    if (semverA && semverB) {\n      let pkgName\n      try {\n        const pkg = await readPackage(resolve(this.prefix, 'package.json'))\n        pkgName = pkg.name\n      } catch (e) {\n        log.verbose('diff', 'could not read project dir package.json')\n      }\n\n      if (!pkgName) {\n        throw this.usageError('Needs to be run from a project dir in order to diff two versions.')\n      }\n\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`]\n    }\n\n    // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n    if (!semverA && semverB) {\n      return [a, `${npa(a).name}@${b}`]\n    }\n\n    if (semverA && !semverB) {\n      return [`${npa(b).name}@${a}`, b]\n    }\n\n    // no valid semver ranges used\n    return [a, b]\n  }\n\n  async findVersionsByPackageName (specs) {\n    let actualTree\n    try {\n      const opts = {\n        ...this.npm.flatOptions,\n        path: this.top,\n      }\n      const arb = new Arborist(opts)\n      actualTree = await arb.loadActual(opts)\n    } catch (e) {\n      log.verbose('diff', 'failed to load actual install tree')\n    }\n\n    return specs.map(i => {\n      const spec = npa(i)\n      if (spec.rawSpec) {\n        return i\n      }\n\n      const node = actualTree\n        && actualTree.inventory.query('name', spec.name)\n          .values().next().value\n\n      const res = !node || !node.package || !node.package.version\n        ? spec.fetchSpec\n        : `file:${node.realpath.replace(/#/g, '%23')}`\n\n      return `${spec.name}@${res}`\n    })\n  }\n}\n\nmodule.exports = Diff\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}