{"ast":null,"code":"// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js');\n\nconst envReplace = require('./env-replace.js');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  parse: umaskParse\n} = require('./umask.js');\n\nconst parseField = function (f, key, opts) {\n  let listElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (typeof f !== 'string' && !Array.isArray(f)) {\n    return f;\n  }\n\n  const {\n    platform,\n    types,\n    home,\n    env\n  } = opts; // type can be array or a single thing.  coerce to array.\n\n  const typeList = new Set([].concat(types[key]));\n  const isPath = typeList.has(typeDefs.path.type);\n  const isBool = typeList.has(typeDefs.Boolean.type);\n  const isString = isPath || typeList.has(typeDefs.String.type);\n  const isUmask = typeList.has(typeDefs.Umask.type);\n  const isNumber = typeList.has(typeDefs.Number.type);\n  const isList = !listElement && typeList.has(Array);\n\n  if (Array.isArray(f)) {\n    return !isList ? f : f.map(field => parseField(field, key, opts, true));\n  } // now we know it's a string\n\n\n  f = f.trim(); // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n\n  if (isList) {\n    return parseField(f.split('\\n\\n'), key, opts);\n  } // --foo is like --foo=true for boolean types\n\n\n  if (isBool && !isString && f === '') {\n    return true;\n  } // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n\n\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true':\n        return true;\n\n      case 'false':\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  f = envReplace(f, env);\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//;\n\n    if (homePattern.test(f) && home) {\n      f = resolve(home, f.slice(2));\n    } else {\n      f = resolve(f);\n    }\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f);\n    } catch (er) {\n      // let it warn later when we validate\n      return f;\n    }\n  }\n\n  if (isNumber && !isNaN(f)) {\n    f = +f;\n  }\n\n  return f;\n};\n\nmodule.exports = parseField;","map":{"version":3,"names":["typeDefs","require","envReplace","resolve","parse","umaskParse","parseField","f","key","opts","listElement","Array","isArray","platform","types","home","env","typeList","Set","concat","isPath","has","path","type","isBool","Boolean","isString","String","isUmask","Umask","isNumber","Number","isList","map","field","trim","split","undefined","homePattern","test","slice","er","isNaN","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/config/lib/parse-field.js"],"sourcesContent":["// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js')\nconst envReplace = require('./env-replace.js')\nconst { resolve } = require('path')\n\nconst { parse: umaskParse } = require('./umask.js')\n\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f)) {\n    return f\n  }\n\n  const { platform, types, home, env } = opts\n\n  // type can be array or a single thing.  coerce to array.\n  const typeList = new Set([].concat(types[key]))\n  const isPath = typeList.has(typeDefs.path.type)\n  const isBool = typeList.has(typeDefs.Boolean.type)\n  const isString = isPath || typeList.has(typeDefs.String.type)\n  const isUmask = typeList.has(typeDefs.Umask.type)\n  const isNumber = typeList.has(typeDefs.Number.type)\n  const isList = !listElement && typeList.has(Array)\n\n  if (Array.isArray(f)) {\n    return !isList ? f : f.map(field => parseField(field, key, opts, true))\n  }\n\n  // now we know it's a string\n  f = f.trim()\n\n  // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n  if (isList) {\n    return parseField(f.split('\\n\\n'), key, opts)\n  }\n\n  // --foo is like --foo=true for boolean types\n  if (isBool && !isString && f === '') {\n    return true\n  }\n\n  // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true': return true\n      case 'false': return false\n      case 'null': return null\n      case 'undefined': return undefined\n    }\n  }\n\n  f = envReplace(f, env)\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n    if (homePattern.test(f) && home) {\n      f = resolve(home, f.slice(2))\n    } else {\n      f = resolve(f)\n    }\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f)\n    } catch (er) {\n      // let it warn later when we validate\n      return f\n    }\n  }\n\n  if (isNumber && !isNaN(f)) {\n    f = +f\n  }\n\n  return f\n}\n\nmodule.exports = parseField\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}