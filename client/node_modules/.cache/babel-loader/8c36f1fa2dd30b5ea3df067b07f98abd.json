{"ast":null,"code":"// Given a set of nodes in a tree, and a filter function to test\n// incoming edges to the dep set that should be ignored otherwise.\n//\n// find the set of deps that are only depended upon by nodes in the set, or\n// their dependencies, or edges that are ignored.\n//\n// Used when figuring out what to prune when replacing a node with a newer\n// version, or when an optional dep fails to install.\nconst gatherDepSet = (set, edgeFilter) => {\n  const deps = new Set(set); // add the full set of dependencies.  note that this loop will continue\n  // as the deps set increases in size.\n\n  for (const node of deps) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.to && edgeFilter(edge)) {\n        deps.add(edge.to);\n      }\n    }\n  } // now remove all nodes in the set that have a dependant outside the set\n  // if any change is made, then re-check\n  // continue until no changes made, or deps set evaporates fully.\n\n\n  let changed = true;\n\n  while (changed === true && deps.size > 0) {\n    changed = false;\n\n    for (const dep of deps) {\n      for (const edge of dep.edgesIn) {\n        if (!deps.has(edge.from) && edgeFilter(edge)) {\n          changed = true;\n          deps.delete(dep);\n          break;\n        }\n      }\n    }\n  }\n\n  return deps;\n};\n\nmodule.exports = gatherDepSet;","map":{"version":3,"names":["gatherDepSet","set","edgeFilter","deps","Set","node","edge","edgesOut","values","to","add","changed","size","dep","edgesIn","has","from","delete","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/gather-dep-set.js"],"sourcesContent":["// Given a set of nodes in a tree, and a filter function to test\n// incoming edges to the dep set that should be ignored otherwise.\n//\n// find the set of deps that are only depended upon by nodes in the set, or\n// their dependencies, or edges that are ignored.\n//\n// Used when figuring out what to prune when replacing a node with a newer\n// version, or when an optional dep fails to install.\n\nconst gatherDepSet = (set, edgeFilter) => {\n  const deps = new Set(set)\n\n  // add the full set of dependencies.  note that this loop will continue\n  // as the deps set increases in size.\n  for (const node of deps) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.to && edgeFilter(edge)) {\n        deps.add(edge.to)\n      }\n    }\n  }\n\n  // now remove all nodes in the set that have a dependant outside the set\n  // if any change is made, then re-check\n  // continue until no changes made, or deps set evaporates fully.\n  let changed = true\n  while (changed === true && deps.size > 0) {\n    changed = false\n    for (const dep of deps) {\n      for (const edge of dep.edgesIn) {\n        if (!deps.has(edge.from) && edgeFilter(edge)) {\n          changed = true\n          deps.delete(dep)\n          break\n        }\n      }\n    }\n  }\n\n  return deps\n}\n\nmodule.exports = gatherDepSet\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,YAAY,GAAG,CAACC,GAAD,EAAMC,UAAN,KAAqB;EACxC,MAAMC,IAAI,GAAG,IAAIC,GAAJ,CAAQH,GAAR,CAAb,CADwC,CAGxC;EACA;;EACA,KAAK,MAAMI,IAAX,IAAmBF,IAAnB,EAAyB;IACvB,KAAK,MAAMG,IAAX,IAAmBD,IAAI,CAACE,QAAL,CAAcC,MAAd,EAAnB,EAA2C;MACzC,IAAIF,IAAI,CAACG,EAAL,IAAWP,UAAU,CAACI,IAAD,CAAzB,EAAiC;QAC/BH,IAAI,CAACO,GAAL,CAASJ,IAAI,CAACG,EAAd;MACD;IACF;EACF,CAXuC,CAaxC;EACA;EACA;;;EACA,IAAIE,OAAO,GAAG,IAAd;;EACA,OAAOA,OAAO,KAAK,IAAZ,IAAoBR,IAAI,CAACS,IAAL,GAAY,CAAvC,EAA0C;IACxCD,OAAO,GAAG,KAAV;;IACA,KAAK,MAAME,GAAX,IAAkBV,IAAlB,EAAwB;MACtB,KAAK,MAAMG,IAAX,IAAmBO,GAAG,CAACC,OAAvB,EAAgC;QAC9B,IAAI,CAACX,IAAI,CAACY,GAAL,CAAST,IAAI,CAACU,IAAd,CAAD,IAAwBd,UAAU,CAACI,IAAD,CAAtC,EAA8C;UAC5CK,OAAO,GAAG,IAAV;UACAR,IAAI,CAACc,MAAL,CAAYJ,GAAZ;UACA;QACD;MACF;IACF;EACF;;EAED,OAAOV,IAAP;AACD,CA/BD;;AAiCAe,MAAM,CAACC,OAAP,GAAiBnB,YAAjB"},"metadata":{},"sourceType":"script"}