{"ast":null,"code":"// print a banner telling the user to upgrade npm to latest\n// but not in CI, and not if we're doing that already.\n// Check daily for betas, and weekly otherwise.\nconst pacote = require('pacote');\n\nconst ciDetect = require('@npmcli/ci-detect');\n\nconst semver = require('semver');\n\nconst chalk = require('chalk');\n\nconst {\n  promisify\n} = require('util');\n\nconst stat = promisify(require('fs').stat);\nconst writeFile = promisify(require('fs').writeFile);\n\nconst {\n  resolve\n} = require('path');\n\nconst SKIP = Symbol('SKIP');\n\nconst isGlobalNpmUpdate = npm => {\n  return npm.flatOptions.global && ['install', 'update'].includes(npm.command) && npm.argv.some(arg => /^npm(@|$)/.test(arg));\n}; // update check frequency\n\n\nconst DAILY = 1000 * 60 * 60 * 24;\nconst WEEKLY = DAILY * 7; // don't put it in the _cacache folder, just in npm's cache\n\nconst lastCheckedFile = npm => resolve(npm.flatOptions.cache, '../_update-notifier-last-checked');\n\nconst checkTimeout = async (npm, duration) => {\n  const t = new Date(Date.now() - duration);\n  const f = lastCheckedFile(npm); // if we don't have a file, then definitely check it.\n\n  const st = await stat(f).catch(() => ({\n    mtime: t - 1\n  }));\n  return t > st.mtime;\n};\n\nconst updateNotifier = async function (npm) {\n  let spec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'latest';\n\n  // never check for updates in CI, when updating npm already, or opted out\n  if (!npm.config.get('update-notifier') || isGlobalNpmUpdate(npm) || ciDetect()) {\n    return SKIP;\n  } // if we're on a prerelease train, then updates are coming fast\n  // check for a new one daily.  otherwise, weekly.\n\n\n  const {\n    version\n  } = npm;\n  const current = semver.parse(version); // if we're on a beta train, always get the next beta\n\n  if (current.prerelease.length) {\n    spec = `^${version}`;\n  } // while on a beta train, get updates daily\n\n\n  const duration = spec !== 'latest' ? DAILY : WEEKLY; // if we've already checked within the specified duration, don't check again\n\n  if (!(await checkTimeout(npm, duration))) {\n    return null;\n  } // if they're currently using a prerelease, nudge to the next prerelease\n  // otherwise, nudge to latest.\n\n\n  const useColor = npm.logColor;\n  const mani = await pacote.manifest(`npm@${spec}`, {\n    // always prefer latest, even if doing --tag=whatever on the cmd\n    defaultTag: 'latest',\n    ...npm.flatOptions\n  }).catch(() => null); // if pacote failed, give up\n\n  if (!mani) {\n    return null;\n  }\n\n  const latest = mani.version; // if the current version is *greater* than latest, we're on a 'next'\n  // and should get the updates from that release train.\n  // Note that this isn't another http request over the network, because\n  // the packument will be cached by pacote from previous request.\n\n  if (semver.gt(version, latest) && spec === 'latest') {\n    return updateNotifier(npm, `^${version}`);\n  } // if we already have something >= the desired spec, then we're done\n\n\n  if (semver.gte(version, latest)) {\n    return null;\n  } // ok!  notify the user about this update they should get.\n  // The message is saved for printing at process exit so it will not get\n  // lost in any other messages being printed as part of the command.\n\n\n  const update = semver.parse(mani.version);\n  const type = update.major !== current.major ? 'major' : update.minor !== current.minor ? 'minor' : update.patch !== current.patch ? 'patch' : 'prerelease';\n  const typec = !useColor ? type : type === 'major' ? chalk.red(type) : type === 'minor' ? chalk.yellow(type) : chalk.green(type);\n  const oldc = !useColor ? current : chalk.red(current);\n  const latestc = !useColor ? latest : chalk.green(latest);\n  const changelog = `https://github.com/npm/cli/releases/tag/v${latest}`;\n  const changelogc = !useColor ? `<${changelog}>` : chalk.cyan(changelog);\n  const cmd = `npm install -g npm@${latest}`;\n  const cmdc = !useColor ? `\\`${cmd}\\`` : chalk.green(cmd);\n  const message = `\\nNew ${typec} version of npm available! ` + `${oldc} -> ${latestc}\\n` + `Changelog: ${changelogc}\\n` + `Run ${cmdc} to update!\\n`;\n  return message;\n}; // only update the notification timeout if we actually finished checking\n\n\nmodule.exports = async npm => {\n  const notification = await updateNotifier(npm); // dont write the file if we skipped checking altogether\n\n  if (notification === SKIP) {\n    return null;\n  } // intentional.  do not await this.  it's a best-effort update.  if this\n  // fails, it's ok.  might be using /dev/null as the cache or something weird\n  // like that.\n\n\n  writeFile(lastCheckedFile(npm), '').catch(() => {});\n  return notification;\n};","map":{"version":3,"names":["pacote","require","ciDetect","semver","chalk","promisify","stat","writeFile","resolve","SKIP","Symbol","isGlobalNpmUpdate","npm","flatOptions","global","includes","command","argv","some","arg","test","DAILY","WEEKLY","lastCheckedFile","cache","checkTimeout","duration","t","Date","now","f","st","catch","mtime","updateNotifier","spec","config","get","version","current","parse","prerelease","length","useColor","logColor","mani","manifest","defaultTag","latest","gt","gte","update","type","major","minor","patch","typec","red","yellow","green","oldc","latestc","changelog","changelogc","cyan","cmd","cmdc","message","module","exports","notification"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/utils/update-notifier.js"],"sourcesContent":["// print a banner telling the user to upgrade npm to latest\n// but not in CI, and not if we're doing that already.\n// Check daily for betas, and weekly otherwise.\n\nconst pacote = require('pacote')\nconst ciDetect = require('@npmcli/ci-detect')\nconst semver = require('semver')\nconst chalk = require('chalk')\nconst { promisify } = require('util')\nconst stat = promisify(require('fs').stat)\nconst writeFile = promisify(require('fs').writeFile)\nconst { resolve } = require('path')\n\nconst SKIP = Symbol('SKIP')\n\nconst isGlobalNpmUpdate = npm => {\n  return npm.flatOptions.global &&\n    ['install', 'update'].includes(npm.command) &&\n    npm.argv.some(arg => /^npm(@|$)/.test(arg))\n}\n\n// update check frequency\nconst DAILY = 1000 * 60 * 60 * 24\nconst WEEKLY = DAILY * 7\n\n// don't put it in the _cacache folder, just in npm's cache\nconst lastCheckedFile = npm =>\n  resolve(npm.flatOptions.cache, '../_update-notifier-last-checked')\n\nconst checkTimeout = async (npm, duration) => {\n  const t = new Date(Date.now() - duration)\n  const f = lastCheckedFile(npm)\n  // if we don't have a file, then definitely check it.\n  const st = await stat(f).catch(() => ({ mtime: t - 1 }))\n  return t > st.mtime\n}\n\nconst updateNotifier = async (npm, spec = 'latest') => {\n  // never check for updates in CI, when updating npm already, or opted out\n  if (!npm.config.get('update-notifier') ||\n      isGlobalNpmUpdate(npm) ||\n      ciDetect()) {\n    return SKIP\n  }\n\n  // if we're on a prerelease train, then updates are coming fast\n  // check for a new one daily.  otherwise, weekly.\n  const { version } = npm\n  const current = semver.parse(version)\n\n  // if we're on a beta train, always get the next beta\n  if (current.prerelease.length) {\n    spec = `^${version}`\n  }\n\n  // while on a beta train, get updates daily\n  const duration = spec !== 'latest' ? DAILY : WEEKLY\n\n  // if we've already checked within the specified duration, don't check again\n  if (!(await checkTimeout(npm, duration))) {\n    return null\n  }\n\n  // if they're currently using a prerelease, nudge to the next prerelease\n  // otherwise, nudge to latest.\n  const useColor = npm.logColor\n\n  const mani = await pacote.manifest(`npm@${spec}`, {\n    // always prefer latest, even if doing --tag=whatever on the cmd\n    defaultTag: 'latest',\n    ...npm.flatOptions,\n  }).catch(() => null)\n\n  // if pacote failed, give up\n  if (!mani) {\n    return null\n  }\n\n  const latest = mani.version\n\n  // if the current version is *greater* than latest, we're on a 'next'\n  // and should get the updates from that release train.\n  // Note that this isn't another http request over the network, because\n  // the packument will be cached by pacote from previous request.\n  if (semver.gt(version, latest) && spec === 'latest') {\n    return updateNotifier(npm, `^${version}`)\n  }\n\n  // if we already have something >= the desired spec, then we're done\n  if (semver.gte(version, latest)) {\n    return null\n  }\n\n  // ok!  notify the user about this update they should get.\n  // The message is saved for printing at process exit so it will not get\n  // lost in any other messages being printed as part of the command.\n  const update = semver.parse(mani.version)\n  const type = update.major !== current.major ? 'major'\n    : update.minor !== current.minor ? 'minor'\n    : update.patch !== current.patch ? 'patch'\n    : 'prerelease'\n  const typec = !useColor ? type\n    : type === 'major' ? chalk.red(type)\n    : type === 'minor' ? chalk.yellow(type)\n    : chalk.green(type)\n  const oldc = !useColor ? current : chalk.red(current)\n  const latestc = !useColor ? latest : chalk.green(latest)\n  const changelog = `https://github.com/npm/cli/releases/tag/v${latest}`\n  const changelogc = !useColor ? `<${changelog}>` : chalk.cyan(changelog)\n  const cmd = `npm install -g npm@${latest}`\n  const cmdc = !useColor ? `\\`${cmd}\\`` : chalk.green(cmd)\n  const message = `\\nNew ${typec} version of npm available! ` +\n    `${oldc} -> ${latestc}\\n` +\n    `Changelog: ${changelogc}\\n` +\n    `Run ${cmdc} to update!\\n`\n\n  return message\n}\n\n// only update the notification timeout if we actually finished checking\nmodule.exports = async npm => {\n  const notification = await updateNotifier(npm)\n\n  // dont write the file if we skipped checking altogether\n  if (notification === SKIP) {\n    return null\n  }\n\n  // intentional.  do not await this.  it's a best-effort update.  if this\n  // fails, it's ok.  might be using /dev/null as the cache or something weird\n  // like that.\n  writeFile(lastCheckedFile(npm), '').catch(() => {})\n  return notification\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}