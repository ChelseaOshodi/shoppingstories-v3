{"ast":null,"code":"'use strict';\n\nconst {\n  promisify\n} = require('util');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst ciDetect = require('@npmcli/ci-detect');\n\nconst crypto = require('crypto');\n\nconst log = require('proc-log');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst npa = require('npm-package-arg');\n\nconst npmlog = require('npmlog');\n\nconst pacote = require('pacote');\n\nconst read = promisify(require('read'));\n\nconst semver = require('semver');\n\nconst {\n  fileExists,\n  localFileExists\n} = require('./file-exists.js');\n\nconst getBinFromManifest = require('./get-bin-from-manifest.js');\n\nconst noTTY = require('./no-tty.js');\n\nconst runScript = require('./run-script.js');\n\nconst isWindows = require('./is-windows.js');\n\nconst {\n  dirname,\n  resolve\n} = require('path');\n\nconst binPaths = []; // when checking the local tree we look up manifests, cache those results by\n// spec.raw so we don't have to fetch again when we check npxCache\n\nconst manifests = new Map();\n\nconst getManifest = async (spec, flatOptions) => {\n  if (!manifests.has(spec.raw)) {\n    const manifest = await pacote.manifest(spec, { ...flatOptions,\n      preferOnline: true\n    });\n    manifests.set(spec.raw, manifest);\n  }\n\n  return manifests.get(spec.raw);\n}; // Returns the required manifest if the spec is missing from the tree\n// Returns the found node if it is in the tree\n\n\nconst missingFromTree = async _ref => {\n  let {\n    spec,\n    tree,\n    flatOptions\n  } = _ref;\n\n  if (spec.registry && (spec.rawSpec === '' || spec.type !== 'tag')) {\n    // registry spec that is not a specific tag.\n    const nodesBySpec = tree.inventory.query('packageName', spec.name);\n\n    for (const node of nodesBySpec) {\n      if (spec.type === 'tag') {\n        // package requested by name only\n        return {\n          node\n        };\n      } else if (spec.type === 'version') {\n        // package requested by specific version\n        if (node.pkgid === spec.raw) {\n          return {\n            node\n          };\n        }\n      } else {\n        // package requested by version range, only remaining registry type\n        if (semver.satisfies(node.package.version, spec.rawSpec)) {\n          return {\n            node\n          };\n        }\n      }\n    }\n\n    const manifest = await getManifest(spec, flatOptions);\n    return {\n      manifest\n    };\n  } else {\n    // non-registry spec, or a specific tag.  Look up manifest and check\n    // resolved to see if it's in the tree.\n    const manifest = await getManifest(spec, flatOptions);\n    const nodesByManifest = tree.inventory.query('packageName', manifest.name);\n\n    for (const node of nodesByManifest) {\n      if (node.package.resolved === manifest._resolved) {\n        // we have a package by the same name and the same resolved destination, nothing to add.\n        return {\n          node\n        };\n      }\n    }\n\n    return {\n      manifest\n    };\n  }\n};\n\nconst exec = async opts => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    globalPath,\n    output,\n    // dereference values because we manipulate it later\n    packages: [...packages] = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts;\n\n  const run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    output,\n    path,\n    binPaths,\n    runPath,\n    scriptShell\n  }); // interactive mode\n\n\n  if (!call && !args.length && !packages.length) {\n    return run();\n  }\n\n  const needPackageCommandSwap = args.length > 0 && packages.length === 0; // If they asked for a command w/o specifying a package, see if there is a\n  // bin that directly matches that name either globally or in the local tree.\n\n  if (needPackageCommandSwap) {\n    const dir = dirname(dirname(localBin));\n    const localBinPath = await localFileExists(dir, args[0], '/');\n\n    if (localBinPath) {\n      binPaths.push(localBinPath);\n      return await run();\n    } else if (globalPath && (await fileExists(`${globalBin}/${args[0]}`))) {\n      binPaths.push(globalBin);\n      return await run();\n    } // We swap out args[0] with the bin from the manifest later\n\n\n    packages.push(args[0]);\n  }\n\n  const localArb = new Arborist({ ...flatOptions,\n    path\n  });\n  const localTree = await localArb.loadActual(); // Find anything that isn't installed locally\n\n  const needInstall = [];\n  let commandManifest;\n  await Promise.all(packages.map(async (pkg, i) => {\n    const spec = npa(pkg, path);\n    const {\n      manifest,\n      node\n    } = await missingFromTree({\n      spec,\n      tree: localTree,\n      flatOptions\n    });\n\n    if (manifest) {\n      // Package does not exist in the local tree\n      needInstall.push({\n        spec,\n        manifest\n      });\n\n      if (i === 0) {\n        commandManifest = manifest;\n      }\n    } else if (i === 0) {\n      // The node.package has enough to look up the bin\n      commandManifest = node.package;\n    }\n  }));\n\n  if (needPackageCommandSwap) {\n    const spec = npa(args[0]);\n    args[0] = getBinFromManifest(commandManifest);\n\n    if (needInstall.length > 0 && globalPath) {\n      // See if the package is installed globally, and run the translated bin\n      const globalArb = new Arborist({ ...flatOptions,\n        path: globalPath,\n        global: true\n      });\n      const globalTree = await globalArb.loadActual();\n      const {\n        manifest: globalManifest\n      } = await missingFromTree({\n        spec,\n        tree: globalTree,\n        flatOptions\n      });\n\n      if (!globalManifest && (await fileExists(`${globalBin}/${args[0]}`))) {\n        binPaths.push(globalBin);\n        return await run();\n      }\n    }\n  }\n\n  const add = [];\n\n  if (needInstall.length > 0) {\n    // Install things to the npx cache, if needed\n    const {\n      npxCache\n    } = flatOptions;\n\n    if (!npxCache) {\n      throw new Error('Must provide a valid npxCache path');\n    }\n\n    const hash = crypto.createHash('sha512').update(packages.sort((a, b) => a.localeCompare(b, 'en')).join('\\n')).digest('hex').slice(0, 16);\n    const installDir = resolve(npxCache, hash);\n    await mkdirp(installDir);\n    const npxArb = new Arborist({ ...flatOptions,\n      path: installDir\n    });\n    const npxTree = await npxArb.loadActual();\n    await Promise.all(needInstall.map(async _ref2 => {\n      let {\n        spec\n      } = _ref2;\n      const {\n        manifest\n      } = await missingFromTree({\n        spec,\n        tree: npxTree,\n        flatOptions\n      });\n\n      if (manifest) {\n        // Manifest is not in npxCache, we need to install it there\n        if (!spec.registry) {\n          add.push(manifest._from);\n        } else {\n          add.push(manifest._id);\n        }\n      }\n    }));\n\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false) {\n          throw new Error('canceled');\n        }\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${add.length === 1 ? ' was' : 's were'} not found and will be installed: ${add.map(pkg => pkg.replace(/@$/, '')).join(', ')}`);\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`).join('\\n') + '\\n';\n          const prompt = `Need to install the following packages:\\n${addList}Ok to proceed? `;\n          npmlog.clearProgress();\n          const confirm = await read({\n            prompt,\n            default: 'y'\n          });\n\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y') {\n            throw new Error('canceled');\n          }\n        }\n      }\n\n      await npxArb.reify({ ...flatOptions,\n        add\n      });\n    }\n\n    binPaths.push(resolve(installDir, 'node_modules/.bin'));\n  }\n\n  return await run();\n};\n\nmodule.exports = exec;","map":{"version":3,"names":["promisify","require","Arborist","ciDetect","crypto","log","mkdirp","npa","npmlog","pacote","read","semver","fileExists","localFileExists","getBinFromManifest","noTTY","runScript","isWindows","dirname","resolve","binPaths","manifests","Map","getManifest","spec","flatOptions","has","raw","manifest","preferOnline","set","get","missingFromTree","tree","registry","rawSpec","type","nodesBySpec","inventory","query","name","node","pkgid","satisfies","package","version","nodesByManifest","resolved","_resolved","exec","opts","args","call","color","localBin","locationMsg","undefined","globalBin","globalPath","output","packages","path","runPath","scriptShell","process","env","ComSpec","yes","run","length","needPackageCommandSwap","dir","localBinPath","push","localArb","localTree","loadActual","needInstall","commandManifest","Promise","all","map","pkg","i","globalArb","global","globalTree","globalManifest","add","npxCache","Error","hash","createHash","update","sort","a","b","localeCompare","join","digest","slice","installDir","npxArb","npxTree","_from","_id","warn","replace","addList","prompt","clearProgress","confirm","default","trim","toLowerCase","charAt","reify","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/libnpmexec/lib/index.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\n\nconst Arborist = require('@npmcli/arborist')\nconst ciDetect = require('@npmcli/ci-detect')\nconst crypto = require('crypto')\nconst log = require('proc-log')\nconst mkdirp = require('mkdirp-infer-owner')\nconst npa = require('npm-package-arg')\nconst npmlog = require('npmlog')\nconst pacote = require('pacote')\nconst read = promisify(require('read'))\nconst semver = require('semver')\n\nconst { fileExists, localFileExists } = require('./file-exists.js')\nconst getBinFromManifest = require('./get-bin-from-manifest.js')\nconst noTTY = require('./no-tty.js')\nconst runScript = require('./run-script.js')\nconst isWindows = require('./is-windows.js')\n\nconst { dirname, resolve } = require('path')\n\nconst binPaths = []\n\n// when checking the local tree we look up manifests, cache those results by\n// spec.raw so we don't have to fetch again when we check npxCache\nconst manifests = new Map()\n\nconst getManifest = async (spec, flatOptions) => {\n  if (!manifests.has(spec.raw)) {\n    const manifest = await pacote.manifest(spec, { ...flatOptions, preferOnline: true })\n    manifests.set(spec.raw, manifest)\n  }\n  return manifests.get(spec.raw)\n}\n\n// Returns the required manifest if the spec is missing from the tree\n// Returns the found node if it is in the tree\nconst missingFromTree = async ({ spec, tree, flatOptions }) => {\n  if (spec.registry && (spec.rawSpec === '' || spec.type !== 'tag')) {\n    // registry spec that is not a specific tag.\n    const nodesBySpec = tree.inventory.query('packageName', spec.name)\n    for (const node of nodesBySpec) {\n      if (spec.type === 'tag') {\n        // package requested by name only\n        return { node }\n      } else if (spec.type === 'version') {\n        // package requested by specific version\n        if (node.pkgid === spec.raw) {\n          return { node }\n        }\n      } else {\n        // package requested by version range, only remaining registry type\n        if (semver.satisfies(node.package.version, spec.rawSpec)) {\n          return { node }\n        }\n      }\n    }\n    const manifest = await getManifest(spec, flatOptions)\n    return { manifest }\n  } else {\n    // non-registry spec, or a specific tag.  Look up manifest and check\n    // resolved to see if it's in the tree.\n    const manifest = await getManifest(spec, flatOptions)\n    const nodesByManifest = tree.inventory.query('packageName', manifest.name)\n    for (const node of nodesByManifest) {\n      if (node.package.resolved === manifest._resolved) {\n        // we have a package by the same name and the same resolved destination, nothing to add.\n        return { node }\n      }\n    }\n    return { manifest }\n  }\n}\n\nconst exec = async (opts) => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    globalPath,\n    output,\n    // dereference values because we manipulate it later\n    packages: [...packages] = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts\n\n  const run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    output,\n    path,\n    binPaths,\n    runPath,\n    scriptShell,\n  })\n\n  // interactive mode\n  if (!call && !args.length && !packages.length) {\n    return run()\n  }\n\n  const needPackageCommandSwap = (args.length > 0) && (packages.length === 0)\n  // If they asked for a command w/o specifying a package, see if there is a\n  // bin that directly matches that name either globally or in the local tree.\n  if (needPackageCommandSwap) {\n    const dir = dirname(dirname(localBin))\n    const localBinPath = await localFileExists(dir, args[0], '/')\n    if (localBinPath) {\n      binPaths.push(localBinPath)\n      return await run()\n    } else if (globalPath && await fileExists(`${globalBin}/${args[0]}`)) {\n      binPaths.push(globalBin)\n      return await run()\n    }\n\n    // We swap out args[0] with the bin from the manifest later\n    packages.push(args[0])\n  }\n\n  const localArb = new Arborist({ ...flatOptions, path })\n  const localTree = await localArb.loadActual()\n\n  // Find anything that isn't installed locally\n  const needInstall = []\n  let commandManifest\n  await Promise.all(packages.map(async (pkg, i) => {\n    const spec = npa(pkg, path)\n    const { manifest, node } = await missingFromTree({ spec, tree: localTree, flatOptions })\n    if (manifest) {\n      // Package does not exist in the local tree\n      needInstall.push({ spec, manifest })\n      if (i === 0) {\n        commandManifest = manifest\n      }\n    } else if (i === 0) {\n      // The node.package has enough to look up the bin\n      commandManifest = node.package\n    }\n  }))\n\n  if (needPackageCommandSwap) {\n    const spec = npa(args[0])\n\n    args[0] = getBinFromManifest(commandManifest)\n\n    if (needInstall.length > 0 && globalPath) {\n      // See if the package is installed globally, and run the translated bin\n      const globalArb = new Arborist({ ...flatOptions, path: globalPath, global: true })\n      const globalTree = await globalArb.loadActual()\n      const { manifest: globalManifest } =\n        await missingFromTree({ spec, tree: globalTree, flatOptions })\n      if (!globalManifest && await fileExists(`${globalBin}/${args[0]}`)) {\n        binPaths.push(globalBin)\n        return await run()\n      }\n    }\n  }\n\n  const add = []\n  if (needInstall.length > 0) {\n    // Install things to the npx cache, if needed\n    const { npxCache } = flatOptions\n    if (!npxCache) {\n      throw new Error('Must provide a valid npxCache path')\n    }\n    const hash = crypto.createHash('sha512')\n      .update(packages.sort((a, b) => a.localeCompare(b, 'en')).join('\\n'))\n      .digest('hex')\n      .slice(0, 16)\n    const installDir = resolve(npxCache, hash)\n    await mkdirp(installDir)\n    const npxArb = new Arborist({\n      ...flatOptions,\n      path: installDir,\n    })\n    const npxTree = await npxArb.loadActual()\n    await Promise.all(needInstall.map(async ({ spec }) => {\n      const { manifest } = await missingFromTree({ spec, tree: npxTree, flatOptions })\n      if (manifest) {\n        // Manifest is not in npxCache, we need to install it there\n        if (!spec.registry) {\n          add.push(manifest._from)\n        } else {\n          add.push(manifest._id)\n        }\n      }\n    }))\n\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false) {\n          throw new Error('canceled')\n        }\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${\n            add.length === 1 ? ' was' : 's were'\n          } not found and will be installed: ${\n            add.map((pkg) => pkg.replace(/@$/, '')).join(', ')\n          }`)\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`)\n            .join('\\n') + '\\n'\n          const prompt = `Need to install the following packages:\\n${\n          addList\n        }Ok to proceed? `\n          npmlog.clearProgress()\n          const confirm = await read({ prompt, default: 'y' })\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y') {\n            throw new Error('canceled')\n          }\n        }\n      }\n      await npxArb.reify({\n        ...flatOptions,\n        add,\n      })\n    }\n    binPaths.push(resolve(installDir, 'node_modules/.bin'))\n  }\n\n  return await run()\n}\n\nmodule.exports = exec\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}