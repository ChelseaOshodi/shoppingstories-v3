{"ast":null,"code":"const tar = require('tar');\n\nconst minimatch = require('minimatch');\n\nconst normalizeMatch = str => str.replace(/\\\\+/g, '/').replace(/^\\.\\/|^\\./, ''); // files and refs are mutating params\n// filterFiles, item, prefix and opts are read-only options\n\n\nconst untar = (_ref, _ref2) => {\n  let {\n    files,\n    refs\n  } = _ref;\n  let {\n    filterFiles,\n    item,\n    prefix\n  } = _ref2;\n  tar.list({\n    filter: (path, entry) => {\n      const fileMatch = () => !filterFiles.length || filterFiles.some(f => {\n        const pattern = normalizeMatch(f);\n        return minimatch(normalizeMatch(path), `{package/,}${pattern}`, {\n          matchBase: pattern.startsWith('*')\n        });\n      }); // expands usage of simple path filters, e.g: lib or src/\n\n\n      const folderMatch = () => filterFiles.some(f => normalizeMatch(path).startsWith(normalizeMatch(f)) || normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`));\n\n      if (entry.type === 'File' && (fileMatch() || folderMatch())) {\n        const key = path.replace(/^[^/]+\\/?/, '');\n        files.add(key); // should skip reading file when using --name-only option\n\n        let content;\n\n        try {\n          entry.setEncoding('utf8');\n          content = entry.concat();\n        } catch (e) {\n          /* istanbul ignore next */\n          throw Object.assign(new Error('failed to read files'), {\n            code: 'EDIFFUNTAR'\n          });\n        }\n\n        refs.set(`${prefix}${key}`, {\n          content,\n          mode: `100${entry.mode.toString(8)}`\n        });\n        return true;\n      }\n    }\n  }).on('error',\n  /* istanbul ignore next */\n  e => {\n    throw e;\n  }).end(item);\n};\n\nconst readTarballs = async function (tarballs) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const files = new Set();\n  const refs = new Map();\n  const arr = [].concat(tarballs);\n  const filterFiles = opts.diffFiles || [];\n\n  for (const i of arr) {\n    untar({\n      files,\n      refs\n    }, {\n      item: i.item,\n      prefix: i.prefix,\n      filterFiles\n    });\n  } // await to read all content from included files\n\n\n  const allRefs = [...refs.values()];\n  const contents = await Promise.all(allRefs.map(async ref => ref.content));\n  contents.forEach((content, index) => {\n    allRefs[index].content = content;\n  });\n  return {\n    files,\n    refs\n  };\n};\n\nmodule.exports = readTarballs;","map":{"version":3,"names":["tar","require","minimatch","normalizeMatch","str","replace","untar","files","refs","filterFiles","item","prefix","list","filter","path","entry","fileMatch","length","some","f","pattern","matchBase","startsWith","folderMatch","type","key","add","content","setEncoding","concat","e","Object","assign","Error","code","set","mode","toString","on","end","readTarballs","tarballs","opts","Set","Map","arr","diffFiles","i","allRefs","values","contents","Promise","all","map","ref","forEach","index","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/libnpmdiff/lib/untar.js"],"sourcesContent":["const tar = require('tar')\nconst minimatch = require('minimatch')\n\nconst normalizeMatch = str => str\n  .replace(/\\\\+/g, '/')\n  .replace(/^\\.\\/|^\\./, '')\n\n// files and refs are mutating params\n// filterFiles, item, prefix and opts are read-only options\nconst untar = ({ files, refs }, { filterFiles, item, prefix }) => {\n  tar.list({\n    filter: (path, entry) => {\n      const fileMatch = () =>\n        (!filterFiles.length ||\n          filterFiles.some(f => {\n            const pattern = normalizeMatch(f)\n            return minimatch(\n              normalizeMatch(path),\n              `{package/,}${pattern}`,\n              { matchBase: pattern.startsWith('*') }\n            )\n          }))\n\n      // expands usage of simple path filters, e.g: lib or src/\n      const folderMatch = () =>\n        filterFiles.some(f =>\n          normalizeMatch(path).startsWith(normalizeMatch(f)) ||\n          normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`))\n\n      if (\n        entry.type === 'File' &&\n        (fileMatch() || folderMatch())\n      ) {\n        const key = path.replace(/^[^/]+\\/?/, '')\n        files.add(key)\n\n        // should skip reading file when using --name-only option\n        let content\n        try {\n          entry.setEncoding('utf8')\n          content = entry.concat()\n        } catch (e) {\n          /* istanbul ignore next */\n          throw Object.assign(\n            new Error('failed to read files'),\n            { code: 'EDIFFUNTAR' }\n          )\n        }\n\n        refs.set(`${prefix}${key}`, {\n          content,\n          mode: `100${entry.mode.toString(8)}`,\n        })\n        return true\n      }\n    },\n  })\n    .on('error', /* istanbul ignore next */ e => {\n      throw e\n    })\n    .end(item)\n}\n\nconst readTarballs = async (tarballs, opts = {}) => {\n  const files = new Set()\n  const refs = new Map()\n  const arr = [].concat(tarballs)\n\n  const filterFiles = opts.diffFiles || []\n\n  for (const i of arr) {\n    untar({\n      files,\n      refs,\n    }, {\n      item: i.item,\n      prefix: i.prefix,\n      filterFiles,\n    })\n  }\n\n  // await to read all content from included files\n  const allRefs = [...refs.values()]\n  const contents = await Promise.all(allRefs.map(async ref => ref.content))\n\n  contents.forEach((content, index) => {\n    allRefs[index].content = content\n  })\n\n  return {\n    files,\n    refs,\n  }\n}\n\nmodule.exports = readTarballs\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}