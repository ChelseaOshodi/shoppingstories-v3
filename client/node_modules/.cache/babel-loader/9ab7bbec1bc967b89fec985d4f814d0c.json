{"ast":null,"code":"// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst semver = require('semver');\n\nconst debug = require('./debug.js');\n\nconst peerEntrySets = require('./peer-entry-sets.js');\n\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\n\nconst CONFLICT = Symbol('CONFLICT');\nconst OK = Symbol('OK');\nconst REPLACE = Symbol('REPLACE');\nconst KEEP = Symbol('KEEP');\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor(options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false\n    } = options;\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep');\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep');\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep');\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(_ref => {\n        let [loc, {\n          packageName,\n          version,\n          resolved\n        }] = _ref;\n        return [loc, packageName, version, resolved];\n      }).sort((_ref2, _ref3) => {\n        let [a] = _ref2;\n        let [b] = _ref3;\n        return localeCompare(a, b);\n      }));\n    }); // the result of whether we can place it or not\n\n    this.canPlace = null; // if peers conflict, but this one doesn't, then that is useful info\n\n    this.canPlaceSelf = null;\n    this.dep = dep;\n    this.target = target;\n    this.edge = edge;\n    this.explicitRequest = explicitRequest; // preventing cycles when we check peer sets\n\n    this.peerPath = peerPath; // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n\n    this.preferDedupe = !!preferDedupe || edge.peer;\n    this.parent = parent;\n    this.children = [];\n    this.isSource = target === this.peerSetSource;\n    this.name = edge.name;\n    this.current = target.children.get(this.name);\n    this.targetEdge = target.edgesOut.get(this.name);\n    this.conflicts = new Map(); // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n\n    this.edgeOverride = !dep.satisfies(edge);\n    this.canPlace = this.checkCanPlace();\n\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace;\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(_ref4 => {\n        let [loc, {\n          packageName,\n          version,\n          resolved\n        }] = _ref4;\n        return [loc, packageName, version, resolved];\n      }).sort((_ref5, _ref6) => {\n        let [a] = _ref5;\n        let [b] = _ref6;\n        return localeCompare(a, b);\n      }));\n      /* istanbul ignore if */\n\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot\n        });\n      }\n    });\n  }\n\n  checkCanPlace() {\n    const {\n      target,\n      targetEdge,\n      current,\n      dep\n    } = this; // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n\n    if (dep.errors.length) {\n      return current ? REPLACE : OK;\n    } // cannot place peers inside their dependents, except for tops\n\n\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT;\n    } // skip this test if there's a current node, because we might be able\n    // to dedupe against it anyway\n\n\n    if (!current && targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {\n      return CONFLICT;\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent();\n  } // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n\n\n  checkCanPlaceCurrent() {\n    const {\n      preferDedupe,\n      explicitRequest,\n      current,\n      target,\n      edge,\n      dep\n    } = this;\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP;\n      }\n    }\n\n    const {\n      version: curVer\n    } = current;\n    const {\n      version: newVer\n    } = dep;\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer);\n\n    if (tryReplace && dep.canReplace(current)) {\n      // It's extremely rare that a replaceable node would be a conflict, if\n      // the current one wasn't a conflict, but it is theoretically possible\n      // if peer deps are pinned.  In that case we treat it like any other\n      // conflict, and keep trying.\n      const cpp = this.canPlacePeers(REPLACE);\n\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    } // ok, can't replace the current with new one, but maybe current is ok?\n\n\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP;\n    } // if we prefer deduping, then try replacing newer with older\n\n\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE);\n\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    } // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n\n\n    const myDeepest = this.deepestNestingTarget; // ok, i COULD be placed deeper, so leave the current one alone.\n\n    if (target !== myDeepest) {\n      return CONFLICT;\n    } // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n\n\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE);\n    } // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n\n    /* istanbul ignore if - allegedly impossible */\n\n\n    if (!this.parent && !edge.peer) {\n      return CONFLICT;\n    } // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n\n\n    let canReplace = true;\n\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue;\n      } // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n\n\n      const entryNode = entryEdge.to;\n      const entryRep = dep.parent.children.get(entryNode.name);\n\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue;\n        }\n      }\n\n      let canClobber = !entryRep;\n\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode]);\n\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue;\n            }\n\n            const rep = dep.parent.children.get(edge.name);\n\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to);\n              }\n\n              continue;\n            }\n\n            if (!rep.satisfies(edge)) {\n              canClobber = false;\n              break OUTER;\n            }\n          }\n        }\n      }\n\n      if (canClobber) {\n        continue;\n      } // ok, we can't replace, but maybe we can nest the current set deeper?\n\n\n      let canNestCurrent = true;\n\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break;\n        } // still possible to nest this peerSet\n\n\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name);\n\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false;\n          canReplace = false;\n        }\n\n        if (canNestCurrent) {\n          continue;\n        }\n      }\n    } // if we can nest or replace all the current peer groups, we can replace.\n\n\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE);\n    }\n\n    return CONFLICT;\n  }\n\n  checkCanPlaceNoCurrent() {\n    const {\n      target,\n      peerEntryEdge,\n      dep,\n      name\n    } = this; // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n\n    const current = target !== peerEntryEdge.from && target.resolve(name);\n\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT;\n          }\n        }\n      }\n    } // no objections, so this is fine as long as peers are ok here.\n\n\n    return this.canPlacePeers(OK);\n  }\n\n  get deepestNestingTarget() {\n    const start = this.parent ? this.parent.deepestNestingTarget : this.edge.from;\n    return deepestNestingTarget(start, this.name);\n  }\n\n  get conflictChildren() {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT);\n  }\n\n  get allChildren() {\n    const set = new Set(this.children);\n\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n\n    return [...set];\n  }\n\n  get top() {\n    return this.parent ? this.parent.top : this;\n  } // check if peers can go here.  returns state or CONFLICT\n\n\n  canPlacePeers(state) {\n    this.canPlaceSelf = state;\n\n    if (this._canPlacePeers) {\n      return this._canPlacePeers;\n    } // TODO: represent peerPath in ERESOLVE error somehow?\n\n\n    const peerPath = [...this.peerPath, this.dep];\n    let sawConflict = false;\n\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue;\n      }\n\n      const peer = peerEdge.to; // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n\n      const target = deepestNestingTarget(this.target, peer.name);\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true\n      });\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly');\n        }\n      });\n      this.children.push(cpp);\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true;\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state;\n    return this._canPlacePeers;\n  } // what is the node that is causing this peerSet to be placed?\n\n\n  get peerSetSource() {\n    return this.parent ? this.parent.peerSetSource : this.edge.from;\n  }\n\n  get peerEntryEdge() {\n    return this.top.edge;\n  }\n\n  static get CONFLICT() {\n    return CONFLICT;\n  }\n\n  static get OK() {\n    return OK;\n  }\n\n  static get REPLACE() {\n    return REPLACE;\n  }\n\n  static get KEEP() {\n    return KEEP;\n  }\n\n  get description() {\n    const {\n      canPlace\n    } = this;\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */\n    canPlace;\n  }\n\n}\n\nmodule.exports = CanPlaceDep;","map":{"version":3,"names":["localeCompare","require","semver","debug","peerEntrySets","deepestNestingTarget","CONFLICT","Symbol","OK","REPLACE","KEEP","CanPlaceDep","constructor","options","dep","target","edge","preferDedupe","parent","peerPath","explicitRequest","Error","_treeSnapshot","JSON","stringify","root","inventory","entries","map","loc","packageName","version","resolved","sort","a","b","canPlace","canPlaceSelf","peer","children","isSource","peerSetSource","name","current","get","targetEdge","edgesOut","conflicts","Map","edgeOverride","satisfies","checkCanPlace","treeSnapshot","Object","assign","expect","actual","errors","length","isTop","checkCanPlaceCurrent","checkCanPlaceNoCurrent","matches","curVer","newVer","tryReplace","gte","canReplace","cpp","canPlacePeers","myDeepest","from","entryEdge","currentPeers","peerEntryEdge","entryNode","to","entryRep","keys","canClobber","peerReplacementWalk","Set","OUTER","currentPeer","values","valid","rep","add","canNestCurrent","curDeep","isDescendantOf","resolve","edgesIn","start","conflictChildren","allChildren","filter","c","set","child","grandchild","top","state","_canPlacePeers","sawConflict","peerEdge","includes","some","push","description","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/can-place-dep.js"],"sourcesContent":["// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst semver = require('semver')\nconst debug = require('./debug.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\n\nconst CONFLICT = Symbol('CONFLICT')\nconst OK = Symbol('OK')\nconst REPLACE = Symbol('REPLACE')\nconst KEEP = Symbol('KEEP')\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor (options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false,\n    } = options\n\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep')\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep')\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep')\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, { packageName, version, resolved }]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n    })\n\n    // the result of whether we can place it or not\n    this.canPlace = null\n    // if peers conflict, but this one doesn't, then that is useful info\n    this.canPlaceSelf = null\n\n    this.dep = dep\n    this.target = target\n    this.edge = edge\n    this.explicitRequest = explicitRequest\n\n    // preventing cycles when we check peer sets\n    this.peerPath = peerPath\n    // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n    this.preferDedupe = !!preferDedupe || edge.peer\n    this.parent = parent\n    this.children = []\n\n    this.isSource = target === this.peerSetSource\n    this.name = edge.name\n    this.current = target.children.get(this.name)\n    this.targetEdge = target.edgesOut.get(this.name)\n    this.conflicts = new Map()\n\n    // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n    this.edgeOverride = !dep.satisfies(edge)\n\n    this.canPlace = this.checkCanPlace()\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, { packageName, version, resolved }]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n      /* istanbul ignore if */\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot,\n        })\n      }\n    })\n  }\n\n  checkCanPlace () {\n    const { target, targetEdge, current, dep } = this\n\n    // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n    if (dep.errors.length) {\n      return current ? REPLACE : OK\n    }\n\n    // cannot place peers inside their dependents, except for tops\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT\n    }\n\n    // skip this test if there's a current node, because we might be able\n    // to dedupe against it anyway\n    if (!current &&\n        targetEdge &&\n        !dep.satisfies(targetEdge) &&\n        targetEdge !== this.edge) {\n      return CONFLICT\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent()\n  }\n\n  // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n  checkCanPlaceCurrent () {\n    const { preferDedupe, explicitRequest, current, target, edge, dep } = this\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP\n      }\n    }\n\n    const { version: curVer } = current\n    const { version: newVer } = dep\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n    if (tryReplace && dep.canReplace(current)) {\n      // It's extremely rare that a replaceable node would be a conflict, if\n      // the current one wasn't a conflict, but it is theoretically possible\n      // if peer deps are pinned.  In that case we treat it like any other\n      // conflict, and keep trying.\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // ok, can't replace the current with new one, but maybe current is ok?\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP\n    }\n\n    // if we prefer deduping, then try replacing newer with older\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n    const myDeepest = this.deepestNestingTarget\n\n    // ok, i COULD be placed deeper, so leave the current one alone.\n    if (target !== myDeepest) {\n      return CONFLICT\n    }\n\n    // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n    /* istanbul ignore if - allegedly impossible */\n    if (!this.parent && !edge.peer) {\n      return CONFLICT\n    }\n\n    // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n    let canReplace = true\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue\n      }\n\n      // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n      const entryNode = entryEdge.to\n      const entryRep = dep.parent.children.get(entryNode.name)\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue\n        }\n      }\n\n      let canClobber = !entryRep\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode])\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue\n            }\n            const rep = dep.parent.children.get(edge.name)\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to)\n              }\n              continue\n            }\n            if (!rep.satisfies(edge)) {\n              canClobber = false\n              break OUTER\n            }\n          }\n        }\n      }\n      if (canClobber) {\n        continue\n      }\n\n      // ok, we can't replace, but maybe we can nest the current set deeper?\n      let canNestCurrent = true\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break\n        }\n\n        // still possible to nest this peerSet\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name)\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false\n          canReplace = false\n        }\n        if (canNestCurrent) {\n          continue\n        }\n      }\n    }\n\n    // if we can nest or replace all the current peer groups, we can replace.\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    return CONFLICT\n  }\n\n  checkCanPlaceNoCurrent () {\n    const { target, peerEntryEdge, dep, name } = this\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n    const current = target !== peerEntryEdge.from && target.resolve(name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT\n          }\n        }\n      }\n    }\n\n    // no objections, so this is fine as long as peers are ok here.\n    return this.canPlacePeers(OK)\n  }\n\n  get deepestNestingTarget () {\n    const start = this.parent ? this.parent.deepestNestingTarget\n      : this.edge.from\n    return deepestNestingTarget(start, this.name)\n  }\n\n  get conflictChildren () {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  // check if peers can go here.  returns state or CONFLICT\n  canPlacePeers (state) {\n    this.canPlaceSelf = state\n    if (this._canPlacePeers) {\n      return this._canPlacePeers\n    }\n\n    // TODO: represent peerPath in ERESOLVE error somehow?\n    const peerPath = [...this.peerPath, this.dep]\n    let sawConflict = false\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue\n      }\n      const peer = peerEdge.to\n      // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n      const target = deepestNestingTarget(this.target, peer.name)\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true,\n      })\n      /* istanbul ignore next */\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly')\n        }\n      })\n      this.children.push(cpp)\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state\n    return this._canPlacePeers\n  }\n\n  // what is the node that is causing this peerSet to be placed?\n  get peerSetSource () {\n    return this.parent ? this.parent.peerSetSource : this.edge.from\n  }\n\n  get peerEntryEdge () {\n    return this.top.edge\n  }\n\n  static get CONFLICT () {\n    return CONFLICT\n  }\n\n  static get OK () {\n    return OK\n  }\n\n  static get REPLACE () {\n    return REPLACE\n  }\n\n  static get KEEP () {\n    return KEEP\n  }\n\n  get description () {\n    const { canPlace } = this\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */ canPlace\n  }\n}\n\nmodule.exports = CanPlaceDep\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}