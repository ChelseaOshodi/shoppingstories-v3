{"ast":null,"code":"// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst {\n  resolve\n} = require('path');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst consistentResolve = require('../consistent-resolve.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst relpath = require('../relpath.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst rpj = require('read-package-json-fast');\n\nconst treeCheck = require('../tree-check.js');\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap');\nconst resolveNodes = Symbol('resolveNodes');\nconst resolveLinks = Symbol('resolveLinks');\nconst assignBundles = Symbol('assignBundles');\nconst loadRoot = Symbol('loadRoot');\nconst loadNode = Symbol('loadVirtualNode');\nconst loadLink = Symbol('loadVirtualLink');\nconst loadWorkspaces = Symbol.for('loadWorkspaces');\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual');\nconst flagsSuspect = Symbol.for('flagsSuspect');\nconst reCalcDepFlags = Symbol('reCalcDepFlags');\nconst checkRootEdges = Symbol('checkRootEdges');\nconst rootOptionProvided = Symbol('rootOptionProvided');\n\nconst depsToEdges = (type, deps) => Object.entries(deps).map(d => [type, ...d]);\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor(options) {\n    super(options); // the virtual tree we load from a shrinkwrap\n\n    this.virtualTree = options.virtualTree;\n    this[flagsSuspect] = false;\n  } // public method\n\n\n  async loadVirtual() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.virtualTree) {\n      return this.virtualTree;\n    } // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n\n    options = { ...this.options,\n      ...options\n    };\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root);\n      return treeCheck(this.virtualTree);\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options\n    });\n\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file');\n      throw Object.assign(er, {\n        code: 'ENOLOCK'\n      });\n    } // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n\n\n    const {\n      root = await this[loadRoot](s)\n    } = options;\n    this[rootOptionProvided] = options.root;\n    await this[loadFromShrinkwrap](s, root);\n    root.assertRootOverrides();\n    return treeCheck(this.virtualTree);\n  }\n\n  async [loadRoot](s) {\n    const pj = this.path + '/package.json';\n    const pkg = (await rpj(pj).catch(() => s.data.packages[''])) || {};\n    return this[loadWorkspaces](this[loadNode]('', pkg, true));\n  }\n\n  async [loadFromShrinkwrap](s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false;\n      root.dev = false;\n      root.optional = false;\n      root.devOptional = false;\n      root.peer = false;\n    } else {\n      this[flagsSuspect] = true;\n    }\n\n    this[checkRootEdges](s, root);\n    root.meta = s;\n    this.virtualTree = root;\n    const {\n      links,\n      nodes\n    } = this[resolveNodes](s, root);\n    await this[resolveLinks](links, nodes);\n\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes);\n    }\n\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values());\n    }\n\n    return root;\n  }\n\n  [reCalcDepFlags](nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue;\n      }\n\n      node.extraneous = true;\n      node.dev = true;\n      node.optional = true;\n      node.devOptional = true;\n      node.peer = true;\n    }\n\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided]);\n  } // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n\n\n  [checkRootEdges](s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return;\n    }\n\n    const lock = s.get('');\n    const prod = lock.dependencies || {};\n    const dev = lock.devDependencies || {};\n    const optional = lock.optionalDependencies || {};\n    const peer = lock.peerDependencies || {};\n    const peerOptional = {};\n\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name];\n          delete peer[name];\n        }\n      }\n    }\n\n    for (const name of Object.keys(optional)) {\n      delete prod[name];\n    }\n\n    const lockWS = [];\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data\n    });\n\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path.replace(/#/g, '%23')}`]);\n    }\n\n    const lockEdges = [...depsToEdges('prod', prod), ...depsToEdges('dev', dev), ...depsToEdges('optional', optional), ...depsToEdges('peer', peer), ...depsToEdges('peerOptional', peerOptional), ...lockWS].sort((_ref, _ref2) => {\n      let [atype, aname] = _ref;\n      let [btype, bname] = _ref2;\n      return localeCompare(atype, btype) || localeCompare(aname, bname);\n    });\n    const rootEdges = [...root.edgesOut.values()].map(e => [e.type, e.name, e.spec]).sort((_ref3, _ref4) => {\n      let [atype, aname] = _ref3;\n      let [btype, bname] = _ref4;\n      return localeCompare(atype, btype) || localeCompare(aname, bname);\n    });\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true;\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true;\n      }\n    }\n  } // separate out link metadatas, and create Node objects for nodes\n\n\n  [resolveNodes](s, root) {\n    const links = new Map();\n    const nodes = new Map([['', root]]);\n\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue;\n      }\n\n      if (meta.link) {\n        links.set(location, meta);\n      } else {\n        nodes.set(location, this[loadNode](location, meta));\n      }\n    }\n\n    return {\n      links,\n      nodes\n    };\n  } // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n\n\n  async [resolveLinks](links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved);\n      const targetLoc = relpath(this.path, targetPath);\n      const target = nodes.get(targetLoc);\n      const link = this[loadLink](location, targetLoc, target, meta);\n      nodes.set(location, link);\n      nodes.set(targetLoc, link.target); // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json';\n        const pkg = await rpj(pj).catch(() => null);\n\n        if (pkg) {\n          link.target.package = pkg;\n        }\n      }\n    }\n  }\n\n  [assignBundles](nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue;\n      }\n\n      const {\n        name,\n        parent,\n        package: {\n          inBundle\n        }\n      } = node;\n\n      if (!parent) {\n        continue;\n      } // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n\n\n      const {\n        package: ppkg\n      } = parent;\n      const {\n        inBundle: parentBundled\n      } = ppkg;\n\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name];\n        } else {\n          ppkg.bundleDependencies.push(name);\n        }\n      }\n    }\n  }\n\n  [loadNode](location, sw, loadOverrides) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path;\n    const path = resolve(p, location); // shrinkwrap doesn't include package name unless necessary\n\n    if (!sw.name) {\n      sw.name = nameFromFolder(path);\n    }\n\n    const dev = sw.dev;\n    const optional = sw.optional;\n    const devOptional = dev || optional || sw.devOptional;\n    const peer = sw.peer;\n    const node = new Node({\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n      loadOverrides\n    }); // cast to boolean because they're undefined in the lock file when false\n\n    node.extraneous = !!sw.extraneous;\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);\n    node.peer = !!sw.peer;\n    node.optional = !!sw.optional;\n    node.dev = !!sw.dev;\n    return node;\n  }\n\n  [loadLink](location, targetLoc, target, meta) {\n    const path = resolve(this.path, location);\n    const link = new Link({\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package\n    });\n    link.extraneous = target.extraneous;\n    link.devOptional = target.devOptional;\n    link.peer = target.peer;\n    link.optional = target.optional;\n    link.dev = target.dev;\n    return link;\n  }\n\n};","map":{"version":3,"names":["localeCompare","require","resolve","nameFromFolder","consistentResolve","Shrinkwrap","Node","Link","relpath","calcDepFlags","rpj","treeCheck","loadFromShrinkwrap","Symbol","resolveNodes","resolveLinks","assignBundles","loadRoot","loadNode","loadLink","loadWorkspaces","for","loadWorkspacesVirtual","flagsSuspect","reCalcDepFlags","checkRootEdges","rootOptionProvided","depsToEdges","type","deps","Object","entries","map","d","module","exports","cls","VirtualLoader","constructor","options","virtualTree","loadVirtual","root","meta","s","load","path","lockfileVersion","resolveOptions","loadedFromDisk","er","Error","assign","code","assertRootOverrides","pj","pkg","catch","data","packages","extraneous","dev","optional","devOptional","peer","links","nodes","originalLockfileVersion","values","node","isRoot","ancientLockfile","lock","get","prod","dependencies","devDependencies","optionalDependencies","peerDependencies","peerOptional","peerDependenciesMeta","name","undefined","keys","lockWS","workspaces","cwd","lockfile","push","replace","lockEdges","sort","atype","aname","btype","bname","rootEdges","edgesOut","e","spec","length","i","Map","location","link","set","targetPath","resolved","targetLoc","target","parent","realpath","package","isLink","inBundle","ppkg","parentBundled","has","bundleDependencies","sw","loadOverrides","p","installLinks","legacyPeerDeps","integrity","hasShrinkwrap"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"],"sourcesContent":["// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst { resolve } = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options,\n    })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    root.assertRootOverrides()\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg, true))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else {\n      this[flagsSuspect] = true\n    }\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const { links, nodes } = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes)\n    }\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values())\n    }\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue\n      }\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return\n    }\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional)) {\n      delete prod[name]\n    }\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path.replace(/#/g, '%23')}`])\n    }\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true\n      }\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue\n      }\n\n      if (meta.link) {\n        links.set(location, meta)\n      } else {\n        nodes.set(location, this[loadNode](location, meta))\n      }\n    }\n    return { links, nodes }\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg) {\n          link.target.package = pkg\n        }\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue\n      }\n      const { name, parent, package: { inBundle } } = node\n\n      if (!parent) {\n        continue\n      }\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name]\n        } else {\n          ppkg.bundleDependencies.push(name)\n        }\n      }\n    }\n  }\n\n  [loadNode] (location, sw, loadOverrides) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name) {\n      sw.name = nameFromFolder(path)\n    }\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n      loadOverrides,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}