{"ast":null,"code":"'use strict';\n\nconst fs = require('@npmcli/fs');\n\nconst move = require('@npmcli/move-file');\n\nconst pinflight = require('promise-inflight');\n\nmodule.exports = moveFile;\n\nasync function moveFile(src, dest) {\n  const isWindows = process.platform === 'win32'; // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n\n  try {\n    await fs.link(src, dest);\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {// XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {// file already exists, so whatever\n    } else {\n      throw err;\n    }\n  }\n\n  try {\n    await Promise.all([fs.unlink(src), !isWindows && fs.chmod(dest, '0444')]);\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch(err => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err;\n        }\n      }); // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n\n      return move(src, dest);\n    });\n  }\n}","map":{"version":3,"names":["fs","require","move","pinflight","module","exports","moveFile","src","dest","isWindows","process","platform","link","err","code","Promise","all","unlink","chmod","e","stat","catch"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/cacache/lib/util/move-file.js"],"sourcesContent":["'use strict'\n\nconst fs = require('@npmcli/fs')\nconst move = require('@npmcli/move-file')\nconst pinflight = require('promise-inflight')\n\nmodule.exports = moveFile\n\nasync function moveFile (src, dest) {\n  const isWindows = process.platform === 'win32'\n\n  // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n  try {\n    await fs.link(src, dest)\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {\n      // XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n      // file already exists, so whatever\n    } else {\n      throw err\n    }\n  }\n  try {\n    await Promise.all([\n      fs.unlink(src),\n      !isWindows && fs.chmod(dest, '0444'),\n    ])\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch((err) => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err\n        }\n      })\n      // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n      return move(src, dest)\n    })\n  }\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,YAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,mBAAD,CAApB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAD,CAAzB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,eAAeA,QAAf,CAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;EAClC,MAAMC,SAAS,GAAGC,OAAO,CAACC,QAAR,KAAqB,OAAvC,CADkC,CAGlC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,IAAI;IACF,MAAMX,EAAE,CAACY,IAAH,CAAQL,GAAR,EAAaC,IAAb,CAAN;EACD,CAFD,CAEE,OAAOK,GAAP,EAAY;IACZ,IAAIJ,SAAS,IAAII,GAAG,CAACC,IAAJ,KAAa,OAA9B,EAAuC,CACrC;MACA;MACA;MACA;MACA;MACA;MACA;IACD,CARD,MAQO,IAAID,GAAG,CAACC,IAAJ,KAAa,QAAb,IAAyBD,GAAG,CAACC,IAAJ,KAAa,OAA1C,EAAmD,CACxD;IACD,CAFM,MAEA;MACL,MAAMD,GAAN;IACD;EACF;;EACD,IAAI;IACF,MAAME,OAAO,CAACC,GAAR,CAAY,CAChBhB,EAAE,CAACiB,MAAH,CAAUV,GAAV,CADgB,EAEhB,CAACE,SAAD,IAAcT,EAAE,CAACkB,KAAH,CAASV,IAAT,EAAe,MAAf,CAFE,CAAZ,CAAN;EAID,CALD,CAKE,OAAOW,CAAP,EAAU;IACV,OAAOhB,SAAS,CAAC,uBAAuBK,IAAxB,EAA8B,YAAY;MACxD,MAAMR,EAAE,CAACoB,IAAH,CAAQZ,IAAR,EAAca,KAAd,CAAqBR,GAAD,IAAS;QACjC,IAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;UACzB;UACA,MAAMD,GAAN;QACD;MACF,CALK,CAAN,CADwD,CAOxD;MACA;;MACA,OAAOX,IAAI,CAACK,GAAD,EAAMC,IAAN,CAAX;IACD,CAVe,CAAhB;EAWD;AACF"},"metadata":{},"sourceType":"script"}