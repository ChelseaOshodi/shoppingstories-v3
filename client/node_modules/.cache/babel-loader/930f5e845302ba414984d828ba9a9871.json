{"ast":null,"code":"// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  existsSync\n} = require('fs');\n\nconst ssri = require('ssri');\n\nclass Diff {\n  constructor(_ref) {\n    let {\n      actual,\n      ideal,\n      filterSet,\n      shrinkwrapInflated\n    } = _ref;\n    this.filterSet = filterSet;\n    this.shrinkwrapInflated = shrinkwrapInflated;\n    this.children = [];\n    this.actual = actual;\n    this.ideal = ideal;\n\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved;\n      this.integrity = this.ideal.integrity;\n    }\n\n    this.action = getAction(this);\n    this.parent = null; // the set of leaf nodes that we rake up to the top level\n\n    this.leaves = []; // the set of nodes that don't change in this branch of the tree\n\n    this.unchanged = []; // the set of nodes that will be removed in this branch of the tree\n\n    this.removed = [];\n  }\n\n  static calculate(_ref2) {\n    let {\n      actual,\n      ideal,\n      filterNodes = [],\n      shrinkwrapInflated = new Set()\n    } = _ref2;\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set();\n    const extraneous = new Set();\n\n    for (const filterNode of filterNodes) {\n      const {\n        root\n      } = filterNode;\n\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree');\n      }\n\n      const rootTarget = root.target;\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode);\n      })[0];\n      filterSet.add(root);\n      filterSet.add(rootTarget);\n      filterSet.add(ideal);\n      filterSet.add(actual);\n\n      if (edge && edge.to) {\n        filterSet.add(edge.to);\n        filterSet.add(edge.to.target);\n      }\n\n      filterSet.add(filterNode);\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target;\n          const loc = node.location;\n          const idealNode = ideal.inventory.get(loc);\n          const ideals = !idealNode ? [] : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          const actualNode = actual.inventory.get(loc);\n          const actuals = !actualNode ? [] : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child);\n              }\n            }\n          }\n\n          return ideals.concat(actuals);\n        }\n      });\n    }\n\n    for (const extra of extraneous) {\n      filterSet.add(extra);\n    }\n\n    return depth({\n      tree: new Diff({\n        actual,\n        ideal,\n        filterSet,\n        shrinkwrapInflated\n      }),\n      getChildren,\n      leave\n    });\n  }\n\n}\n\nconst getAction = _ref3 => {\n  let {\n    actual,\n    ideal\n  } = _ref3;\n\n  if (!ideal) {\n    return 'REMOVE';\n  } // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n\n\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD';\n  } // always ignore the root node\n\n\n  if (ideal.isRoot && actual.isRoot) {\n    return null;\n  } // if the versions don't match, it's a change no matter what\n\n\n  if (ideal.version !== actual.version) {\n    return 'CHANGE';\n  }\n\n  const binsExist = ideal.binPaths.every(path => existsSync(path)); // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n\n  const noIntegrity = !ideal.integrity && !actual.integrity;\n  const noResolved = !ideal.resolved && !actual.resolved;\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved;\n\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null;\n  } // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n\n\n  const integrityMismatch = !ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity);\n\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE';\n  }\n\n  return null;\n};\n\nconst allChildren = node => {\n  if (!node) {\n    return new Map();\n  } // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n\n\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target);\n  }\n\n  const kids = new Map();\n\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid);\n    }\n  }\n\n  return kids;\n}; // functions for the walk options when we traverse the trees\n// to create the diff tree\n\n\nconst getChildren = diff => {\n  const children = [];\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated\n  } = diff; // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n\n  const actualKids = allChildren(actual);\n  const idealKids = allChildren(ideal);\n\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff);\n    return children;\n  }\n\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()]);\n\n  for (const path of paths) {\n    const actual = actualKids.get(path);\n    const ideal = idealKids.get(path);\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    });\n  }\n\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff);\n  }\n\n  return children;\n};\n\nconst diffNode = _ref4 => {\n  let {\n    actual,\n    ideal,\n    children,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated\n  } = _ref4;\n\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return;\n  }\n\n  const action = getAction({\n    actual,\n    ideal\n  }); // if it's a match, then get its children\n  // otherwise, this is the child diff node\n\n  if (action || !shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap) {\n    if (action === 'REMOVE') {\n      removed.push(actual);\n    }\n\n    children.push(new Diff({\n      actual,\n      ideal,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  } else {\n    unchanged.push(ideal); // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n\n    const bd = ideal.package.bundleDependencies;\n\n    if (actual && bd && bd.length) {\n      const bundledChildren = [];\n\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node);\n        }\n      }\n\n      for (const node of bundledChildren) {\n        node.parent = ideal;\n      }\n    }\n\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  }\n}; // set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\n\n\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff;\n    diff.leaves.push(...kid.leaves);\n    diff.unchanged.push(...kid.unchanged);\n    diff.removed.push(...kid.removed);\n  });\n  diff.children = children;\n  return diff;\n};\n\nmodule.exports = Diff;","map":{"version":3,"names":["depth","require","existsSync","ssri","Diff","constructor","actual","ideal","filterSet","shrinkwrapInflated","children","resolved","integrity","action","getAction","parent","leaves","unchanged","removed","calculate","filterNodes","Set","extraneous","filterNode","root","Error","rootTarget","target","edge","edgesOut","values","filter","e","to","add","tree","visit","node","getChildren","loc","location","idealNode","inventory","get","ideals","map","actualNode","actuals","child","concat","extra","leave","inDepBundle","isRoot","version","binsExist","binPaths","every","path","noIntegrity","noResolved","resolvedMatch","integrityMismatch","parse","match","allChildren","Map","isLink","kids","n","fsChildren","kid","set","diff","actualKids","idealKids","hasShrinkwrap","has","push","paths","keys","diffNode","length","size","bd","package","bundleDependencies","bundledChildren","inBundle","forEach","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/diff.js"],"sourcesContent":["// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\n\nconst { depth } = require('treeverse')\nconst { existsSync } = require('fs')\n\nconst ssri = require('ssri')\n\nclass Diff {\n  constructor ({ actual, ideal, filterSet, shrinkwrapInflated }) {\n    this.filterSet = filterSet\n    this.shrinkwrapInflated = shrinkwrapInflated\n    this.children = []\n    this.actual = actual\n    this.ideal = ideal\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved\n      this.integrity = this.ideal.integrity\n    }\n    this.action = getAction(this)\n    this.parent = null\n    // the set of leaf nodes that we rake up to the top level\n    this.leaves = []\n    // the set of nodes that don't change in this branch of the tree\n    this.unchanged = []\n    // the set of nodes that will be removed in this branch of the tree\n    this.removed = []\n  }\n\n  static calculate ({\n    actual,\n    ideal,\n    filterNodes = [],\n    shrinkwrapInflated = new Set(),\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set()\n    const extraneous = new Set()\n    for (const filterNode of filterNodes) {\n      const { root } = filterNode\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree')\n      }\n      const rootTarget = root.target\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode)\n      })[0]\n      filterSet.add(root)\n      filterSet.add(rootTarget)\n      filterSet.add(ideal)\n      filterSet.add(actual)\n      if (edge && edge.to) {\n        filterSet.add(edge.to)\n        filterSet.add(edge.to.target)\n      }\n      filterSet.add(filterNode)\n\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target\n          const loc = node.location\n          const idealNode = ideal.inventory.get(loc)\n          const ideals = !idealNode ? []\n            : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          const actualNode = actual.inventory.get(loc)\n          const actuals = !actualNode ? []\n            : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child)\n              }\n            }\n          }\n\n          return ideals.concat(actuals)\n        },\n      })\n    }\n    for (const extra of extraneous) {\n      filterSet.add(extra)\n    }\n\n    return depth({\n      tree: new Diff({ actual, ideal, filterSet, shrinkwrapInflated }),\n      getChildren,\n      leave,\n    })\n  }\n}\n\nconst getAction = ({ actual, ideal }) => {\n  if (!ideal) {\n    return 'REMOVE'\n  }\n\n  // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD'\n  }\n\n  // always ignore the root node\n  if (ideal.isRoot && actual.isRoot) {\n    return null\n  }\n\n  // if the versions don't match, it's a change no matter what\n  if (ideal.version !== actual.version) {\n    return 'CHANGE'\n  }\n\n  const binsExist = ideal.binPaths.every((path) => existsSync(path))\n\n  // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n  const noIntegrity = !ideal.integrity && !actual.integrity\n  const noResolved = !ideal.resolved && !actual.resolved\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null\n  }\n\n  // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n  const integrityMismatch = !ideal.integrity || !actual.integrity ||\n    !ssri.parse(ideal.integrity).match(actual.integrity)\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE'\n  }\n\n  return null\n}\n\nconst allChildren = node => {\n  if (!node) {\n    return new Map()\n  }\n\n  // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target)\n  }\n\n  const kids = new Map()\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid)\n    }\n  }\n  return kids\n}\n\n// functions for the walk options when we traverse the trees\n// to create the diff tree\nconst getChildren = diff => {\n  const children = []\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated,\n  } = diff\n\n  // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n  const actualKids = allChildren(actual)\n  const idealKids = allChildren(ideal)\n\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff)\n    return children\n  }\n\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()])\n  for (const path of paths) {\n    const actual = actualKids.get(path)\n    const ideal = idealKids.get(path)\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    })\n  }\n\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff)\n  }\n\n  return children\n}\n\nconst diffNode = ({\n  actual,\n  ideal,\n  children,\n  unchanged,\n  removed,\n  filterSet,\n  shrinkwrapInflated,\n}) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return\n  }\n\n  const action = getAction({ actual, ideal })\n\n  // if it's a match, then get its children\n  // otherwise, this is the child diff node\n  if (action || (!shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap)) {\n    if (action === 'REMOVE') {\n      removed.push(actual)\n    }\n    children.push(new Diff({ actual, ideal, filterSet, shrinkwrapInflated }))\n  } else {\n    unchanged.push(ideal)\n    // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n    const bd = ideal.package.bundleDependencies\n    if (actual && bd && bd.length) {\n      const bundledChildren = []\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node)\n        }\n      }\n      for (const node of bundledChildren) {\n        node.parent = ideal\n      }\n    }\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    }))\n  }\n}\n\n// set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff\n    diff.leaves.push(...kid.leaves)\n    diff.unchanged.push(...kid.unchanged)\n    diff.removed.push(...kid.removed)\n  })\n  diff.children = children\n  return diff\n}\n\nmodule.exports = Diff\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}