{"ast":null,"code":"// The arborist manages three trees:\n// - actual\n// - virtual\n// - ideal\n//\n// The actual tree is what's present on disk in the node_modules tree\n// and elsewhere that links may extend.\n//\n// The virtual tree is loaded from metadata (package.json and lock files).\n//\n// The ideal tree is what we WANT that actual tree to become.  This starts\n// with the virtual tree, and then applies the options requesting\n// add/remove/update actions.\n//\n// To reify a tree, we calculate a diff between the ideal and actual trees,\n// and then turn the actual tree into the ideal tree by taking the actions\n// required.  At the end of the reification process, the actualTree is\n// updated to reflect the changes.\n//\n// Each tree has an Inventory at the root.  Shrinkwrap is tracked by Arborist\n// instance.  It always refers to the actual tree, but is updated (and written\n// to disk) on reification.\n// Each of the mixin \"classes\" adds functionality, but are not dependent on\n// constructor call order.  So, we just load them in an array, and build up\n// the base class, so that the overall voltron class is easier to test and\n// cover, and separation of concerns can be maintained.\nconst {\n  resolve\n} = require('path');\n\nconst {\n  homedir\n} = require('os');\n\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  saveTypeMap\n} = require('../add-rm-pkg-deps.js');\n\nconst mixins = [require('../tracker.js'), require('./pruner.js'), require('./deduper.js'), require('./audit.js'), require('./build-ideal-tree.js'), require('./load-workspaces.js'), require('./load-actual.js'), require('./load-virtual.js'), require('./rebuild.js'), require('./reify.js')];\n\nconst _workspacesEnabled = Symbol.for('workspacesEnabled');\n\nconst Base = mixins.reduce((a, b) => b(a), require('events'));\n\nconst getWorkspaceNodes = require('../get-workspace-nodes.js'); // if it's 1, 2, or 3, set it explicitly that.\n// if undefined or null, set it null\n// otherwise, throw.\n\n\nconst lockfileVersion = lfv => {\n  if (lfv === 1 || lfv === 2 || lfv === 3) {\n    return lfv;\n  }\n\n  if (lfv === undefined || lfv === null) {\n    return null;\n  }\n\n  throw new TypeError('Invalid lockfileVersion config: ' + lfv);\n};\n\nclass Arborist extends Base {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    process.emit('time', 'arborist:ctor');\n    super(options);\n    this.options = {\n      nodeVersion: process.version,\n      ...options,\n      path: options.path || '.',\n      cache: options.cache || `${homedir()}/.npm/_cacache`,\n      packumentCache: options.packumentCache || new Map(),\n      workspacesEnabled: options.workspacesEnabled !== false,\n      replaceRegistryHost: options.replaceRegistryHost,\n      lockfileVersion: lockfileVersion(options.lockfileVersion)\n    };\n    this.replaceRegistryHost = this.options.replaceRegistryHost = !this.options.replaceRegistryHost || this.options.replaceRegistryHost === 'npmjs' ? 'registry.npmjs.org' : this.options.replaceRegistryHost;\n    this[_workspacesEnabled] = this.options.workspacesEnabled;\n\n    if (options.saveType && !saveTypeMap.get(options.saveType)) {\n      throw new Error(`Invalid saveType ${options.saveType}`);\n    }\n\n    this.cache = resolve(this.options.cache);\n    this.path = resolve(this.options.path);\n    process.emit('timeEnd', 'arborist:ctor');\n  } // TODO: We should change these to static functions instead\n  //   of methods for the next major version\n  // returns an array of the actual nodes for all the workspaces\n\n\n  workspaceNodes(tree, workspaces) {\n    return getWorkspaceNodes(tree, workspaces);\n  } // returns a set of workspace nodes and all their deps\n\n\n  workspaceDependencySet(tree, workspaces, includeWorkspaceRoot) {\n    const wsNodes = this.workspaceNodes(tree, workspaces);\n\n    if (includeWorkspaceRoot) {\n      for (const edge of tree.edgesOut.values()) {\n        if (edge.type !== 'workspace' && edge.to) {\n          wsNodes.push(edge.to);\n        }\n      }\n    }\n\n    const wsDepSet = new Set(wsNodes);\n    const extraneous = new Set();\n\n    for (const node of wsDepSet) {\n      for (const edge of node.edgesOut.values()) {\n        const dep = edge.to;\n\n        if (dep) {\n          wsDepSet.add(dep);\n\n          if (dep.isLink) {\n            wsDepSet.add(dep.target);\n          }\n        }\n      }\n\n      for (const child of node.children.values()) {\n        if (child.extraneous) {\n          extraneous.add(child);\n        }\n      }\n    }\n\n    for (const extra of extraneous) {\n      wsDepSet.add(extra);\n    }\n\n    return wsDepSet;\n  } // returns a set of root dependencies, excluding depdencies that are\n  // exclusively workspace dependencies\n\n\n  excludeWorkspacesDependencySet(tree) {\n    const rootDepSet = new Set();\n    depth({\n      tree,\n      visit: node => {\n        for (const {\n          to\n        } of node.edgesOut.values()) {\n          if (!to || to.isWorkspace) {\n            continue;\n          }\n\n          for (const edgeIn of to.edgesIn.values()) {\n            if (edgeIn.from.isRoot || rootDepSet.has(edgeIn.from)) {\n              rootDepSet.add(to);\n            }\n          }\n        }\n\n        return node;\n      },\n      filter: node => node,\n      getChildren: (node, tree) => [...tree.edgesOut.values()].map(edge => edge.to)\n    });\n    return rootDepSet;\n  }\n\n}\n\nmodule.exports = Arborist;","map":{"version":3,"names":["resolve","require","homedir","depth","saveTypeMap","mixins","_workspacesEnabled","Symbol","for","Base","reduce","a","b","getWorkspaceNodes","lockfileVersion","lfv","undefined","TypeError","Arborist","constructor","options","process","emit","nodeVersion","version","path","cache","packumentCache","Map","workspacesEnabled","replaceRegistryHost","saveType","get","Error","workspaceNodes","tree","workspaces","workspaceDependencySet","includeWorkspaceRoot","wsNodes","edge","edgesOut","values","type","to","push","wsDepSet","Set","extraneous","node","dep","add","isLink","target","child","children","extra","excludeWorkspacesDependencySet","rootDepSet","visit","isWorkspace","edgeIn","edgesIn","from","isRoot","has","filter","getChildren","map","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/index.js"],"sourcesContent":["// The arborist manages three trees:\n// - actual\n// - virtual\n// - ideal\n//\n// The actual tree is what's present on disk in the node_modules tree\n// and elsewhere that links may extend.\n//\n// The virtual tree is loaded from metadata (package.json and lock files).\n//\n// The ideal tree is what we WANT that actual tree to become.  This starts\n// with the virtual tree, and then applies the options requesting\n// add/remove/update actions.\n//\n// To reify a tree, we calculate a diff between the ideal and actual trees,\n// and then turn the actual tree into the ideal tree by taking the actions\n// required.  At the end of the reification process, the actualTree is\n// updated to reflect the changes.\n//\n// Each tree has an Inventory at the root.  Shrinkwrap is tracked by Arborist\n// instance.  It always refers to the actual tree, but is updated (and written\n// to disk) on reification.\n\n// Each of the mixin \"classes\" adds functionality, but are not dependent on\n// constructor call order.  So, we just load them in an array, and build up\n// the base class, so that the overall voltron class is easier to test and\n// cover, and separation of concerns can be maintained.\n\nconst { resolve } = require('path')\nconst { homedir } = require('os')\nconst { depth } = require('treeverse')\nconst { saveTypeMap } = require('../add-rm-pkg-deps.js')\n\nconst mixins = [\n  require('../tracker.js'),\n  require('./pruner.js'),\n  require('./deduper.js'),\n  require('./audit.js'),\n  require('./build-ideal-tree.js'),\n  require('./load-workspaces.js'),\n  require('./load-actual.js'),\n  require('./load-virtual.js'),\n  require('./rebuild.js'),\n  require('./reify.js'),\n]\n\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\nconst Base = mixins.reduce((a, b) => b(a), require('events'))\nconst getWorkspaceNodes = require('../get-workspace-nodes.js')\n\n// if it's 1, 2, or 3, set it explicitly that.\n// if undefined or null, set it null\n// otherwise, throw.\nconst lockfileVersion = lfv => {\n  if (lfv === 1 || lfv === 2 || lfv === 3) {\n    return lfv\n  }\n\n  if (lfv === undefined || lfv === null) {\n    return null\n  }\n\n  throw new TypeError('Invalid lockfileVersion config: ' + lfv)\n}\n\nclass Arborist extends Base {\n  constructor (options = {}) {\n    process.emit('time', 'arborist:ctor')\n    super(options)\n    this.options = {\n      nodeVersion: process.version,\n      ...options,\n      path: options.path || '.',\n      cache: options.cache || `${homedir()}/.npm/_cacache`,\n      packumentCache: options.packumentCache || new Map(),\n      workspacesEnabled: options.workspacesEnabled !== false,\n      replaceRegistryHost: options.replaceRegistryHost,\n      lockfileVersion: lockfileVersion(options.lockfileVersion),\n    }\n    this.replaceRegistryHost = this.options.replaceRegistryHost =\n      (!this.options.replaceRegistryHost || this.options.replaceRegistryHost === 'npmjs') ?\n        'registry.npmjs.org' : this.options.replaceRegistryHost\n\n    this[_workspacesEnabled] = this.options.workspacesEnabled\n\n    if (options.saveType && !saveTypeMap.get(options.saveType)) {\n      throw new Error(`Invalid saveType ${options.saveType}`)\n    }\n    this.cache = resolve(this.options.cache)\n    this.path = resolve(this.options.path)\n    process.emit('timeEnd', 'arborist:ctor')\n  }\n\n  // TODO: We should change these to static functions instead\n  //   of methods for the next major version\n\n  // returns an array of the actual nodes for all the workspaces\n  workspaceNodes (tree, workspaces) {\n    return getWorkspaceNodes(tree, workspaces)\n  }\n\n  // returns a set of workspace nodes and all their deps\n  workspaceDependencySet (tree, workspaces, includeWorkspaceRoot) {\n    const wsNodes = this.workspaceNodes(tree, workspaces)\n    if (includeWorkspaceRoot) {\n      for (const edge of tree.edgesOut.values()) {\n        if (edge.type !== 'workspace' && edge.to) {\n          wsNodes.push(edge.to)\n        }\n      }\n    }\n    const wsDepSet = new Set(wsNodes)\n    const extraneous = new Set()\n    for (const node of wsDepSet) {\n      for (const edge of node.edgesOut.values()) {\n        const dep = edge.to\n        if (dep) {\n          wsDepSet.add(dep)\n          if (dep.isLink) {\n            wsDepSet.add(dep.target)\n          }\n        }\n      }\n      for (const child of node.children.values()) {\n        if (child.extraneous) {\n          extraneous.add(child)\n        }\n      }\n    }\n    for (const extra of extraneous) {\n      wsDepSet.add(extra)\n    }\n\n    return wsDepSet\n  }\n\n  // returns a set of root dependencies, excluding depdencies that are\n  // exclusively workspace dependencies\n  excludeWorkspacesDependencySet (tree) {\n    const rootDepSet = new Set()\n    depth({\n      tree,\n      visit: node => {\n        for (const { to } of node.edgesOut.values()) {\n          if (!to || to.isWorkspace) {\n            continue\n          }\n          for (const edgeIn of to.edgesIn.values()) {\n            if (edgeIn.from.isRoot || rootDepSet.has(edgeIn.from)) {\n              rootDepSet.add(to)\n            }\n          }\n        }\n        return node\n      },\n      filter: node => node,\n      getChildren: (node, tree) =>\n        [...tree.edgesOut.values()].map(edge => edge.to),\n    })\n    return rootDepSet\n  }\n}\n\nmodule.exports = Arborist\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA,MAAM;EAAEA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AACA,MAAM;EAAEC;AAAF,IAAcD,OAAO,CAAC,IAAD,CAA3B;;AACA,MAAM;EAAEE;AAAF,IAAYF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAM;EAAEG;AAAF,IAAkBH,OAAO,CAAC,uBAAD,CAA/B;;AAEA,MAAMI,MAAM,GAAG,CACbJ,OAAO,CAAC,eAAD,CADM,EAEbA,OAAO,CAAC,aAAD,CAFM,EAGbA,OAAO,CAAC,cAAD,CAHM,EAIbA,OAAO,CAAC,YAAD,CAJM,EAKbA,OAAO,CAAC,uBAAD,CALM,EAMbA,OAAO,CAAC,sBAAD,CANM,EAObA,OAAO,CAAC,kBAAD,CAPM,EAQbA,OAAO,CAAC,mBAAD,CARM,EASbA,OAAO,CAAC,cAAD,CATM,EAUbA,OAAO,CAAC,YAAD,CAVM,CAAf;;AAaA,MAAMK,kBAAkB,GAAGC,MAAM,CAACC,GAAP,CAAW,mBAAX,CAA3B;;AACA,MAAMC,IAAI,GAAGJ,MAAM,CAACK,MAAP,CAAc,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACD,CAAD,CAAzB,EAA8BV,OAAO,CAAC,QAAD,CAArC,CAAb;;AACA,MAAMY,iBAAiB,GAAGZ,OAAO,CAAC,2BAAD,CAAjC,C,CAEA;AACA;AACA;;;AACA,MAAMa,eAAe,GAAGC,GAAG,IAAI;EAC7B,IAAIA,GAAG,KAAK,CAAR,IAAaA,GAAG,KAAK,CAArB,IAA0BA,GAAG,KAAK,CAAtC,EAAyC;IACvC,OAAOA,GAAP;EACD;;EAED,IAAIA,GAAG,KAAKC,SAAR,IAAqBD,GAAG,KAAK,IAAjC,EAAuC;IACrC,OAAO,IAAP;EACD;;EAED,MAAM,IAAIE,SAAJ,CAAc,qCAAqCF,GAAnD,CAAN;AACD,CAVD;;AAYA,MAAMG,QAAN,SAAuBT,IAAvB,CAA4B;EAC1BU,WAAW,GAAgB;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IACzBC,OAAO,CAACC,IAAR,CAAa,MAAb,EAAqB,eAArB;IACA,MAAMF,OAAN;IACA,KAAKA,OAAL,GAAe;MACbG,WAAW,EAAEF,OAAO,CAACG,OADR;MAEb,GAAGJ,OAFU;MAGbK,IAAI,EAAEL,OAAO,CAACK,IAAR,IAAgB,GAHT;MAIbC,KAAK,EAAEN,OAAO,CAACM,KAAR,IAAkB,GAAExB,OAAO,EAAG,gBAJxB;MAKbyB,cAAc,EAAEP,OAAO,CAACO,cAAR,IAA0B,IAAIC,GAAJ,EAL7B;MAMbC,iBAAiB,EAAET,OAAO,CAACS,iBAAR,KAA8B,KANpC;MAObC,mBAAmB,EAAEV,OAAO,CAACU,mBAPhB;MAQbhB,eAAe,EAAEA,eAAe,CAACM,OAAO,CAACN,eAAT;IARnB,CAAf;IAUA,KAAKgB,mBAAL,GAA2B,KAAKV,OAAL,CAAaU,mBAAb,GACxB,CAAC,KAAKV,OAAL,CAAaU,mBAAd,IAAqC,KAAKV,OAAL,CAAaU,mBAAb,KAAqC,OAA3E,GACE,oBADF,GACyB,KAAKV,OAAL,CAAaU,mBAFxC;IAIA,KAAKxB,kBAAL,IAA2B,KAAKc,OAAL,CAAaS,iBAAxC;;IAEA,IAAIT,OAAO,CAACW,QAAR,IAAoB,CAAC3B,WAAW,CAAC4B,GAAZ,CAAgBZ,OAAO,CAACW,QAAxB,CAAzB,EAA4D;MAC1D,MAAM,IAAIE,KAAJ,CAAW,oBAAmBb,OAAO,CAACW,QAAS,EAA/C,CAAN;IACD;;IACD,KAAKL,KAAL,GAAa1B,OAAO,CAAC,KAAKoB,OAAL,CAAaM,KAAd,CAApB;IACA,KAAKD,IAAL,GAAYzB,OAAO,CAAC,KAAKoB,OAAL,CAAaK,IAAd,CAAnB;IACAJ,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB,eAAxB;EACD,CA1ByB,CA4B1B;EACA;EAEA;;;EACAY,cAAc,CAAEC,IAAF,EAAQC,UAAR,EAAoB;IAChC,OAAOvB,iBAAiB,CAACsB,IAAD,EAAOC,UAAP,CAAxB;EACD,CAlCyB,CAoC1B;;;EACAC,sBAAsB,CAAEF,IAAF,EAAQC,UAAR,EAAoBE,oBAApB,EAA0C;IAC9D,MAAMC,OAAO,GAAG,KAAKL,cAAL,CAAoBC,IAApB,EAA0BC,UAA1B,CAAhB;;IACA,IAAIE,oBAAJ,EAA0B;MACxB,KAAK,MAAME,IAAX,IAAmBL,IAAI,CAACM,QAAL,CAAcC,MAAd,EAAnB,EAA2C;QACzC,IAAIF,IAAI,CAACG,IAAL,KAAc,WAAd,IAA6BH,IAAI,CAACI,EAAtC,EAA0C;UACxCL,OAAO,CAACM,IAAR,CAAaL,IAAI,CAACI,EAAlB;QACD;MACF;IACF;;IACD,MAAME,QAAQ,GAAG,IAAIC,GAAJ,CAAQR,OAAR,CAAjB;IACA,MAAMS,UAAU,GAAG,IAAID,GAAJ,EAAnB;;IACA,KAAK,MAAME,IAAX,IAAmBH,QAAnB,EAA6B;MAC3B,KAAK,MAAMN,IAAX,IAAmBS,IAAI,CAACR,QAAL,CAAcC,MAAd,EAAnB,EAA2C;QACzC,MAAMQ,GAAG,GAAGV,IAAI,CAACI,EAAjB;;QACA,IAAIM,GAAJ,EAAS;UACPJ,QAAQ,CAACK,GAAT,CAAaD,GAAb;;UACA,IAAIA,GAAG,CAACE,MAAR,EAAgB;YACdN,QAAQ,CAACK,GAAT,CAAaD,GAAG,CAACG,MAAjB;UACD;QACF;MACF;;MACD,KAAK,MAAMC,KAAX,IAAoBL,IAAI,CAACM,QAAL,CAAcb,MAAd,EAApB,EAA4C;QAC1C,IAAIY,KAAK,CAACN,UAAV,EAAsB;UACpBA,UAAU,CAACG,GAAX,CAAeG,KAAf;QACD;MACF;IACF;;IACD,KAAK,MAAME,KAAX,IAAoBR,UAApB,EAAgC;MAC9BF,QAAQ,CAACK,GAAT,CAAaK,KAAb;IACD;;IAED,OAAOV,QAAP;EACD,CArEyB,CAuE1B;EACA;;;EACAW,8BAA8B,CAAEtB,IAAF,EAAQ;IACpC,MAAMuB,UAAU,GAAG,IAAIX,GAAJ,EAAnB;IACA5C,KAAK,CAAC;MACJgC,IADI;MAEJwB,KAAK,EAAEV,IAAI,IAAI;QACb,KAAK,MAAM;UAAEL;QAAF,CAAX,IAAqBK,IAAI,CAACR,QAAL,CAAcC,MAAd,EAArB,EAA6C;UAC3C,IAAI,CAACE,EAAD,IAAOA,EAAE,CAACgB,WAAd,EAA2B;YACzB;UACD;;UACD,KAAK,MAAMC,MAAX,IAAqBjB,EAAE,CAACkB,OAAH,CAAWpB,MAAX,EAArB,EAA0C;YACxC,IAAImB,MAAM,CAACE,IAAP,CAAYC,MAAZ,IAAsBN,UAAU,CAACO,GAAX,CAAeJ,MAAM,CAACE,IAAtB,CAA1B,EAAuD;cACrDL,UAAU,CAACP,GAAX,CAAeP,EAAf;YACD;UACF;QACF;;QACD,OAAOK,IAAP;MACD,CAdG;MAeJiB,MAAM,EAAEjB,IAAI,IAAIA,IAfZ;MAgBJkB,WAAW,EAAE,CAAClB,IAAD,EAAOd,IAAP,KACX,CAAC,GAAGA,IAAI,CAACM,QAAL,CAAcC,MAAd,EAAJ,EAA4B0B,GAA5B,CAAgC5B,IAAI,IAAIA,IAAI,CAACI,EAA7C;IAjBE,CAAD,CAAL;IAmBA,OAAOc,UAAP;EACD;;AA/FyB;;AAkG5BW,MAAM,CAACC,OAAP,GAAiBpD,QAAjB"},"metadata":{},"sourceType":"script"}