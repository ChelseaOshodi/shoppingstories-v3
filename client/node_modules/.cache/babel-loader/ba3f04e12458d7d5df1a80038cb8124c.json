{"ast":null,"code":"// An edge in the dependency graph\n// Represents a dependency relationship of some kind\nconst util = require('util');\n\nconst npa = require('npm-package-arg');\n\nconst depValid = require('./dep-valid.js');\n\nconst _from = Symbol('_from');\n\nconst _to = Symbol('_to');\n\nconst _type = Symbol('_type');\n\nconst _spec = Symbol('_spec');\n\nconst _accept = Symbol('_accept');\n\nconst _name = Symbol('_name');\n\nconst _error = Symbol('_error');\n\nconst _loadError = Symbol('_loadError');\n\nconst _setFrom = Symbol('_setFrom');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst types = new Set(['prod', 'dev', 'optional', 'peer', 'peerOptional', 'workspace']);\n\nclass ArboristEdge {}\n\nconst printableEdge = edge => {\n  const edgeFrom = edge.from && edge.from.location;\n  const edgeTo = edge.to && edge.to.location;\n  const override = edge.overrides && edge.overrides.value;\n  return Object.assign(new ArboristEdge(), {\n    name: edge.name,\n    spec: edge.spec,\n    type: edge.type,\n    ...(edgeFrom != null ? {\n      from: edgeFrom\n    } : {}),\n    ...(edgeTo ? {\n      to: edgeTo\n    } : {}),\n    ...(edge.error ? {\n      error: edge.error\n    } : {}),\n    ...(edge.peerConflicted ? {\n      peerConflicted: true\n    } : {}),\n    ...(override ? {\n      overridden: override\n    } : {})\n  });\n};\n\nclass Edge {\n  constructor(options) {\n    const {\n      type,\n      name,\n      spec,\n      accept,\n      from,\n      overrides\n    } = options;\n\n    if (typeof spec !== 'string') {\n      throw new TypeError('must provide string spec');\n    }\n\n    if (type === 'workspace' && npa(spec).type !== 'directory') {\n      throw new TypeError('workspace edges must be a symlink');\n    }\n\n    this[_spec] = spec;\n\n    if (overrides !== undefined) {\n      this.overrides = overrides;\n    }\n\n    if (accept !== undefined) {\n      if (typeof accept !== 'string') {\n        throw new TypeError('accept field must be a string if provided');\n      }\n\n      this[_accept] = accept || '*';\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('must provide dependency name');\n    }\n\n    this[_name] = name;\n\n    if (!types.has(type)) {\n      throw new TypeError(`invalid type: ${type}\\n` + `(valid types are: ${Edge.types.join(', ')})`);\n    }\n\n    this[_type] = type;\n\n    if (!from) {\n      throw new TypeError('must provide \"from\" node');\n    }\n\n    this[_setFrom](from);\n\n    this[_error] = this[_loadError]();\n    this.peerConflicted = false;\n  }\n\n  satisfiedBy(node) {\n    if (node.name !== this.name) {\n      return false;\n    } // NOTE: this condition means we explicitly do not support overriding\n    // bundled or shrinkwrapped dependencies\n\n\n    const spec = node.hasShrinkwrap || node.inShrinkwrap || node.inBundle ? this.rawSpec : this.spec;\n    return depValid(node, spec, this.accept, this.from);\n  }\n\n  explain() {\n    let seen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (this[_explanation]) {\n      return this[_explanation];\n    }\n\n    return this[_explanation] = this[_explain](seen);\n  } // return the edge data, and an explanation of how that edge came to be here\n\n\n  [_explain](seen) {\n    const {\n      error,\n      from,\n      bundled\n    } = this;\n    return {\n      type: this.type,\n      name: this.name,\n      spec: this.spec,\n      ...(this.rawSpec !== this.spec ? {\n        rawSpec: this.rawSpec,\n        overridden: true\n      } : {}),\n      ...(bundled ? {\n        bundled\n      } : {}),\n      ...(error ? {\n        error\n      } : {}),\n      ...(from ? {\n        from: from.explain(null, seen)\n      } : {})\n    };\n  }\n\n  get bundled() {\n    if (!this.from) {\n      return false;\n    }\n\n    const {\n      package: {\n        bundleDependencies = []\n      }\n    } = this.from;\n    return bundleDependencies.includes(this.name);\n  }\n\n  get workspace() {\n    return this[_type] === 'workspace';\n  }\n\n  get prod() {\n    return this[_type] === 'prod';\n  }\n\n  get dev() {\n    return this[_type] === 'dev';\n  }\n\n  get optional() {\n    return this[_type] === 'optional' || this[_type] === 'peerOptional';\n  }\n\n  get peer() {\n    return this[_type] === 'peer' || this[_type] === 'peerOptional';\n  }\n\n  get type() {\n    return this[_type];\n  }\n\n  get name() {\n    return this[_name];\n  }\n\n  get rawSpec() {\n    return this[_spec];\n  }\n\n  get spec() {\n    if (this.overrides && this.overrides.value && this.overrides.name === this.name) {\n      if (this.overrides.value.startsWith('$')) {\n        const ref = this.overrides.value.slice(1); // we may be a virtual root, if we are we want to resolve reference overrides\n        // from the real root, not the virtual one\n\n        const pkg = this.from.sourceReference ? this.from.sourceReference.root.package : this.from.root.package;\n        const overrideSpec = pkg.devDependencies && pkg.devDependencies[ref] || pkg.optionalDependencies && pkg.optionalDependencies[ref] || pkg.dependencies && pkg.dependencies[ref] || pkg.peerDependencies && pkg.peerDependencies[ref];\n\n        if (overrideSpec) {\n          return overrideSpec;\n        }\n\n        throw new Error(`Unable to resolve reference ${this.overrides.value}`);\n      }\n\n      return this.overrides.value;\n    }\n\n    return this[_spec];\n  }\n\n  get accept() {\n    return this[_accept];\n  }\n\n  get valid() {\n    return !this.error;\n  }\n\n  get missing() {\n    return this.error === 'MISSING';\n  }\n\n  get invalid() {\n    return this.error === 'INVALID';\n  }\n\n  get peerLocal() {\n    return this.error === 'PEER LOCAL';\n  }\n\n  get error() {\n    this[_error] = this[_error] || this[_loadError]();\n    return this[_error] === 'OK' ? null : this[_error];\n  }\n\n  [_loadError]() {\n    return !this[_to] ? this.optional ? null : 'MISSING' : this.peer && this.from === this.to.parent && !this.from.isTop ? 'PEER LOCAL' : !this.satisfiedBy(this.to) ? 'INVALID' : 'OK';\n  }\n\n  reload() {\n    let hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this[_explanation] = null;\n\n    if (this[_from].overrides) {\n      this.overrides = this[_from].overrides.getEdgeRule(this);\n    } else {\n      delete this.overrides;\n    }\n\n    const newTo = this[_from].resolve(this.name);\n\n    if (newTo !== this[_to]) {\n      if (this[_to]) {\n        this[_to].edgesIn.delete(this);\n      }\n\n      this[_to] = newTo;\n      this[_error] = this[_loadError]();\n\n      if (this[_to]) {\n        this[_to].addEdgeIn(this);\n      }\n    } else if (hard) {\n      this[_error] = this[_loadError]();\n    }\n  }\n\n  detach() {\n    this[_explanation] = null;\n\n    if (this[_to]) {\n      this[_to].edgesIn.delete(this);\n    }\n\n    this[_from].edgesOut.delete(this.name);\n\n    this[_to] = null;\n    this[_error] = 'DETACHED';\n    this[_from] = null;\n  }\n\n  [_setFrom](node) {\n    this[_explanation] = null;\n    this[_from] = node;\n\n    if (node.edgesOut.has(this.name)) {\n      node.edgesOut.get(this.name).detach();\n    }\n\n    node.addEdgeOut(this);\n    this.reload();\n  }\n\n  get from() {\n    return this[_from];\n  }\n\n  get to() {\n    return this[_to];\n  }\n\n  toJSON() {\n    return printableEdge(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nEdge.types = [...types];\nEdge.errors = ['DETACHED', 'MISSING', 'PEER LOCAL', 'INVALID'];\nmodule.exports = Edge;","map":{"version":3,"names":["util","require","npa","depValid","_from","Symbol","_to","_type","_spec","_accept","_name","_error","_loadError","_setFrom","_explain","_explanation","types","Set","ArboristEdge","printableEdge","edge","edgeFrom","from","location","edgeTo","to","override","overrides","value","Object","assign","name","spec","type","error","peerConflicted","overridden","Edge","constructor","options","accept","TypeError","undefined","has","join","satisfiedBy","node","hasShrinkwrap","inShrinkwrap","inBundle","rawSpec","explain","seen","bundled","package","bundleDependencies","includes","workspace","prod","dev","optional","peer","startsWith","ref","slice","pkg","sourceReference","root","overrideSpec","devDependencies","optionalDependencies","dependencies","peerDependencies","Error","valid","missing","invalid","peerLocal","parent","isTop","reload","hard","getEdgeRule","newTo","resolve","edgesIn","delete","addEdgeIn","detach","edgesOut","get","addEdgeOut","toJSON","inspect","custom","errors","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/edge.js"],"sourcesContent":["// An edge in the dependency graph\n// Represents a dependency relationship of some kind\n\nconst util = require('util')\nconst npa = require('npm-package-arg')\nconst depValid = require('./dep-valid.js')\nconst _from = Symbol('_from')\nconst _to = Symbol('_to')\nconst _type = Symbol('_type')\nconst _spec = Symbol('_spec')\nconst _accept = Symbol('_accept')\nconst _name = Symbol('_name')\nconst _error = Symbol('_error')\nconst _loadError = Symbol('_loadError')\nconst _setFrom = Symbol('_setFrom')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\n\nconst types = new Set([\n  'prod',\n  'dev',\n  'optional',\n  'peer',\n  'peerOptional',\n  'workspace',\n])\n\nclass ArboristEdge {}\nconst printableEdge = (edge) => {\n  const edgeFrom = edge.from && edge.from.location\n  const edgeTo = edge.to && edge.to.location\n  const override = edge.overrides && edge.overrides.value\n\n  return Object.assign(new ArboristEdge(), {\n    name: edge.name,\n    spec: edge.spec,\n    type: edge.type,\n    ...(edgeFrom != null ? { from: edgeFrom } : {}),\n    ...(edgeTo ? { to: edgeTo } : {}),\n    ...(edge.error ? { error: edge.error } : {}),\n    ...(edge.peerConflicted ? { peerConflicted: true } : {}),\n    ...(override ? { overridden: override } : {}),\n  })\n}\n\nclass Edge {\n  constructor (options) {\n    const { type, name, spec, accept, from, overrides } = options\n\n    if (typeof spec !== 'string') {\n      throw new TypeError('must provide string spec')\n    }\n\n    if (type === 'workspace' && npa(spec).type !== 'directory') {\n      throw new TypeError('workspace edges must be a symlink')\n    }\n\n    this[_spec] = spec\n\n    if (overrides !== undefined) {\n      this.overrides = overrides\n    }\n\n    if (accept !== undefined) {\n      if (typeof accept !== 'string') {\n        throw new TypeError('accept field must be a string if provided')\n      }\n      this[_accept] = accept || '*'\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('must provide dependency name')\n    }\n    this[_name] = name\n\n    if (!types.has(type)) {\n      throw new TypeError(\n        `invalid type: ${type}\\n` +\n        `(valid types are: ${Edge.types.join(', ')})`)\n    }\n    this[_type] = type\n    if (!from) {\n      throw new TypeError('must provide \"from\" node')\n    }\n    this[_setFrom](from)\n    this[_error] = this[_loadError]()\n    this.peerConflicted = false\n  }\n\n  satisfiedBy (node) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    // NOTE: this condition means we explicitly do not support overriding\n    // bundled or shrinkwrapped dependencies\n    const spec = (node.hasShrinkwrap || node.inShrinkwrap || node.inBundle)\n      ? this.rawSpec\n      : this.spec\n    return depValid(node, spec, this.accept, this.from)\n  }\n\n  explain (seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](seen)\n  }\n\n  // return the edge data, and an explanation of how that edge came to be here\n  [_explain] (seen) {\n    const { error, from, bundled } = this\n    return {\n      type: this.type,\n      name: this.name,\n      spec: this.spec,\n      ...(this.rawSpec !== this.spec ? {\n        rawSpec: this.rawSpec,\n        overridden: true,\n      } : {}),\n      ...(bundled ? { bundled } : {}),\n      ...(error ? { error } : {}),\n      ...(from ? { from: from.explain(null, seen) } : {}),\n    }\n  }\n\n  get bundled () {\n    if (!this.from) {\n      return false\n    }\n    const { package: { bundleDependencies = [] } } = this.from\n    return bundleDependencies.includes(this.name)\n  }\n\n  get workspace () {\n    return this[_type] === 'workspace'\n  }\n\n  get prod () {\n    return this[_type] === 'prod'\n  }\n\n  get dev () {\n    return this[_type] === 'dev'\n  }\n\n  get optional () {\n    return this[_type] === 'optional' || this[_type] === 'peerOptional'\n  }\n\n  get peer () {\n    return this[_type] === 'peer' || this[_type] === 'peerOptional'\n  }\n\n  get type () {\n    return this[_type]\n  }\n\n  get name () {\n    return this[_name]\n  }\n\n  get rawSpec () {\n    return this[_spec]\n  }\n\n  get spec () {\n    if (this.overrides && this.overrides.value && this.overrides.name === this.name) {\n      if (this.overrides.value.startsWith('$')) {\n        const ref = this.overrides.value.slice(1)\n        // we may be a virtual root, if we are we want to resolve reference overrides\n        // from the real root, not the virtual one\n        const pkg = this.from.sourceReference\n          ? this.from.sourceReference.root.package\n          : this.from.root.package\n        const overrideSpec = (pkg.devDependencies && pkg.devDependencies[ref]) ||\n            (pkg.optionalDependencies && pkg.optionalDependencies[ref]) ||\n            (pkg.dependencies && pkg.dependencies[ref]) ||\n            (pkg.peerDependencies && pkg.peerDependencies[ref])\n\n        if (overrideSpec) {\n          return overrideSpec\n        }\n\n        throw new Error(`Unable to resolve reference ${this.overrides.value}`)\n      }\n      return this.overrides.value\n    }\n    return this[_spec]\n  }\n\n  get accept () {\n    return this[_accept]\n  }\n\n  get valid () {\n    return !this.error\n  }\n\n  get missing () {\n    return this.error === 'MISSING'\n  }\n\n  get invalid () {\n    return this.error === 'INVALID'\n  }\n\n  get peerLocal () {\n    return this.error === 'PEER LOCAL'\n  }\n\n  get error () {\n    this[_error] = this[_error] || this[_loadError]()\n    return this[_error] === 'OK' ? null : this[_error]\n  }\n\n  [_loadError] () {\n    return !this[_to] ? (this.optional ? null : 'MISSING')\n      : this.peer && this.from === this.to.parent && !this.from.isTop ? 'PEER LOCAL'\n      : !this.satisfiedBy(this.to) ? 'INVALID'\n      : 'OK'\n  }\n\n  reload (hard = false) {\n    this[_explanation] = null\n    if (this[_from].overrides) {\n      this.overrides = this[_from].overrides.getEdgeRule(this)\n    } else {\n      delete this.overrides\n    }\n    const newTo = this[_from].resolve(this.name)\n    if (newTo !== this[_to]) {\n      if (this[_to]) {\n        this[_to].edgesIn.delete(this)\n      }\n      this[_to] = newTo\n      this[_error] = this[_loadError]()\n      if (this[_to]) {\n        this[_to].addEdgeIn(this)\n      }\n    } else if (hard) {\n      this[_error] = this[_loadError]()\n    }\n  }\n\n  detach () {\n    this[_explanation] = null\n    if (this[_to]) {\n      this[_to].edgesIn.delete(this)\n    }\n    this[_from].edgesOut.delete(this.name)\n    this[_to] = null\n    this[_error] = 'DETACHED'\n    this[_from] = null\n  }\n\n  [_setFrom] (node) {\n    this[_explanation] = null\n    this[_from] = node\n    if (node.edgesOut.has(this.name)) {\n      node.edgesOut.get(this.name).detach()\n    }\n\n    node.addEdgeOut(this)\n    this.reload()\n  }\n\n  get from () {\n    return this[_from]\n  }\n\n  get to () {\n    return this[_to]\n  }\n\n  toJSON () {\n    return printableEdge(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nEdge.types = [...types]\nEdge.errors = [\n  'DETACHED',\n  'MISSING',\n  'PEER LOCAL',\n  'INVALID',\n]\n\nmodule.exports = Edge\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}