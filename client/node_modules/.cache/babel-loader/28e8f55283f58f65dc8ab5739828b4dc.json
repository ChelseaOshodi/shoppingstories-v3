{"ast":null,"code":"const os = require('os');\n\nconst path = require('path');\n\nconst {\n  format,\n  promisify\n} = require('util');\n\nconst rimraf = promisify(require('rimraf'));\nconst glob = promisify(require('glob'));\n\nconst MiniPass = require('minipass');\n\nconst fsMiniPass = require('fs-minipass');\n\nconst fs = require('@npmcli/fs');\n\nconst log = require('./log-shim');\n\nconst padZero = (n, length) => n.toString().padStart(length.toString().length, '0');\n\nconst globify = pattern => pattern.split('\\\\').join('/');\n\nconst _logHandler = Symbol('logHandler');\n\nconst _formatLogItem = Symbol('formatLogItem');\n\nconst _getLogFilePath = Symbol('getLogFilePath');\n\nconst _openLogFile = Symbol('openLogFile');\n\nconst _cleanLogs = Symbol('cleanlogs');\n\nconst _endStream = Symbol('endStream');\n\nconst _isBuffered = Symbol('isBuffered');\n\nclass LogFiles {\n  // If we write multiple log files we want them all to have the same\n  // identifier for sorting and matching purposes\n  #logId = null; // Default to a plain minipass stream so we can buffer\n  // initial writes before we know the cache location\n\n  #logStream = null; // We cap log files at a certain number of log events per file.\n  // Note that each log event can write more than one line to the\n  // file. Then we rotate log files once this number of events is reached\n\n  #MAX_LOGS_PER_FILE = null; // Now that we write logs continuously we need to have a backstop\n  // here for infinite loops that still log. This is also partially handled\n  // by the config.get('max-files') option, but this is a failsafe to\n  // prevent runaway log file creation\n\n  #MAX_FILES_PER_PROCESS = null;\n  #fileLogCount = 0;\n  #totalLogCount = 0;\n  #dir = null;\n  #logsMax = null;\n  #files = [];\n\n  constructor() {\n    let {\n      maxLogsPerFile = 50_000,\n      maxFilesPerProcess = 5\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.#logId = LogFiles.logId(new Date());\n    this.#MAX_LOGS_PER_FILE = maxLogsPerFile;\n    this.#MAX_FILES_PER_PROCESS = maxFilesPerProcess;\n    this.on();\n  }\n\n  static logId(d) {\n    return d.toISOString().replace(/[.:]/g, '_');\n  }\n\n  static format(count, level, title) {\n    let prefix = `${count} ${level}`;\n\n    if (title) {\n      prefix += ` ${title}`;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n\n    return format(...args).split(/\\r?\\n/).reduce((lines, line) => lines += prefix + (line ? ' ' : '') + line + os.EOL, '');\n  }\n\n  on() {\n    this.#logStream = new MiniPass();\n    process.on('log', this[_logHandler]);\n  }\n\n  off() {\n    process.off('log', this[_logHandler]);\n\n    this[_endStream]();\n  }\n\n  load() {\n    let {\n      dir,\n      logsMax = Infinity\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // dir is user configurable and is required to exist so\n    // this can error if the dir is missing or not configured correctly\n    this.#dir = dir;\n    this.#logsMax = logsMax; // Log stream has already ended\n\n    if (!this.#logStream) {\n      return;\n    }\n\n    log.verbose('logfile', `logs-max:${logsMax} dir:${dir}`); // Pipe our initial stream to our new file stream and\n    // set that as the new log logstream for future writes\n    // if logs max is 0 then the user does not want a log file\n\n    if (this.#logsMax > 0) {\n      const initialFile = this[_openLogFile]();\n\n      if (initialFile) {\n        this.#logStream = this.#logStream.pipe(initialFile);\n      }\n    } // Kickoff cleaning process, even if we aren't writing a logfile.\n    // This is async but it will always ignore the current logfile\n    // Return the result so it can be awaited in tests\n\n\n    return this[_cleanLogs]();\n  }\n\n  log() {\n    this[_logHandler](...arguments);\n  }\n\n  get files() {\n    return this.#files;\n  }\n\n  get [_isBuffered]() {\n    return this.#logStream instanceof MiniPass;\n  }\n\n  [_endStream](output) {\n    if (this.#logStream) {\n      this.#logStream.end(output);\n      this.#logStream = null;\n    }\n  }\n\n  [_logHandler] = (() => {\n    var _this = this;\n\n    return function (level) {\n      // Ignore pause and resume events since we\n      // write everything to the log file\n      if (level === 'pause' || level === 'resume') {\n        return;\n      } // If the stream is ended then do nothing\n\n\n      if (!_this.#logStream) {\n        return;\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      const logOutput = _this[_formatLogItem](level, ...args);\n\n      if (_this[_isBuffered]) {\n        // Cant do anything but buffer the output if we dont\n        // have a file stream yet\n        _this.#logStream.write(logOutput);\n\n        return;\n      } // Open a new log file if we've written too many logs to this one\n\n\n      if (_this.#fileLogCount >= _this.#MAX_LOGS_PER_FILE) {\n        // Write last chunk to the file and close it\n        _this[_endStream](logOutput);\n\n        if (_this.#files.length >= _this.#MAX_FILES_PER_PROCESS) {\n          // but if its way too many then we just stop listening\n          _this.off();\n        } else {\n          // otherwise we are ready for a new file for the next event\n          _this.#logStream = _this[_openLogFile]();\n        }\n      } else {\n        _this.#logStream.write(logOutput);\n      }\n    };\n  })();\n\n  [_formatLogItem]() {\n    this.#fileLogCount += 1;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return LogFiles.format(this.#totalLogCount++, ...args);\n  }\n\n  [_getLogFilePath]() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return path.resolve(this.#dir, `${this.#logId}-debug-${count}.log`);\n  }\n\n  [_openLogFile]() {\n    // Count in filename will be 0 indexed\n    const count = this.#files.length;\n\n    try {\n      // Pad with zeros so that our log files are always sorted properly\n      // We never want to write files ending in `-9.log` and `-10.log` because\n      // log file cleaning is done by deleting the oldest so in this example\n      // `-10.log` would be deleted next\n      const f = this[_getLogFilePath](padZero(count, this.#MAX_FILES_PER_PROCESS)); // Some effort was made to make the async, but we need to write logs\n      // during process.on('exit') which has to be synchronous. So in order\n      // to never drop log messages, it is easiest to make it sync all the time\n      // and this was measured to be about 1.5% slower for 40k lines of output\n\n\n      const logStream = fs.withOwnerSync(f, () => new fsMiniPass.WriteStreamSync(f, {\n        flags: 'a'\n      }), {\n        owner: 'inherit'\n      });\n\n      if (count > 0) {\n        // Reset file log count if we are opening\n        // after our first file\n        this.#fileLogCount = 0;\n      }\n\n      this.#files.push(logStream.path);\n      return logStream;\n    } catch (e) {\n      // If the user has a readonly logdir then we don't want to\n      // warn this on every command so it should be verbose\n      log.verbose('logfile', `could not be created: ${e}`);\n    }\n  }\n\n  async [_cleanLogs]() {\n    // module to clean out the old log files\n    // this is a best-effort attempt.  if a rm fails, we just\n    // log a message about it and move on.  We do return a\n    // Promise that succeeds when we've tried to delete everything,\n    // just for the benefit of testing this function properly.\n    try {\n      const logPath = this[_getLogFilePath]();\n\n      const logGlob = path.join(path.dirname(logPath), path.basename(logPath) // tell glob to only match digits\n      .replace(/\\d/g, '[0123456789]') // Handle the old (prior to 8.2.0) log file names which did not have a\n      // counter suffix\n      .replace(/-\\.log$/, '*.log')); // Always ignore the currently written files\n\n      const files = await glob(globify(logGlob), {\n        ignore: this.#files.map(globify),\n        silent: true\n      });\n      const toDelete = files.length - this.#logsMax;\n\n      if (toDelete <= 0) {\n        return;\n      }\n\n      log.silly('logfile', `start cleaning logs, removing ${toDelete} files`);\n\n      for (const file of files.slice(0, toDelete)) {\n        try {\n          await rimraf(file, {\n            glob: false\n          });\n        } catch (e) {\n          log.silly('logfile', 'error removing log file', file, e);\n        }\n      }\n    } catch (e) {\n      log.warn('logfile', 'error cleaning log files', e);\n    } finally {\n      log.silly('logfile', 'done cleaning log files');\n    }\n  }\n\n}\n\nmodule.exports = LogFiles;","map":{"version":3,"names":["os","require","path","format","promisify","rimraf","glob","MiniPass","fsMiniPass","fs","log","padZero","n","length","toString","padStart","globify","pattern","split","join","_logHandler","Symbol","_formatLogItem","_getLogFilePath","_openLogFile","_cleanLogs","_endStream","_isBuffered","LogFiles","logId","logStream","MAX_LOGS_PER_FILE","MAX_FILES_PER_PROCESS","fileLogCount","totalLogCount","dir","logsMax","files","constructor","maxLogsPerFile","maxFilesPerProcess","Date","on","d","toISOString","replace","count","level","title","prefix","args","reduce","lines","line","EOL","process","off","load","Infinity","verbose","initialFile","pipe","output","end","logOutput","write","resolve","f","withOwnerSync","WriteStreamSync","flags","owner","push","e","logPath","logGlob","dirname","basename","ignore","map","silent","toDelete","silly","file","slice","warn","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/utils/log-file.js"],"sourcesContent":["const os = require('os')\nconst path = require('path')\nconst { format, promisify } = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst glob = promisify(require('glob'))\nconst MiniPass = require('minipass')\nconst fsMiniPass = require('fs-minipass')\nconst fs = require('@npmcli/fs')\nconst log = require('./log-shim')\n\nconst padZero = (n, length) => n.toString().padStart(length.toString().length, '0')\nconst globify = pattern => pattern.split('\\\\').join('/')\n\nconst _logHandler = Symbol('logHandler')\nconst _formatLogItem = Symbol('formatLogItem')\nconst _getLogFilePath = Symbol('getLogFilePath')\nconst _openLogFile = Symbol('openLogFile')\nconst _cleanLogs = Symbol('cleanlogs')\nconst _endStream = Symbol('endStream')\nconst _isBuffered = Symbol('isBuffered')\n\nclass LogFiles {\n  // If we write multiple log files we want them all to have the same\n  // identifier for sorting and matching purposes\n  #logId = null\n\n  // Default to a plain minipass stream so we can buffer\n  // initial writes before we know the cache location\n  #logStream = null\n\n  // We cap log files at a certain number of log events per file.\n  // Note that each log event can write more than one line to the\n  // file. Then we rotate log files once this number of events is reached\n  #MAX_LOGS_PER_FILE = null\n\n  // Now that we write logs continuously we need to have a backstop\n  // here for infinite loops that still log. This is also partially handled\n  // by the config.get('max-files') option, but this is a failsafe to\n  // prevent runaway log file creation\n  #MAX_FILES_PER_PROCESS = null\n\n  #fileLogCount = 0\n  #totalLogCount = 0\n  #dir = null\n  #logsMax = null\n  #files = []\n\n  constructor ({\n    maxLogsPerFile = 50_000,\n    maxFilesPerProcess = 5,\n  } = {}) {\n    this.#logId = LogFiles.logId(new Date())\n    this.#MAX_LOGS_PER_FILE = maxLogsPerFile\n    this.#MAX_FILES_PER_PROCESS = maxFilesPerProcess\n    this.on()\n  }\n\n  static logId (d) {\n    return d.toISOString().replace(/[.:]/g, '_')\n  }\n\n  static format (count, level, title, ...args) {\n    let prefix = `${count} ${level}`\n    if (title) {\n      prefix += ` ${title}`\n    }\n\n    return format(...args)\n      .split(/\\r?\\n/)\n      .reduce((lines, line) =>\n        lines += prefix + (line ? ' ' : '') + line + os.EOL,\n      ''\n      )\n  }\n\n  on () {\n    this.#logStream = new MiniPass()\n    process.on('log', this[_logHandler])\n  }\n\n  off () {\n    process.off('log', this[_logHandler])\n    this[_endStream]()\n  }\n\n  load ({ dir, logsMax = Infinity } = {}) {\n    // dir is user configurable and is required to exist so\n    // this can error if the dir is missing or not configured correctly\n    this.#dir = dir\n    this.#logsMax = logsMax\n\n    // Log stream has already ended\n    if (!this.#logStream) {\n      return\n    }\n\n    log.verbose('logfile', `logs-max:${logsMax} dir:${dir}`)\n\n    // Pipe our initial stream to our new file stream and\n    // set that as the new log logstream for future writes\n    // if logs max is 0 then the user does not want a log file\n    if (this.#logsMax > 0) {\n      const initialFile = this[_openLogFile]()\n      if (initialFile) {\n        this.#logStream = this.#logStream.pipe(initialFile)\n      }\n    }\n\n    // Kickoff cleaning process, even if we aren't writing a logfile.\n    // This is async but it will always ignore the current logfile\n    // Return the result so it can be awaited in tests\n    return this[_cleanLogs]()\n  }\n\n  log (...args) {\n    this[_logHandler](...args)\n  }\n\n  get files () {\n    return this.#files\n  }\n\n  get [_isBuffered] () {\n    return this.#logStream instanceof MiniPass\n  }\n\n  [_endStream] (output) {\n    if (this.#logStream) {\n      this.#logStream.end(output)\n      this.#logStream = null\n    }\n  }\n\n  [_logHandler] = (level, ...args) => {\n    // Ignore pause and resume events since we\n    // write everything to the log file\n    if (level === 'pause' || level === 'resume') {\n      return\n    }\n\n    // If the stream is ended then do nothing\n    if (!this.#logStream) {\n      return\n    }\n\n    const logOutput = this[_formatLogItem](level, ...args)\n\n    if (this[_isBuffered]) {\n      // Cant do anything but buffer the output if we dont\n      // have a file stream yet\n      this.#logStream.write(logOutput)\n      return\n    }\n\n    // Open a new log file if we've written too many logs to this one\n    if (this.#fileLogCount >= this.#MAX_LOGS_PER_FILE) {\n      // Write last chunk to the file and close it\n      this[_endStream](logOutput)\n      if (this.#files.length >= this.#MAX_FILES_PER_PROCESS) {\n        // but if its way too many then we just stop listening\n        this.off()\n      } else {\n        // otherwise we are ready for a new file for the next event\n        this.#logStream = this[_openLogFile]()\n      }\n    } else {\n      this.#logStream.write(logOutput)\n    }\n  }\n\n  [_formatLogItem] (...args) {\n    this.#fileLogCount += 1\n    return LogFiles.format(this.#totalLogCount++, ...args)\n  }\n\n  [_getLogFilePath] (count = '') {\n    return path.resolve(this.#dir, `${this.#logId}-debug-${count}.log`)\n  }\n\n  [_openLogFile] () {\n    // Count in filename will be 0 indexed\n    const count = this.#files.length\n\n    try {\n      // Pad with zeros so that our log files are always sorted properly\n      // We never want to write files ending in `-9.log` and `-10.log` because\n      // log file cleaning is done by deleting the oldest so in this example\n      // `-10.log` would be deleted next\n      const f = this[_getLogFilePath](padZero(count, this.#MAX_FILES_PER_PROCESS))\n      // Some effort was made to make the async, but we need to write logs\n      // during process.on('exit') which has to be synchronous. So in order\n      // to never drop log messages, it is easiest to make it sync all the time\n      // and this was measured to be about 1.5% slower for 40k lines of output\n      const logStream = fs.withOwnerSync(\n        f,\n        () => new fsMiniPass.WriteStreamSync(f, { flags: 'a' }),\n        { owner: 'inherit' }\n      )\n      if (count > 0) {\n        // Reset file log count if we are opening\n        // after our first file\n        this.#fileLogCount = 0\n      }\n      this.#files.push(logStream.path)\n      return logStream\n    } catch (e) {\n      // If the user has a readonly logdir then we don't want to\n      // warn this on every command so it should be verbose\n      log.verbose('logfile', `could not be created: ${e}`)\n    }\n  }\n\n  async [_cleanLogs] () {\n    // module to clean out the old log files\n    // this is a best-effort attempt.  if a rm fails, we just\n    // log a message about it and move on.  We do return a\n    // Promise that succeeds when we've tried to delete everything,\n    // just for the benefit of testing this function properly.\n\n    try {\n      const logPath = this[_getLogFilePath]()\n      const logGlob = path.join(path.dirname(logPath), path.basename(logPath)\n        // tell glob to only match digits\n        .replace(/\\d/g, '[0123456789]')\n        // Handle the old (prior to 8.2.0) log file names which did not have a\n        // counter suffix\n        .replace(/-\\.log$/, '*.log')\n      )\n\n      // Always ignore the currently written files\n      const files = await glob(globify(logGlob), { ignore: this.#files.map(globify), silent: true })\n      const toDelete = files.length - this.#logsMax\n\n      if (toDelete <= 0) {\n        return\n      }\n\n      log.silly('logfile', `start cleaning logs, removing ${toDelete} files`)\n\n      for (const file of files.slice(0, toDelete)) {\n        try {\n          await rimraf(file, { glob: false })\n        } catch (e) {\n          log.silly('logfile', 'error removing log file', file, e)\n        }\n      }\n    } catch (e) {\n      log.warn('logfile', 'error cleaning log files', e)\n    } finally {\n      log.silly('logfile', 'done cleaning log files')\n    }\n  }\n}\n\nmodule.exports = LogFiles\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}