{"ast":null,"code":"'use strict';\n\nconst npa = require('npm-package-arg');\n\nconst parser = require('postcss-selector-parser');\n\nconst semver = require('semver');\n\nconst arrayDelimiter = Symbol('arrayDelimiter');\n\nconst escapeSlashes = str => str.replace(/\\//g, '\\\\/');\n\nconst unescapeSlashes = str => str.replace(/\\\\\\//g, '/');\n\nconst fixupIds = astNode => {\n  const {\n    name,\n    rawSpec: part\n  } = npa(astNode.value);\n  const versionParts = [{\n    astNode,\n    part\n  }];\n  let currentAstNode = astNode.next();\n\n  if (!part) {\n    return;\n  }\n\n  while (currentAstNode) {\n    versionParts.push({\n      astNode: currentAstNode,\n      part: String(currentAstNode)\n    });\n    currentAstNode = currentAstNode.next();\n  }\n\n  let version;\n  let length = versionParts.length;\n\n  while (!version && length) {\n    version = semver.valid(versionParts.slice(0, length).reduce((res, i) => `${res}${i.part}`, ''));\n    length--;\n  }\n\n  astNode.value = `${name}@${version}`;\n\n  for (let i = 1; i <= length; i++) {\n    versionParts[i].astNode.remove();\n  }\n}; // recursively fixes up any :attr pseudo-class found\n\n\nconst fixupAttr = astNode => {\n  const properties = [];\n  const matcher = {};\n\n  for (const selectorAstNode of astNode.nodes) {\n    const [firstAstNode] = selectorAstNode.nodes;\n\n    if (firstAstNode.type === 'tag') {\n      properties.push(firstAstNode.value);\n    }\n  }\n\n  const lastSelectorAstNode = astNode.nodes.pop();\n  const [attributeAstNode] = lastSelectorAstNode.nodes;\n\n  if (attributeAstNode.value === ':attr') {\n    const appendParts = fixupAttr(attributeAstNode);\n    properties.push(arrayDelimiter, ...appendParts.lookupProperties);\n    matcher.qualifiedAttribute = appendParts.attributeMatcher.qualifiedAttribute;\n    matcher.operator = appendParts.attributeMatcher.operator;\n    matcher.value = appendParts.attributeMatcher.value; // backwards compatibility\n\n    matcher.attribute = appendParts.attributeMatcher.attribute;\n\n    if (appendParts.attributeMatcher.insensitive) {\n      matcher.insensitive = true;\n    }\n  } else {\n    if (attributeAstNode.type !== 'attribute') {\n      throw Object.assign(new Error('`:attr` pseudo-class expects an attribute matcher as the last value'), {\n        code: 'EQUERYATTR'\n      });\n    }\n\n    matcher.qualifiedAttribute = unescapeSlashes(attributeAstNode.qualifiedAttribute);\n    matcher.operator = attributeAstNode.operator;\n    matcher.value = attributeAstNode.value; // backwards compatibility\n\n    matcher.attribute = matcher.qualifiedAttribute;\n\n    if (attributeAstNode.insensitive) {\n      matcher.insensitive = true;\n    }\n  }\n\n  astNode.lookupProperties = properties;\n  astNode.attributeMatcher = matcher;\n  astNode.nodes.length = 0;\n  return astNode;\n}; // fixed up nested pseudo nodes will have their internal selectors moved\n// to a new root node that will be referenced by the `nestedNode` property,\n// this tweak makes it simpler to reuse `retrieveNodesFromParsedAst` to\n// recursively parse and extract results from the internal selectors\n\n\nconst fixupNestedPseudo = astNode => {\n  // create a new ast root node and relocate any children\n  // selectors of the current ast node to this new root\n  const newRootNode = parser.root();\n  astNode.nestedNode = newRootNode;\n  newRootNode.nodes = [...astNode.nodes]; // clean up the ast by removing the children nodes from the\n  // current ast node while also cleaning up their `parent` refs\n\n  astNode.nodes.length = 0;\n\n  for (const currAstNode of newRootNode.nodes) {\n    currAstNode.parent = newRootNode;\n  } // recursively fixup nodes of any nested selector\n\n\n  transformAst(newRootNode);\n};\n\nconst fixupSemverSpecs = astNode => {\n  const children = astNode.nodes[0].nodes;\n  const value = children.reduce((res, i) => `${res}${String(i)}`, '');\n  astNode.semverValue = value;\n  astNode.nodes.length = 0;\n};\n\nconst fixupTypes = astNode => {\n  const [valueAstNode] = astNode.nodes[0].nodes;\n  const {\n    value\n  } = valueAstNode || {};\n  astNode.typeValue = value;\n  astNode.nodes.length = 0;\n};\n\nconst fixupPaths = astNode => {\n  astNode.pathValue = unescapeSlashes(String(astNode.nodes[0]));\n  astNode.nodes.length = 0;\n}; // a few of the supported ast nodes need to be tweaked in order to properly be\n// interpreted as proper arborist query selectors, namely semver ranges from\n// both ids and :semver pseudo-class selectors need to be translated from what\n// are usually multiple ast nodes, such as: tag:1, class:.0, class:.0 to a\n// single `1.0.0` value, other pseudo-class selectors also get preprocessed in\n// order to make it simpler to execute later when traversing each ast node\n// using rootNode.walk(), such as :path, :type, etc. transformAst handles all\n// these modifications to the parsed ast by doing an extra, initial traversal\n// of the parsed ast from the query and modifying the parsed nodes accordingly\n\n\nconst transformAst = selector => {\n  selector.walk(nextAstNode => {\n    if (nextAstNode.type === 'id') {\n      fixupIds(nextAstNode);\n    }\n\n    switch (nextAstNode.value) {\n      case ':attr':\n        return fixupAttr(nextAstNode);\n\n      case ':is':\n      case ':has':\n      case ':not':\n        return fixupNestedPseudo(nextAstNode);\n\n      case ':path':\n        return fixupPaths(nextAstNode);\n\n      case ':semver':\n        return fixupSemverSpecs(nextAstNode);\n\n      case ':type':\n        return fixupTypes(nextAstNode);\n    }\n  });\n};\n\nconst queryParser = query => {\n  // if query is an empty string or any falsy\n  // value, just returns an empty result\n  if (!query) {\n    return [];\n  }\n\n  return parser(transformAst).astSync(escapeSlashes(query), {\n    lossless: false\n  });\n};\n\nmodule.exports = {\n  parser: queryParser,\n  arrayDelimiter\n};","map":{"version":3,"names":["npa","require","parser","semver","arrayDelimiter","Symbol","escapeSlashes","str","replace","unescapeSlashes","fixupIds","astNode","name","rawSpec","part","value","versionParts","currentAstNode","next","push","String","version","length","valid","slice","reduce","res","i","remove","fixupAttr","properties","matcher","selectorAstNode","nodes","firstAstNode","type","lastSelectorAstNode","pop","attributeAstNode","appendParts","lookupProperties","qualifiedAttribute","attributeMatcher","operator","attribute","insensitive","Object","assign","Error","code","fixupNestedPseudo","newRootNode","root","nestedNode","currAstNode","parent","transformAst","fixupSemverSpecs","children","semverValue","fixupTypes","valueAstNode","typeValue","fixupPaths","pathValue","selector","walk","nextAstNode","queryParser","query","astSync","lossless","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/query/lib/index.js"],"sourcesContent":["'use strict'\n\nconst npa = require('npm-package-arg')\nconst parser = require('postcss-selector-parser')\nconst semver = require('semver')\n\nconst arrayDelimiter = Symbol('arrayDelimiter')\n\nconst escapeSlashes = str =>\n  str.replace(/\\//g, '\\\\/')\n\nconst unescapeSlashes = str =>\n  str.replace(/\\\\\\//g, '/')\n\nconst fixupIds = astNode => {\n  const { name, rawSpec: part } = npa(astNode.value)\n  const versionParts = [{ astNode, part }]\n  let currentAstNode = astNode.next()\n\n  if (!part) {\n    return\n  }\n\n  while (currentAstNode) {\n    versionParts.push({ astNode: currentAstNode, part: String(currentAstNode) })\n    currentAstNode = currentAstNode.next()\n  }\n\n  let version\n  let length = versionParts.length\n  while (!version && length) {\n    version =\n      semver.valid(\n        versionParts.slice(0, length).reduce((res, i) => `${res}${i.part}`, '')\n      )\n    length--\n  }\n\n  astNode.value = `${name}@${version}`\n\n  for (let i = 1; i <= length; i++) {\n    versionParts[i].astNode.remove()\n  }\n}\n\n// recursively fixes up any :attr pseudo-class found\nconst fixupAttr = astNode => {\n  const properties = []\n  const matcher = {}\n  for (const selectorAstNode of astNode.nodes) {\n    const [firstAstNode] = selectorAstNode.nodes\n    if (firstAstNode.type === 'tag') {\n      properties.push(firstAstNode.value)\n    }\n  }\n\n  const lastSelectorAstNode = astNode.nodes.pop()\n  const [attributeAstNode] = lastSelectorAstNode.nodes\n\n  if (attributeAstNode.value === ':attr') {\n    const appendParts = fixupAttr(attributeAstNode)\n    properties.push(arrayDelimiter, ...appendParts.lookupProperties)\n    matcher.qualifiedAttribute = appendParts.attributeMatcher.qualifiedAttribute\n    matcher.operator = appendParts.attributeMatcher.operator\n    matcher.value = appendParts.attributeMatcher.value\n\n    // backwards compatibility\n    matcher.attribute = appendParts.attributeMatcher.attribute\n\n    if (appendParts.attributeMatcher.insensitive) {\n      matcher.insensitive = true\n    }\n  } else {\n    if (attributeAstNode.type !== 'attribute') {\n      throw Object.assign(\n        new Error('`:attr` pseudo-class expects an attribute matcher as the last value'),\n        { code: 'EQUERYATTR' }\n      )\n    }\n\n    matcher.qualifiedAttribute = unescapeSlashes(attributeAstNode.qualifiedAttribute)\n    matcher.operator = attributeAstNode.operator\n    matcher.value = attributeAstNode.value\n\n    // backwards compatibility\n    matcher.attribute = matcher.qualifiedAttribute\n\n    if (attributeAstNode.insensitive) {\n      matcher.insensitive = true\n    }\n  }\n\n  astNode.lookupProperties = properties\n  astNode.attributeMatcher = matcher\n  astNode.nodes.length = 0\n  return astNode\n}\n\n// fixed up nested pseudo nodes will have their internal selectors moved\n// to a new root node that will be referenced by the `nestedNode` property,\n// this tweak makes it simpler to reuse `retrieveNodesFromParsedAst` to\n// recursively parse and extract results from the internal selectors\nconst fixupNestedPseudo = astNode => {\n  // create a new ast root node and relocate any children\n  // selectors of the current ast node to this new root\n  const newRootNode = parser.root()\n  astNode.nestedNode = newRootNode\n  newRootNode.nodes = [...astNode.nodes]\n\n  // clean up the ast by removing the children nodes from the\n  // current ast node while also cleaning up their `parent` refs\n  astNode.nodes.length = 0\n  for (const currAstNode of newRootNode.nodes) {\n    currAstNode.parent = newRootNode\n  }\n\n  // recursively fixup nodes of any nested selector\n  transformAst(newRootNode)\n}\n\nconst fixupSemverSpecs = astNode => {\n  const children = astNode.nodes[0].nodes\n  const value = children.reduce((res, i) => `${res}${String(i)}`, '')\n\n  astNode.semverValue = value\n  astNode.nodes.length = 0\n}\n\nconst fixupTypes = astNode => {\n  const [valueAstNode] = astNode.nodes[0].nodes\n  const { value } = valueAstNode || {}\n  astNode.typeValue = value\n  astNode.nodes.length = 0\n}\n\nconst fixupPaths = astNode => {\n  astNode.pathValue = unescapeSlashes(String(astNode.nodes[0]))\n  astNode.nodes.length = 0\n}\n\n// a few of the supported ast nodes need to be tweaked in order to properly be\n// interpreted as proper arborist query selectors, namely semver ranges from\n// both ids and :semver pseudo-class selectors need to be translated from what\n// are usually multiple ast nodes, such as: tag:1, class:.0, class:.0 to a\n// single `1.0.0` value, other pseudo-class selectors also get preprocessed in\n// order to make it simpler to execute later when traversing each ast node\n// using rootNode.walk(), such as :path, :type, etc. transformAst handles all\n// these modifications to the parsed ast by doing an extra, initial traversal\n// of the parsed ast from the query and modifying the parsed nodes accordingly\nconst transformAst = selector => {\n  selector.walk((nextAstNode) => {\n    if (nextAstNode.type === 'id') {\n      fixupIds(nextAstNode)\n    }\n\n    switch (nextAstNode.value) {\n      case ':attr':\n        return fixupAttr(nextAstNode)\n      case ':is':\n      case ':has':\n      case ':not':\n        return fixupNestedPseudo(nextAstNode)\n      case ':path':\n        return fixupPaths(nextAstNode)\n      case ':semver':\n        return fixupSemverSpecs(nextAstNode)\n      case ':type':\n        return fixupTypes(nextAstNode)\n    }\n  })\n}\n\nconst queryParser = (query) => {\n  // if query is an empty string or any falsy\n  // value, just returns an empty result\n  if (!query) {\n    return []\n  }\n\n  return parser(transformAst)\n    .astSync(escapeSlashes(query), { lossless: false })\n}\n\nmodule.exports = {\n  parser: queryParser,\n  arrayDelimiter,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}