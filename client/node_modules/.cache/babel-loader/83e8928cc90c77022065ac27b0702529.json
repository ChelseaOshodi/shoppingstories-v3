{"ast":null,"code":"// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\nconst semver = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  relative\n} = require('path');\n\nconst fromPath = require('./from-path.js');\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor, requestor.edgesOut.get(child.name)));\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name;\n      er.requested = requested;\n      requestor.errors.push(er);\n      return false;\n    }\n  } // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n\n\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier');\n    er.dependency = child.name;\n    er.requested = requested;\n    requestor.errors.push(er);\n    return false;\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true;\n      }\n\n    // fallthrough\n\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true);\n\n    case 'directory':\n      return linkValid(child, requested, requestor);\n\n    case 'file':\n      return tarballValid(child, requested, requestor);\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor);\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote';\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec;\n\n    case 'git':\n      {\n        // if it's a git type, verify that they're the same repo\n        //\n        // if it specifies a definite commit, then it must have the\n        // same commit to be considered the same repo\n        //\n        // if it has a #semver:<range> specifier, verify that the\n        // version in the package is in the semver range\n        const resRepo = npa(child.resolved || '');\n        const resHost = resRepo.hosted;\n        const reqHost = requested.hosted;\n        const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '');\n        const nc = {\n          noCommittish: !reqCommit\n        };\n        const sameRepo = resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc) : resRepo.fetchSpec === requested.fetchSpec;\n        return !sameRepo ? false : !requested.gitRange ? true : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true\n        });\n      }\n\n    default:\n      // unpossible, just being cautious\n      break;\n  }\n\n  const er = new Error('Unsupported dependency type');\n  er.dependency = child.name;\n  er.requested = requested;\n  requestor.errors.push(er);\n  return false;\n};\n\nconst linkValid = (child, requested, requestor) => {\n  const isLink = !!child.isLink; // if we're installing links and the node is a link, then it's invalid because we want\n  // a real node to be there\n\n  if (requestor.installLinks) {\n    return !isLink;\n  } // directory must be a link to the specified folder\n\n\n  return isLink && relative(child.realpath, requested.fetchSpec) === '';\n};\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false;\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`;\n  } // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n\n\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec;\n  } // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n\n\n  return false;\n};\n\nmodule.exports = (child, requested, accept, requestor) => depValid(child, requested, requestor) || (typeof accept === 'string' ? depValid(child, accept, requestor) : false);","map":{"version":3,"names":["semver","require","npa","relative","fromPath","depValid","child","requested","requestor","resolve","name","edgesOut","get","er","dependency","errors","push","Error","type","fetchSpec","satisfies","version","linkValid","tarballValid","subSpec","resolved","resRepo","resHost","hosted","reqHost","reqCommit","test","gitCommittish","nc","noCommittish","sameRepo","ssh","gitRange","package","loose","isLink","installLinks","realpath","replace","_requested","saveSpec","module","exports","accept"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/dep-valid.js"],"sourcesContent":["// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\n\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst { relative } = require('path')\nconst fromPath = require('./from-path.js')\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor, requestor.edgesOut.get(child.name)))\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name\n      er.requested = requested\n      requestor.errors.push(er)\n      return false\n    }\n  }\n\n  // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier')\n    er.dependency = child.name\n    er.requested = requested\n    requestor.errors.push(er)\n    return false\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true\n      }\n      // fallthrough\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true)\n\n    case 'directory':\n      return linkValid(child, requested, requestor)\n\n    case 'file':\n      return tarballValid(child, requested, requestor)\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor)\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote'\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec\n\n    case 'git': {\n      // if it's a git type, verify that they're the same repo\n      //\n      // if it specifies a definite commit, then it must have the\n      // same commit to be considered the same repo\n      //\n      // if it has a #semver:<range> specifier, verify that the\n      // version in the package is in the semver range\n      const resRepo = npa(child.resolved || '')\n      const resHost = resRepo.hosted\n      const reqHost = requested.hosted\n      const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '')\n      const nc = { noCommittish: !reqCommit }\n      const sameRepo =\n        resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc)\n        : resRepo.fetchSpec === requested.fetchSpec\n\n      return !sameRepo ? false\n        : !requested.gitRange ? true\n        : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true,\n        })\n    }\n\n    default: // unpossible, just being cautious\n      break\n  }\n\n  const er = new Error('Unsupported dependency type')\n  er.dependency = child.name\n  er.requested = requested\n  requestor.errors.push(er)\n  return false\n}\n\nconst linkValid = (child, requested, requestor) => {\n  const isLink = !!child.isLink\n  // if we're installing links and the node is a link, then it's invalid because we want\n  // a real node to be there\n  if (requestor.installLinks) {\n    return !isLink\n  }\n\n  // directory must be a link to the specified folder\n  return isLink && relative(child.realpath, requested.fetchSpec) === ''\n}\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`\n  }\n\n  // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec\n  }\n\n  // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n  return false\n}\n\nmodule.exports = (child, requested, accept, requestor) =>\n  depValid(child, requested, requestor) ||\n  (typeof accept === 'string' ? depValid(child, accept, requestor) : false)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}