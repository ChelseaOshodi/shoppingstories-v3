{"ast":null,"code":"const {\n  warn,\n  debug\n} = require('./debug');\n\nconst Cell = require('./cell');\n\nconst {\n  ColSpanCell,\n  RowSpanCell\n} = Cell;\n\n(function () {\n  function next(alloc, col) {\n    if (alloc[col] > 0) {\n      return next(alloc, col + 1);\n    }\n\n    return col;\n  }\n\n  function layoutTable(table) {\n    let alloc = {};\n    table.forEach(function (row, rowIndex) {\n      let col = 0;\n      row.forEach(function (cell) {\n        cell.y = rowIndex; // Avoid erroneous call to next() on first row\n\n        cell.x = rowIndex ? next(alloc, col) : col;\n        const rowSpan = cell.rowSpan || 1;\n        const colSpan = cell.colSpan || 1;\n\n        if (rowSpan > 1) {\n          for (let cs = 0; cs < colSpan; cs++) {\n            alloc[cell.x + cs] = rowSpan;\n          }\n        }\n\n        col = cell.x + colSpan;\n      });\n      Object.keys(alloc).forEach(idx => {\n        alloc[idx]--;\n        if (alloc[idx] < 1) delete alloc[idx];\n      });\n    });\n  }\n\n  function maxWidth(table) {\n    let mw = 0;\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        mw = Math.max(mw, cell.x + (cell.colSpan || 1));\n      });\n    });\n    return mw;\n  }\n\n  function maxHeight(table) {\n    return table.length;\n  }\n\n  function cellsConflict(cell1, cell2) {\n    let yMin1 = cell1.y;\n    let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);\n    let yMin2 = cell2.y;\n    let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);\n    let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);\n    let xMin1 = cell1.x;\n    let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);\n    let xMin2 = cell2.x;\n    let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);\n    let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);\n    return yConflict && xConflict;\n  }\n\n  function conflictExists(rows, x, y) {\n    let i_max = Math.min(rows.length - 1, y);\n    let cell = {\n      x: x,\n      y: y\n    };\n\n    for (let i = 0; i <= i_max; i++) {\n      let row = rows[i];\n\n      for (let j = 0; j < row.length; j++) {\n        if (cellsConflict(cell, row[j])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function allBlank(rows, y, xMin, xMax) {\n    for (let x = xMin; x < xMax; x++) {\n      if (conflictExists(rows, x, y)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function addRowSpanCells(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell) {\n        for (let i = 1; i < cell.rowSpan; i++) {\n          let rowSpanCell = new RowSpanCell(cell);\n          rowSpanCell.x = cell.x;\n          rowSpanCell.y = cell.y + i;\n          rowSpanCell.colSpan = cell.colSpan;\n          insertCell(rowSpanCell, table[rowIndex + i]);\n        }\n      });\n    });\n  }\n\n  function addColSpanCells(cellRows) {\n    for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {\n      let cellColumns = cellRows[rowIndex];\n\n      for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {\n        let cell = cellColumns[columnIndex];\n\n        for (let k = 1; k < cell.colSpan; k++) {\n          let colSpanCell = new ColSpanCell();\n          colSpanCell.x = cell.x + k;\n          colSpanCell.y = cell.y;\n          cellColumns.splice(columnIndex + 1, 0, colSpanCell);\n        }\n      }\n    }\n  }\n\n  function insertCell(cell, row) {\n    let x = 0;\n\n    while (x < row.length && row[x].x < cell.x) {\n      x++;\n    }\n\n    row.splice(x, 0, cell);\n  }\n\n  function fillInTable(table) {\n    let h_max = maxHeight(table);\n    let w_max = maxWidth(table);\n    debug(`Max rows: ${h_max}; Max cols: ${w_max}`);\n\n    for (let y = 0; y < h_max; y++) {\n      for (let x = 0; x < w_max; x++) {\n        if (!conflictExists(table, x, y)) {\n          let opts = {\n            x: x,\n            y: y,\n            colSpan: 1,\n            rowSpan: 1\n          };\n          x++;\n\n          while (x < w_max && !conflictExists(table, x, y)) {\n            opts.colSpan++;\n            x++;\n          }\n\n          let y2 = y + 1;\n\n          while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {\n            opts.rowSpan++;\n            y2++;\n          }\n\n          let cell = new Cell(opts);\n          cell.x = opts.x;\n          cell.y = opts.y;\n          warn(`Missing cell at ${cell.y}-${cell.x}.`);\n          insertCell(cell, table[y]);\n        }\n      }\n    }\n  }\n\n  function generateCells(rows) {\n    return rows.map(function (row) {\n      if (!Array.isArray(row)) {\n        let key = Object.keys(row)[0];\n        row = row[key];\n\n        if (Array.isArray(row)) {\n          row = row.slice();\n          row.unshift(key);\n        } else {\n          row = [key, row];\n        }\n      }\n\n      return row.map(function (cell) {\n        return new Cell(cell);\n      });\n    });\n  }\n\n  function makeTableLayout(rows) {\n    let cellRows = generateCells(rows);\n    layoutTable(cellRows);\n    fillInTable(cellRows);\n    addRowSpanCells(cellRows);\n    addColSpanCells(cellRows);\n    return cellRows;\n  }\n\n  module.exports = {\n    makeTableLayout: makeTableLayout,\n    layoutTable: layoutTable,\n    addRowSpanCells: addRowSpanCells,\n    maxWidth: maxWidth,\n    fillInTable: fillInTable,\n    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),\n    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1)\n  };\n})();\n\nfunction makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {\n  return function (vals, table) {\n    let result = [];\n    let spanners = [];\n    let auto = {};\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        if ((cell[colSpan] || 1) > 1) {\n          spanners.push(cell);\n        } else {\n          result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);\n        }\n      });\n    });\n    vals.forEach(function (val, index) {\n      if (typeof val === 'number') {\n        result[index] = val;\n      }\n    }); //spanners.forEach(function(cell){\n\n    for (let k = spanners.length - 1; k >= 0; k--) {\n      let cell = spanners[k];\n      let span = cell[colSpan];\n      let col = cell[x];\n      let existingWidth = result[col];\n      let editableCols = typeof vals[col] === 'number' ? 0 : 1;\n\n      if (typeof existingWidth === 'number') {\n        for (let i = 1; i < span; i++) {\n          existingWidth += 1 + result[col + i];\n\n          if (typeof vals[col + i] !== 'number') {\n            editableCols++;\n          }\n        }\n      } else {\n        existingWidth = desiredWidth === 'desiredWidth' ? cell.desiredWidth - 1 : 1;\n\n        if (!auto[col] || auto[col] < existingWidth) {\n          auto[col] = existingWidth;\n        }\n      }\n\n      if (cell[desiredWidth] > existingWidth) {\n        let i = 0;\n\n        while (editableCols > 0 && cell[desiredWidth] > existingWidth) {\n          if (typeof vals[col + i] !== 'number') {\n            let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);\n            existingWidth += dif;\n            result[col + i] += dif;\n            editableCols--;\n          }\n\n          i++;\n        }\n      }\n    }\n\n    Object.assign(vals, result, auto);\n\n    for (let j = 0; j < vals.length; j++) {\n      vals[j] = Math.max(forcedMin, vals[j] || 0);\n    }\n  };\n}","map":{"version":3,"names":["warn","debug","require","Cell","ColSpanCell","RowSpanCell","next","alloc","col","layoutTable","table","forEach","row","rowIndex","cell","y","x","rowSpan","colSpan","cs","Object","keys","idx","maxWidth","mw","Math","max","maxHeight","length","cellsConflict","cell1","cell2","yMin1","yMax1","yMin2","yMax2","yConflict","xMin1","xMax1","xMin2","xMax2","xConflict","conflictExists","rows","i_max","min","i","j","allBlank","xMin","xMax","addRowSpanCells","rowSpanCell","insertCell","addColSpanCells","cellRows","cellColumns","columnIndex","k","colSpanCell","splice","fillInTable","h_max","w_max","opts","y2","generateCells","map","Array","isArray","key","slice","unshift","makeTableLayout","module","exports","computeWidths","makeComputeWidths","computeHeights","desiredWidth","forcedMin","vals","result","spanners","auto","push","val","index","span","existingWidth","editableCols","dif","round","assign"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/cli-table3/src/layout-manager.js"],"sourcesContent":["const { warn, debug } = require('./debug');\nconst Cell = require('./cell');\nconst { ColSpanCell, RowSpanCell } = Cell;\n\n(function () {\n  function next(alloc, col) {\n    if (alloc[col] > 0) {\n      return next(alloc, col + 1);\n    }\n    return col;\n  }\n\n  function layoutTable(table) {\n    let alloc = {};\n    table.forEach(function (row, rowIndex) {\n      let col = 0;\n      row.forEach(function (cell) {\n        cell.y = rowIndex;\n        // Avoid erroneous call to next() on first row\n        cell.x = rowIndex ? next(alloc, col) : col;\n        const rowSpan = cell.rowSpan || 1;\n        const colSpan = cell.colSpan || 1;\n        if (rowSpan > 1) {\n          for (let cs = 0; cs < colSpan; cs++) {\n            alloc[cell.x + cs] = rowSpan;\n          }\n        }\n        col = cell.x + colSpan;\n      });\n      Object.keys(alloc).forEach((idx) => {\n        alloc[idx]--;\n        if (alloc[idx] < 1) delete alloc[idx];\n      });\n    });\n  }\n\n  function maxWidth(table) {\n    let mw = 0;\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        mw = Math.max(mw, cell.x + (cell.colSpan || 1));\n      });\n    });\n    return mw;\n  }\n\n  function maxHeight(table) {\n    return table.length;\n  }\n\n  function cellsConflict(cell1, cell2) {\n    let yMin1 = cell1.y;\n    let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);\n    let yMin2 = cell2.y;\n    let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);\n    let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);\n\n    let xMin1 = cell1.x;\n    let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);\n    let xMin2 = cell2.x;\n    let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);\n    let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);\n\n    return yConflict && xConflict;\n  }\n\n  function conflictExists(rows, x, y) {\n    let i_max = Math.min(rows.length - 1, y);\n    let cell = { x: x, y: y };\n    for (let i = 0; i <= i_max; i++) {\n      let row = rows[i];\n      for (let j = 0; j < row.length; j++) {\n        if (cellsConflict(cell, row[j])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  function allBlank(rows, y, xMin, xMax) {\n    for (let x = xMin; x < xMax; x++) {\n      if (conflictExists(rows, x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function addRowSpanCells(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell) {\n        for (let i = 1; i < cell.rowSpan; i++) {\n          let rowSpanCell = new RowSpanCell(cell);\n          rowSpanCell.x = cell.x;\n          rowSpanCell.y = cell.y + i;\n          rowSpanCell.colSpan = cell.colSpan;\n          insertCell(rowSpanCell, table[rowIndex + i]);\n        }\n      });\n    });\n  }\n\n  function addColSpanCells(cellRows) {\n    for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {\n      let cellColumns = cellRows[rowIndex];\n      for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {\n        let cell = cellColumns[columnIndex];\n        for (let k = 1; k < cell.colSpan; k++) {\n          let colSpanCell = new ColSpanCell();\n          colSpanCell.x = cell.x + k;\n          colSpanCell.y = cell.y;\n          cellColumns.splice(columnIndex + 1, 0, colSpanCell);\n        }\n      }\n    }\n  }\n\n  function insertCell(cell, row) {\n    let x = 0;\n    while (x < row.length && row[x].x < cell.x) {\n      x++;\n    }\n    row.splice(x, 0, cell);\n  }\n\n  function fillInTable(table) {\n    let h_max = maxHeight(table);\n    let w_max = maxWidth(table);\n    debug(`Max rows: ${h_max}; Max cols: ${w_max}`);\n    for (let y = 0; y < h_max; y++) {\n      for (let x = 0; x < w_max; x++) {\n        if (!conflictExists(table, x, y)) {\n          let opts = { x: x, y: y, colSpan: 1, rowSpan: 1 };\n          x++;\n          while (x < w_max && !conflictExists(table, x, y)) {\n            opts.colSpan++;\n            x++;\n          }\n          let y2 = y + 1;\n          while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {\n            opts.rowSpan++;\n            y2++;\n          }\n          let cell = new Cell(opts);\n          cell.x = opts.x;\n          cell.y = opts.y;\n          warn(`Missing cell at ${cell.y}-${cell.x}.`);\n          insertCell(cell, table[y]);\n        }\n      }\n    }\n  }\n\n  function generateCells(rows) {\n    return rows.map(function (row) {\n      if (!Array.isArray(row)) {\n        let key = Object.keys(row)[0];\n        row = row[key];\n        if (Array.isArray(row)) {\n          row = row.slice();\n          row.unshift(key);\n        } else {\n          row = [key, row];\n        }\n      }\n      return row.map(function (cell) {\n        return new Cell(cell);\n      });\n    });\n  }\n\n  function makeTableLayout(rows) {\n    let cellRows = generateCells(rows);\n    layoutTable(cellRows);\n    fillInTable(cellRows);\n    addRowSpanCells(cellRows);\n    addColSpanCells(cellRows);\n    return cellRows;\n  }\n\n  module.exports = {\n    makeTableLayout: makeTableLayout,\n    layoutTable: layoutTable,\n    addRowSpanCells: addRowSpanCells,\n    maxWidth: maxWidth,\n    fillInTable: fillInTable,\n    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),\n    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1),\n  };\n})();\n\nfunction makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {\n  return function (vals, table) {\n    let result = [];\n    let spanners = [];\n    let auto = {};\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        if ((cell[colSpan] || 1) > 1) {\n          spanners.push(cell);\n        } else {\n          result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);\n        }\n      });\n    });\n\n    vals.forEach(function (val, index) {\n      if (typeof val === 'number') {\n        result[index] = val;\n      }\n    });\n\n    //spanners.forEach(function(cell){\n    for (let k = spanners.length - 1; k >= 0; k--) {\n      let cell = spanners[k];\n      let span = cell[colSpan];\n      let col = cell[x];\n      let existingWidth = result[col];\n      let editableCols = typeof vals[col] === 'number' ? 0 : 1;\n      if (typeof existingWidth === 'number') {\n        for (let i = 1; i < span; i++) {\n          existingWidth += 1 + result[col + i];\n          if (typeof vals[col + i] !== 'number') {\n            editableCols++;\n          }\n        }\n      } else {\n        existingWidth = desiredWidth === 'desiredWidth' ? cell.desiredWidth - 1 : 1;\n        if (!auto[col] || auto[col] < existingWidth) {\n          auto[col] = existingWidth;\n        }\n      }\n\n      if (cell[desiredWidth] > existingWidth) {\n        let i = 0;\n        while (editableCols > 0 && cell[desiredWidth] > existingWidth) {\n          if (typeof vals[col + i] !== 'number') {\n            let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);\n            existingWidth += dif;\n            result[col + i] += dif;\n            editableCols--;\n          }\n          i++;\n        }\n      }\n    }\n\n    Object.assign(vals, result, auto);\n    for (let j = 0; j < vals.length; j++) {\n      vals[j] = Math.max(forcedMin, vals[j] || 0);\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}