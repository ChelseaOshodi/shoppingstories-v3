{"ast":null,"code":"const debug = require('./debug.js');\n\nconst relpath = require('./relpath.js');\n\nconst Node = require('./node.js');\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _target = Symbol.for('_target');\n\nconst {\n  dirname\n} = require('path'); // defined by Node class\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nclass Link extends Node {\n  constructor(options) {\n    const {\n      root,\n      realpath,\n      target,\n      parent,\n      fsParent\n    } = options;\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node');\n    }\n\n    super({ ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root : fsParent ? fsParent.root : target ? target.root : null)\n    });\n\n    if (target) {\n      this.target = target;\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root;\n    } else {\n      this.target = new Node({ ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root\n      });\n    }\n  }\n\n  get version() {\n    return this.target ? this.target.version : this.package.version || '';\n  }\n\n  get target() {\n    return this[_target];\n  }\n\n  set target(target) {\n    const current = this[_target];\n\n    if (target === current) {\n      return;\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath\n        });\n      });\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target;\n      target.then(node => {\n        this[_target] = null;\n        this.target = node;\n      });\n      return;\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this);\n      }\n\n      if (this.path) {\n        this[_delistFromMeta]();\n\n        this[_target] = null;\n        this.package = {};\n\n        this[_refreshLocation]();\n      } else {\n        this[_target] = null;\n      }\n\n      return;\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path;\n      } else {\n        target.path = target.realpath = this.realpath;\n      }\n\n      target.root = this.root;\n      this[_target] = target;\n      target.linksIn.add(this);\n      this.package = target.package;\n      return;\n    } // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n\n\n    this[_delistFromMeta]();\n\n    this.package = target.package;\n    this.realpath = target.path;\n\n    this[_refreshLocation]();\n\n    target.root = this.root;\n  } // a link always resolves to the relative path to its target\n\n\n  get resolved() {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath ? `file:${relpath(dirname(this.path), this.realpath).replace(/#/g, '%23')}` : null;\n  }\n\n  set resolved(r) {} // deps are resolved on the target, not the Link\n  // so this is a no-op\n\n\n  [_loadDeps]() {} // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n\n\n  get children() {\n    return new Map();\n  }\n\n  set children(c) {}\n\n  get isLink() {\n    return true;\n  }\n\n}\n\nmodule.exports = Link;","map":{"version":3,"names":["debug","require","relpath","Node","_loadDeps","Symbol","for","_target","dirname","_delistFromMeta","_refreshLocation","Link","constructor","options","root","realpath","target","parent","fsParent","path","TypeError","version","package","current","then","Object","assign","Error","node","linksIn","delete","add","resolved","replace","r","children","Map","c","isLink","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/link.js"],"sourcesContent":["const debug = require('./debug.js')\nconst relpath = require('./relpath.js')\nconst Node = require('./node.js')\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _target = Symbol.for('_target')\nconst { dirname } = require('path')\n// defined by Node class\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nclass Link extends Node {\n  constructor (options) {\n    const { root, realpath, target, parent, fsParent } = options\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node')\n    }\n\n    super({\n      ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root\n      : fsParent ? fsParent.root\n      : target ? target.root\n      : null),\n    })\n\n    if (target) {\n      this.target = target\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root\n    } else {\n      this.target = new Node({\n        ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root,\n      })\n    }\n  }\n\n  get version () {\n    return this.target ? this.target.version : this.package.version || ''\n  }\n\n  get target () {\n    return this[_target]\n  }\n\n  set target (target) {\n    const current = this[_target]\n    if (target === current) {\n      return\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath,\n        })\n      })\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target\n      target.then(node => {\n        this[_target] = null\n        this.target = node\n      })\n      return\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this)\n      }\n      if (this.path) {\n        this[_delistFromMeta]()\n        this[_target] = null\n        this.package = {}\n        this[_refreshLocation]()\n      } else {\n        this[_target] = null\n      }\n      return\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path\n      } else {\n        target.path = target.realpath = this.realpath\n      }\n      target.root = this.root\n      this[_target] = target\n      target.linksIn.add(this)\n      this.package = target.package\n      return\n    }\n\n    // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n    this[_delistFromMeta]()\n    this.package = target.package\n    this.realpath = target.path\n    this[_refreshLocation]()\n\n    target.root = this.root\n  }\n\n  // a link always resolves to the relative path to its target\n  get resolved () {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath\n      ? `file:${relpath(dirname(this.path), this.realpath).replace(/#/g, '%23')}`\n      : null\n  }\n\n  set resolved (r) {}\n\n  // deps are resolved on the target, not the Link\n  // so this is a no-op\n  [_loadDeps] () {}\n\n  // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n  get children () {\n    return new Map()\n  }\n\n  set children (c) {}\n\n  get isLink () {\n    return true\n  }\n}\n\nmodule.exports = Link\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}