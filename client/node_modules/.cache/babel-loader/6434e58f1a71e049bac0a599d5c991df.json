{"ast":null,"code":"const Minipass = require('minipass');\n\nconst fetch = require('minipass-fetch');\n\nconst promiseRetry = require('promise-retry');\n\nconst ssri = require('ssri');\n\nconst CachingMinipassPipeline = require('./pipeline.js');\n\nconst getAgent = require('./agent.js');\n\nconst pkg = require('../package.json');\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\n\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  }\n\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT);\n  } // keep our own options since we're overriding the agent\n  // and the redirect mode\n\n\n  const _opts = { ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts);\n\n    try {\n      let res = await fetch(req, _opts);\n\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          algorithms: _opts.algorithms,\n          integrity: _opts.integrity,\n          size: _opts.size\n        });\n        const pipeline = new CachingMinipassPipeline({\n          events: ['integrity', 'size']\n        }, res.body, integrityStream); // we also propagate the integrity and size events out to the pipeline so we can use\n        // this new response body as an integrityEmitter for cacache\n\n        integrityStream.on('integrity', i => pipeline.emit('integrity', i));\n        integrityStream.on('size', s => pipeline.emit('size', s));\n        res = new fetch.Response(pipeline, res); // set an explicit flag so we know if our response body will emit integrity and size\n\n        res.body.hasIntegrityEmitter = true;\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum); // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n\n      const isStream = Minipass.isStream(req.body);\n      const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(res);\n        }\n\n        return retryHandler(res);\n      }\n\n      return res;\n    } catch (err) {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code; // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n\n      const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err;\n      }\n\n      if (typeof options.onRetry === 'function') {\n        options.onRetry(err);\n      }\n\n      return retryHandler(err);\n    }\n  }, options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err;\n    }\n\n    throw err;\n  });\n};\n\nmodule.exports = remoteFetch;","map":{"version":3,"names":["Minipass","require","fetch","promiseRetry","ssri","CachingMinipassPipeline","getAgent","pkg","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","redirect","retryHandler","attemptNum","req","Request","res","integrity","status","integrityStream","algorithms","size","pipeline","events","body","on","i","emit","s","Response","hasIntegrityEmitter","isStream","isRetriable","method","includes","onRetry","err","code","retried","isRetryError","type","retry","catch","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/make-fetch-happen/lib/remote.js"],"sourcesContent":["const Minipass = require('minipass')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst CachingMinipassPipeline = require('./pipeline.js')\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n  }\n\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT)\n  }\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          algorithms: _opts.algorithms,\n          integrity: _opts.integrity,\n          size: _opts.size,\n        })\n        const pipeline = new CachingMinipassPipeline({\n          events: ['integrity', 'size'],\n        }, res.body, integrityStream)\n        // we also propagate the integrity and size events out to the pipeline so we can use\n        // this new response body as an integrityEmitter for cacache\n        integrityStream.on('integrity', i => pipeline.emit('integrity', i))\n        integrityStream.on('size', s => pipeline.emit('size', s))\n        res = new fetch.Response(pipeline, res)\n        // set an explicit flag so we know if our response body will emit integrity and size\n        res.body.hasIntegrityEmitter = true\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(res)\n        }\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err\n      }\n\n      if (typeof options.onRetry === 'function') {\n        options.onRetry(err)\n      }\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err\n    }\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMI,uBAAuB,GAAGJ,OAAO,CAAC,eAAD,CAAvC;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,iBAAD,CAAnB;;AAEA,MAAMO,UAAU,GAAI,GAAED,GAAG,CAACE,IAAK,IAAGF,GAAG,CAACG,OAAQ,qBAAoBH,GAAG,CAACE,IAAK,GAA3E;AAEA,MAAME,YAAY,GAAG,CACnB,YADmB,EACL;AACd,cAFmB,EAEH;AAChB,YAHmB,EAGL;AACd,WAJmB,EAIN;AACb,oBALmB,CAKG;AACtB;AACA;AAPmB,CAArB;AAUA,MAAMC,WAAW,GAAG,CAClB,iBADkB,CAApB,C,CAIA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsB;EACxC,MAAMC,KAAK,GAAGV,QAAQ,CAACQ,OAAO,CAACG,GAAT,EAAcF,OAAd,CAAtB;;EACA,IAAI,CAACD,OAAO,CAACI,OAAR,CAAgBC,GAAhB,CAAoB,YAApB,CAAL,EAAwC;IACtCL,OAAO,CAACI,OAAR,CAAgBE,GAAhB,CAAoB,YAApB,EAAkCJ,KAAK,GAAG,YAAH,GAAkB,OAAzD;EACD;;EAED,IAAI,CAACF,OAAO,CAACI,OAAR,CAAgBC,GAAhB,CAAoB,YAApB,CAAL,EAAwC;IACtCL,OAAO,CAACI,OAAR,CAAgBE,GAAhB,CAAoB,YAApB,EAAkCZ,UAAlC;EACD,CARuC,CAUxC;EACA;;;EACA,MAAMa,KAAK,GAAG,EACZ,GAAGN,OADS;IAEZC,KAFY;IAGZM,QAAQ,EAAE;EAHE,CAAd;EAMA,OAAOnB,YAAY,CAAC,OAAOoB,YAAP,EAAqBC,UAArB,KAAoC;IACtD,MAAMC,GAAG,GAAG,IAAIvB,KAAK,CAACwB,OAAV,CAAkBZ,OAAlB,EAA2BO,KAA3B,CAAZ;;IACA,IAAI;MACF,IAAIM,GAAG,GAAG,MAAMzB,KAAK,CAACuB,GAAD,EAAMJ,KAAN,CAArB;;MACA,IAAIA,KAAK,CAACO,SAAN,IAAmBD,GAAG,CAACE,MAAJ,KAAe,GAAtC,EAA2C;QACzC;QACA;QACA,MAAMC,eAAe,GAAG1B,IAAI,CAAC0B,eAAL,CAAqB;UAC3CC,UAAU,EAAEV,KAAK,CAACU,UADyB;UAE3CH,SAAS,EAAEP,KAAK,CAACO,SAF0B;UAG3CI,IAAI,EAAEX,KAAK,CAACW;QAH+B,CAArB,CAAxB;QAKA,MAAMC,QAAQ,GAAG,IAAI5B,uBAAJ,CAA4B;UAC3C6B,MAAM,EAAE,CAAC,WAAD,EAAc,MAAd;QADmC,CAA5B,EAEdP,GAAG,CAACQ,IAFU,EAEJL,eAFI,CAAjB,CARyC,CAWzC;QACA;;QACAA,eAAe,CAACM,EAAhB,CAAmB,WAAnB,EAAgCC,CAAC,IAAIJ,QAAQ,CAACK,IAAT,CAAc,WAAd,EAA2BD,CAA3B,CAArC;QACAP,eAAe,CAACM,EAAhB,CAAmB,MAAnB,EAA2BG,CAAC,IAAIN,QAAQ,CAACK,IAAT,CAAc,MAAd,EAAsBC,CAAtB,CAAhC;QACAZ,GAAG,GAAG,IAAIzB,KAAK,CAACsC,QAAV,CAAmBP,QAAnB,EAA6BN,GAA7B,CAAN,CAfyC,CAgBzC;;QACAA,GAAG,CAACQ,IAAJ,CAASM,mBAAT,GAA+B,IAA/B;MACD;;MAEDd,GAAG,CAACT,OAAJ,CAAYE,GAAZ,CAAgB,kBAAhB,EAAoCI,UAApC,EAtBE,CAwBF;MACA;;MACA,MAAMkB,QAAQ,GAAG1C,QAAQ,CAAC0C,QAAT,CAAkBjB,GAAG,CAACU,IAAtB,CAAjB;MACA,MAAMQ,WAAW,GAAGlB,GAAG,CAACmB,MAAJ,KAAe,MAAf,IAChB,CAACF,QADe,KAEf,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBG,QAAhB,CAAyBlB,GAAG,CAACE,MAA7B,KAAwCF,GAAG,CAACE,MAAJ,IAAc,GAFvC,CAApB;;MAIA,IAAIc,WAAJ,EAAiB;QACf,IAAI,OAAO5B,OAAO,CAAC+B,OAAf,KAA2B,UAA/B,EAA2C;UACzC/B,OAAO,CAAC+B,OAAR,CAAgBnB,GAAhB;QACD;;QAED,OAAOJ,YAAY,CAACI,GAAD,CAAnB;MACD;;MAED,OAAOA,GAAP;IACD,CAxCD,CAwCE,OAAOoB,GAAP,EAAY;MACZ,MAAMC,IAAI,GAAID,GAAG,CAACC,IAAJ,KAAa,eAAd,GACTD,GAAG,CAACE,OAAJ,CAAYD,IADH,GAETD,GAAG,CAACC,IAFR,CADY,CAKZ;MACA;MACA;;MACA,MAAME,YAAY,GAAGH,GAAG,CAACE,OAAJ,YAAuB/C,KAAK,CAACsC,QAA7B,IAClB7B,YAAY,CAACkC,QAAb,CAAsBG,IAAtB,KAA+BpC,WAAW,CAACiC,QAAZ,CAAqBE,GAAG,CAACI,IAAzB,CADlC;;MAGA,IAAI1B,GAAG,CAACmB,MAAJ,KAAe,MAAf,IAAyBM,YAA7B,EAA2C;QACzC,MAAMH,GAAN;MACD;;MAED,IAAI,OAAOhC,OAAO,CAAC+B,OAAf,KAA2B,UAA/B,EAA2C;QACzC/B,OAAO,CAAC+B,OAAR,CAAgBC,GAAhB;MACD;;MAED,OAAOxB,YAAY,CAACwB,GAAD,CAAnB;IACD;EACF,CA/DkB,EA+DhBhC,OAAO,CAACqC,KA/DQ,CAAZ,CA+DWC,KA/DX,CA+DkBN,GAAD,IAAS;IAC/B;IACA,IAAIA,GAAG,CAAClB,MAAJ,IAAc,GAAd,IAAqBkB,GAAG,CAACI,IAAJ,KAAa,QAAtC,EAAgD;MAC9C,OAAOJ,GAAP;IACD;;IAED,MAAMA,GAAN;EACD,CAtEM,CAAP;AAuED,CAzFD;;AA2FAO,MAAM,CAACC,OAAP,GAAiB1C,WAAjB"},"metadata":{},"sourceType":"script"}