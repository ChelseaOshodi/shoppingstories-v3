{"ast":null,"code":"const signals = require('./signals.js'); // for testing, expose the process being used\n\n\nmodule.exports = Object.assign(fn => setup(fn), {\n  process\n}); // do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\n\nconst setup = fn => {\n  const {\n    process\n  } = module.exports;\n  const sigListeners = {\n    loaded: false\n  };\n\n  const unload = () => {\n    if (!sigListeners.loaded) {\n      return;\n    }\n\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    }\n\n    process.removeListener('beforeExit', onBeforeExit);\n    sigListeners.loaded = false;\n  };\n\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload();\n    process.kill(process.pid, signalReceived);\n    setTimeout(() => {}, 500);\n  };\n\n  let signalReceived = null;\n\n  const listener = (sig, fn) => () => {\n    signalReceived = sig; // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n\n    unload();\n\n    if (process.listeners(sig).length < 1) {\n      process.once('beforeExit', onBeforeExit);\n    }\n\n    fn({\n      signal: sig\n    });\n  }; // do the actual loading here\n\n\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn);\n    const max = process.getMaxListeners();\n\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const {\n        length\n      } = process.listeners(sig);\n\n      if (length >= max) {\n        process.setMaxListeners(length + 1);\n      }\n\n      process.on(sig, sigListeners[sig]);\n    } catch (er) {}\n  }\n\n  sigListeners.loaded = true;\n  return unload;\n};","map":{"version":3,"names":["signals","require","module","exports","Object","assign","fn","setup","process","sigListeners","loaded","unload","sig","removeListener","er","onBeforeExit","kill","pid","signalReceived","setTimeout","listener","listeners","length","once","signal","max","getMaxListeners","setMaxListeners","on"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/signal-handling.js"],"sourcesContent":["const signals = require('./signals.js')\n\n// for testing, expose the process being used\nmodule.exports = Object.assign(fn => setup(fn), { process })\n\n// do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\nconst setup = fn => {\n  const { process } = module.exports\n\n  const sigListeners = { loaded: false }\n\n  const unload = () => {\n    if (!sigListeners.loaded) {\n      return\n    }\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    }\n    process.removeListener('beforeExit', onBeforeExit)\n    sigListeners.loaded = false\n  }\n\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload()\n    process.kill(process.pid, signalReceived)\n    setTimeout(() => {}, 500)\n  }\n\n  let signalReceived = null\n  const listener = (sig, fn) => () => {\n    signalReceived = sig\n\n    // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n    unload()\n    if (process.listeners(sig).length < 1) {\n      process.once('beforeExit', onBeforeExit)\n    }\n\n    fn({ signal: sig })\n  }\n\n  // do the actual loading here\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn)\n    const max = process.getMaxListeners()\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const { length } = process.listeners(sig)\n      if (length >= max) {\n        process.setMaxListeners(length + 1)\n      }\n      process.on(sig, sigListeners[sig])\n    } catch (er) {}\n  }\n  sigListeners.loaded = true\n\n  return unload\n}\n"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB,C,CAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiBC,MAAM,CAACC,MAAP,CAAcC,EAAE,IAAIC,KAAK,CAACD,EAAD,CAAzB,EAA+B;EAAEE;AAAF,CAA/B,CAAjB,C,CAEA;AACA;AACA;AACA;;AACA,MAAMD,KAAK,GAAGD,EAAE,IAAI;EAClB,MAAM;IAAEE;EAAF,IAAcN,MAAM,CAACC,OAA3B;EAEA,MAAMM,YAAY,GAAG;IAAEC,MAAM,EAAE;EAAV,CAArB;;EAEA,MAAMC,MAAM,GAAG,MAAM;IACnB,IAAI,CAACF,YAAY,CAACC,MAAlB,EAA0B;MACxB;IACD;;IACD,KAAK,MAAME,GAAX,IAAkBZ,OAAlB,EAA2B;MACzB,IAAI;QACFQ,OAAO,CAACK,cAAR,CAAuBD,GAAvB,EAA4BH,YAAY,CAACG,GAAD,CAAxC;MACD,CAFD,CAEE,OAAOE,EAAP,EAAW,CAAE;IAChB;;IACDN,OAAO,CAACK,cAAR,CAAuB,YAAvB,EAAqCE,YAArC;IACAN,YAAY,CAACC,MAAb,GAAsB,KAAtB;EACD,CAXD;;EAaA,MAAMK,YAAY,GAAG,MAAM;IACzB;IACA;IACA;IACA;IACA;IACA;IACAJ,MAAM;IACNH,OAAO,CAACQ,IAAR,CAAaR,OAAO,CAACS,GAArB,EAA0BC,cAA1B;IACAC,UAAU,CAAC,MAAM,CAAE,CAAT,EAAW,GAAX,CAAV;EACD,CAVD;;EAYA,IAAID,cAAc,GAAG,IAArB;;EACA,MAAME,QAAQ,GAAG,CAACR,GAAD,EAAMN,EAAN,KAAa,MAAM;IAClCY,cAAc,GAAGN,GAAjB,CADkC,CAGlC;IACA;;IACAD,MAAM;;IACN,IAAIH,OAAO,CAACa,SAAR,CAAkBT,GAAlB,EAAuBU,MAAvB,GAAgC,CAApC,EAAuC;MACrCd,OAAO,CAACe,IAAR,CAAa,YAAb,EAA2BR,YAA3B;IACD;;IAEDT,EAAE,CAAC;MAAEkB,MAAM,EAAEZ;IAAV,CAAD,CAAF;EACD,CAXD,CA/BkB,CA4ClB;;;EACA,KAAK,MAAMA,GAAX,IAAkBZ,OAAlB,EAA2B;IACzBS,YAAY,CAACG,GAAD,CAAZ,GAAoBQ,QAAQ,CAACR,GAAD,EAAMN,EAAN,CAA5B;IACA,MAAMmB,GAAG,GAAGjB,OAAO,CAACkB,eAAR,EAAZ;;IACA,IAAI;MACF;MACA,MAAM;QAAEJ;MAAF,IAAad,OAAO,CAACa,SAAR,CAAkBT,GAAlB,CAAnB;;MACA,IAAIU,MAAM,IAAIG,GAAd,EAAmB;QACjBjB,OAAO,CAACmB,eAAR,CAAwBL,MAAM,GAAG,CAAjC;MACD;;MACDd,OAAO,CAACoB,EAAR,CAAWhB,GAAX,EAAgBH,YAAY,CAACG,GAAD,CAA5B;IACD,CAPD,CAOE,OAAOE,EAAP,EAAW,CAAE;EAChB;;EACDL,YAAY,CAACC,MAAb,GAAsB,IAAtB;EAEA,OAAOC,MAAP;AACD,CA5DD"},"metadata":{},"sourceType":"script"}