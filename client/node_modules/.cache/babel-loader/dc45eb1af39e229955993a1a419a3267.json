{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst ssri = require('ssri');\n\nconst crypto = require('crypto'); // Corgis are cute. üêïüê∂\n\n\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\n\nconst fetch = require('npm-registry-fetch');\n\nconst _headers = Symbol('_headers');\n\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n\n    this.packumentCache = this.opts.packumentCache || null; // handle case when npm-package-arg guesses wrong.\n\n    if (this.spec.type === 'tag' && this.spec.rawSpec === '' && this.defaultTag !== 'latest') {\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`);\n    }\n\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' + this.spec.escapedName;\n    const parsed = new URL(this.registry);\n    const regKey = `//${parsed.host}${parsed.pathname}`; // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`];\n    } // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n\n  }\n\n  async resolve() {\n    // fetching the manifest sets resolved and (if present) integrity\n    await this.manifest();\n\n    if (!this.resolved) {\n      throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n        package: this.spec.toString()\n      });\n    }\n\n    return this.resolved;\n  }\n\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n\n  async packument() {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) {\n      return this.packumentCache.get(this.packumentUrl);\n    } // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n\n\n    try {\n      const res = await fetch(this.packumentUrl, { ...this.opts,\n        headers: this[_headers](),\n        spec: this.spec,\n        // never check integrity for packuments themselves\n        integrity: null\n      });\n      const packument = await res.json();\n      packument._cached = res.headers.has('x-local-cache');\n      packument._contentLength = +res.headers.get('content-length');\n\n      if (this.packumentCache) {\n        this.packumentCache.set(this.packumentUrl, packument);\n      }\n\n      return packument;\n    } catch (err) {\n      if (this.packumentCache) {\n        this.packumentCache.delete(this.packumentUrl);\n      }\n\n      if (err.code !== 'E404' || this.fullMetadata) {\n        throw err;\n      } // possible that corgis are not supported by this registry\n\n\n      this.fullMetadata = true;\n      return this.packument();\n    }\n  }\n\n  async manifest() {\n    if (this.package) {\n      return this.package;\n    }\n\n    const packument = await this.packument();\n    let mani = await pickManifest(packument, this.spec.fetchSpec, { ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before\n    });\n    mani = rpj.normalize(mani);\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n    // add _resolved and _integrity from dist object\n\n    const {\n      dist\n    } = mani;\n\n    if (dist) {\n      this.resolved = mani._resolved = dist.tarball;\n      mani._from = this.from;\n      const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts\n      }) : null;\n\n      if (distIntegrity) {\n        if (this.integrity && !this.integrity.match(distIntegrity)) {\n          // only bork if they have algos in common.\n          // otherwise we end up breaking if we have saved a sha512\n          // previously for the tarball, but the manifest only\n          // provides a sha1, which is possible for older publishes.\n          // Otherwise, this is almost certainly a case of holding it\n          // wrong, and will result in weird or insecure behavior\n          // later on when building package tree.\n          for (const algo of Object.keys(this.integrity)) {\n            if (distIntegrity[algo]) {\n              throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${this.integrity} but got ${distIntegrity}.`), {\n                code: 'EINTEGRITY'\n              });\n            }\n          }\n        } // made it this far, the integrity is worthwhile.  accept it.\n        // the setter here will take care of merging it into what we already\n        // had.\n\n\n        this.integrity = distIntegrity;\n      }\n    }\n\n    if (this.integrity) {\n      mani._integrity = String(this.integrity);\n\n      if (dist.signatures) {\n        if (this.opts.verifySignatures) {\n          // validate and throw on error, then set _signatures\n          const message = `${mani._id}:${mani._integrity}`;\n\n          for (const signature of dist.signatures) {\n            const publicKey = this.registryKeys && this.registryKeys.filter(key => key.keyid === signature.keyid)[0];\n\n            if (!publicKey) {\n              throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + 'but no corresponding public key can be found'), {\n                code: 'EMISSINGSIGNATUREKEY'\n              });\n            }\n\n            const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n\n            if (!validPublicKey) {\n              throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                code: 'EEXPIREDSIGNATUREKEY'\n              });\n            }\n\n            const verifier = crypto.createVerify('SHA256');\n            verifier.write(message);\n            verifier.end();\n            const valid = verifier.verify(publicKey.pemkey, signature.sig, 'base64');\n\n            if (!valid) {\n              throw Object.assign(new Error(`${mani._id} has an invalid registry signature with ` + `keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {\n                code: 'EINTEGRITYSIGNATURE',\n                keyid: publicKey.keyid,\n                signature: signature.sig,\n                resolved: mani._resolved,\n                integrity: mani._integrity\n              });\n            }\n          }\n\n          mani._signatures = dist.signatures;\n        } else {\n          mani._signatures = dist.signatures;\n        }\n      }\n    }\n\n    this.package = mani;\n    return this.package;\n  }\n\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, { ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n\n}\n\nmodule.exports = RegistryFetcher;","map":{"version":3,"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","removeTrailingSlashes","npa","rpj","pickManifest","ssri","crypto","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","type","rawSpec","defaultTag","name","registry","pickRegistry","packumentUrl","escapedName","parsed","URL","regKey","host","pathname","registryKeys","resolve","manifest","resolved","Object","assign","Error","package","toString","userAgent","process","headers","accept","fullMetadata","packument","has","get","res","integrity","json","_cached","_contentLength","set","err","delete","code","mani","fetchSpec","before","normalize","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","signatures","verifySignatures","message","_id","signature","publicKey","filter","key","keyid","validPublicKey","expires","Date","now","verifier","createVerify","write","end","valid","verify","pemkey","sig","_signatures","pkgid","types","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/pacote/lib/registry.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst crypto = require('crypto')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    // handle case when npm-package-arg guesses wrong.\n    if (this.spec.type === 'tag' &&\n        this.spec.rawSpec === '' &&\n        this.defaultTag !== 'latest') {\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`)\n    }\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' +\n      this.spec.escapedName\n\n    const parsed = new URL(this.registry)\n    const regKey = `//${parsed.host}${parsed.pathname}`\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`]\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  async resolve () {\n    // fetching the manifest sets resolved and (if present) integrity\n    await this.manifest()\n    if (!this.resolved) {\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    }\n    return this.resolved\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) {\n      return this.packumentCache.get(this.packumentUrl)\n    }\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    try {\n      const res = await fetch(this.packumentUrl, {\n        ...this.opts,\n        headers: this[_headers](),\n        spec: this.spec,\n        // never check integrity for packuments themselves\n        integrity: null,\n      })\n      const packument = await res.json()\n      packument._cached = res.headers.has('x-local-cache')\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache) {\n        this.packumentCache.set(this.packumentUrl, packument)\n      }\n      return packument\n    } catch (err) {\n      if (this.packumentCache) {\n        this.packumentCache.delete(this.packumentUrl)\n      }\n      if (err.code !== 'E404' || this.fullMetadata) {\n        throw err\n      }\n      // possible that corgis are not supported by this registry\n      this.fullMetadata = true\n      return this.packument()\n    }\n  }\n\n  async manifest () {\n    if (this.package) {\n      return this.package\n    }\n\n    const packument = await this.packument()\n    let mani = await pickManifest(packument, this.spec.fetchSpec, {\n      ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before,\n    })\n    mani = rpj.normalize(mani)\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n    // add _resolved and _integrity from dist object\n    const { dist } = mani\n    if (dist) {\n      this.resolved = mani._resolved = dist.tarball\n      mani._from = this.from\n      const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n        : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts })\n        : null\n      if (distIntegrity) {\n        if (this.integrity && !this.integrity.match(distIntegrity)) {\n          // only bork if they have algos in common.\n          // otherwise we end up breaking if we have saved a sha512\n          // previously for the tarball, but the manifest only\n          // provides a sha1, which is possible for older publishes.\n          // Otherwise, this is almost certainly a case of holding it\n          // wrong, and will result in weird or insecure behavior\n          // later on when building package tree.\n          for (const algo of Object.keys(this.integrity)) {\n            if (distIntegrity[algo]) {\n              throw Object.assign(new Error(\n                `Integrity checksum failed when using ${algo}: ` +\n                `wanted ${this.integrity} but got ${distIntegrity}.`\n              ), { code: 'EINTEGRITY' })\n            }\n          }\n        }\n        // made it this far, the integrity is worthwhile.  accept it.\n        // the setter here will take care of merging it into what we already\n        // had.\n        this.integrity = distIntegrity\n      }\n    }\n    if (this.integrity) {\n      mani._integrity = String(this.integrity)\n      if (dist.signatures) {\n        if (this.opts.verifySignatures) {\n          // validate and throw on error, then set _signatures\n          const message = `${mani._id}:${mani._integrity}`\n          for (const signature of dist.signatures) {\n            const publicKey = this.registryKeys &&\n              this.registryKeys.filter(key => (key.keyid === signature.keyid))[0]\n            if (!publicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  'but no corresponding public key can be found'\n              ), { code: 'EMISSINGSIGNATUREKEY' })\n            }\n            const validPublicKey =\n              !publicKey.expires || (Date.parse(publicKey.expires) > Date.now())\n            if (!validPublicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  `but the corresponding public key has expired ${publicKey.expires}`\n              ), { code: 'EEXPIREDSIGNATUREKEY' })\n            }\n            const verifier = crypto.createVerify('SHA256')\n            verifier.write(message)\n            verifier.end()\n            const valid = verifier.verify(\n              publicKey.pemkey,\n              signature.sig,\n              'base64'\n            )\n            if (!valid) {\n              throw Object.assign(new Error(\n                  `${mani._id} has an invalid registry signature with ` +\n                  `keyid: ${publicKey.keyid} and signature: ${signature.sig}`\n              ), {\n                code: 'EINTEGRITYSIGNATURE',\n                keyid: publicKey.keyid,\n                signature: signature.sig,\n                resolved: mani._resolved,\n                integrity: mani._integrity,\n              })\n            }\n          }\n          mani._signatures = dist.signatures\n        } else {\n          mani._signatures = dist.signatures\n        }\n      }\n    }\n    this.package = mani\n    return this.package\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}