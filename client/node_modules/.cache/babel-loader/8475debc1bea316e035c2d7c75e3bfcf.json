{"ast":null,"code":"const {\n  dirname,\n  relative,\n  join,\n  resolve,\n  basename\n} = require('path');\n\nconst linkGently = require('./link-gently.js');\n\nconst manTarget = require('./man-target.js');\n\nconst linkMans = _ref => {\n  let {\n    path,\n    pkg,\n    top,\n    force\n  } = _ref;\n  const target = manTarget({\n    path,\n    top\n  });\n\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length) {\n    return Promise.resolve([]);\n  } // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n\n\n  const set = [...new Set(pkg.man.map(man => man ? join('/', man).replace(/\\\\|:/g, '/').slice(1) : null).filter(man => typeof man === 'string'))];\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/);\n\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' + 'Man files must end with a number, ' + 'and optionally a .gz suffix if they are compressed.'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n\n    const stem = parseMan[1];\n    const sxn = parseMan[2];\n    const base = basename(stem);\n    const absFrom = resolve(path, man);\n    /* istanbul ignore if - that unpossible */\n\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n\n    const to = resolve(target, 'man' + sxn, base);\n    const from = relative(dirname(to), absFrom);\n    return linkGently({\n      from,\n      to,\n      path,\n      absFrom,\n      force\n    });\n  }));\n};\n\nmodule.exports = linkMans;","map":{"version":3,"names":["dirname","relative","join","resolve","basename","require","linkGently","manTarget","linkMans","path","pkg","top","force","target","man","Array","isArray","length","Promise","set","Set","map","replace","slice","filter","all","parseMan","match","reject","Object","assign","Error","code","pkgid","_id","stem","sxn","base","absFrom","indexOf","to","from","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/bin-links/lib/link-mans.js"],"sourcesContent":["const { dirname, relative, join, resolve, basename } = require('path')\nconst linkGently = require('./link-gently.js')\nconst manTarget = require('./man-target.js')\n\nconst linkMans = ({ path, pkg, top, force }) => {\n  const target = manTarget({ path, top })\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length) {\n    return Promise.resolve([])\n  }\n\n  // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n  const set = [...new Set(pkg.man.map(man =>\n    man ? join('/', man).replace(/\\\\|:/g, '/').slice(1) : null)\n    .filter(man => typeof man === 'string'))]\n\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' +\n        'Man files must end with a number, ' +\n        'and optionally a .gz suffix if they are compressed.'\n      ), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const stem = parseMan[1]\n    const sxn = parseMan[2]\n    const base = basename(stem)\n    const absFrom = resolve(path, man)\n    /* istanbul ignore if - that unpossible */\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const to = resolve(target, 'man' + sxn, base)\n    const from = relative(dirname(to), absFrom)\n\n    return linkGently({ from, to, path, absFrom, force })\n  }))\n}\n\nmodule.exports = linkMans\n"],"mappings":"AAAA,MAAM;EAAEA,OAAF;EAAWC,QAAX;EAAqBC,IAArB;EAA2BC,OAA3B;EAAoCC;AAApC,IAAiDC,OAAO,CAAC,MAAD,CAA9D;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,iBAAD,CAAzB;;AAEA,MAAMG,QAAQ,GAAG,QAA+B;EAAA,IAA9B;IAAEC,IAAF;IAAQC,GAAR;IAAaC,GAAb;IAAkBC;EAAlB,CAA8B;EAC9C,MAAMC,MAAM,GAAGN,SAAS,CAAC;IAAEE,IAAF;IAAQE;EAAR,CAAD,CAAxB;;EACA,IAAI,CAACE,MAAD,IAAW,CAACH,GAAG,CAACI,GAAhB,IAAuB,CAACC,KAAK,CAACC,OAAN,CAAcN,GAAG,CAACI,GAAlB,CAAxB,IAAkD,CAACJ,GAAG,CAACI,GAAJ,CAAQG,MAA/D,EAAuE;IACrE,OAAOC,OAAO,CAACf,OAAR,CAAgB,EAAhB,CAAP;EACD,CAJ6C,CAM9C;EACA;;;EACA,MAAMgB,GAAG,GAAG,CAAC,GAAG,IAAIC,GAAJ,CAAQV,GAAG,CAACI,GAAJ,CAAQO,GAAR,CAAYP,GAAG,IACrCA,GAAG,GAAGZ,IAAI,CAAC,GAAD,EAAMY,GAAN,CAAJ,CAAeQ,OAAf,CAAuB,OAAvB,EAAgC,GAAhC,EAAqCC,KAArC,CAA2C,CAA3C,CAAH,GAAmD,IADhC,EAErBC,MAFqB,CAEdV,GAAG,IAAI,OAAOA,GAAP,KAAe,QAFR,CAAR,CAAJ,CAAZ;EAIA,OAAOI,OAAO,CAACO,GAAR,CAAYN,GAAG,CAACE,GAAJ,CAAQP,GAAG,IAAI;IAChC,MAAMY,QAAQ,GAAGZ,GAAG,CAACa,KAAJ,CAAU,wBAAV,CAAjB;;IACA,IAAI,CAACD,QAAL,EAAe;MACb,OAAOR,OAAO,CAACU,MAAR,CAAeC,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,6BAC5C,oCAD4C,GAE5C,qDAFkC,CAAd,EAGnB;QACDC,IAAI,EAAE,SADL;QAEDvB,IAFC;QAGDwB,KAAK,EAAEvB,GAAG,CAACwB,GAHV;QAIDpB;MAJC,CAHmB,CAAf,CAAP;IASD;;IAED,MAAMqB,IAAI,GAAGT,QAAQ,CAAC,CAAD,CAArB;IACA,MAAMU,GAAG,GAAGV,QAAQ,CAAC,CAAD,CAApB;IACA,MAAMW,IAAI,GAAGjC,QAAQ,CAAC+B,IAAD,CAArB;IACA,MAAMG,OAAO,GAAGnC,OAAO,CAACM,IAAD,EAAOK,GAAP,CAAvB;IACA;;IACA,IAAIwB,OAAO,CAACC,OAAR,CAAgB9B,IAAhB,MAA0B,CAA9B,EAAiC;MAC/B,OAAOS,OAAO,CAACU,MAAR,CAAeC,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,mBAAV,CAAd,EAA8C;QAClEC,IAAI,EAAE,SAD4D;QAElEvB,IAFkE;QAGlEwB,KAAK,EAAEvB,GAAG,CAACwB,GAHuD;QAIlEpB;MAJkE,CAA9C,CAAf,CAAP;IAMD;;IAED,MAAM0B,EAAE,GAAGrC,OAAO,CAACU,MAAD,EAAS,QAAQuB,GAAjB,EAAsBC,IAAtB,CAAlB;IACA,MAAMI,IAAI,GAAGxC,QAAQ,CAACD,OAAO,CAACwC,EAAD,CAAR,EAAcF,OAAd,CAArB;IAEA,OAAOhC,UAAU,CAAC;MAAEmC,IAAF;MAAQD,EAAR;MAAY/B,IAAZ;MAAkB6B,OAAlB;MAA2B1B;IAA3B,CAAD,CAAjB;EACD,CAhCkB,CAAZ,CAAP;AAiCD,CA7CD;;AA+CA8B,MAAM,CAACC,OAAP,GAAiBnC,QAAjB"},"metadata":{},"sourceType":"script"}