{"ast":null,"code":"// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\nconst required = ['type', 'description', 'default', 'key'];\nconst allowed = ['default', 'defaultDescription', 'deprecated', 'description', 'flatten', 'hint', 'key', 'short', 'type', 'typeDescription', 'usage', 'envExport'];\n\nconst {\n  typeDefs: {\n    semver: {\n      type: semver\n    },\n    Umask: {\n      type: Umask\n    },\n    url: {\n      type: url\n    },\n    path: {\n      type: path\n    }\n  }\n} = require('@npmcli/config');\n\nclass Definition {\n  constructor(key, def) {\n    this.key = key; // if it's set falsey, don't export it, otherwise we do by default\n\n    this.envExport = true;\n    Object.assign(this, def);\n    this.validate();\n\n    if (!this.defaultDescription) {\n      this.defaultDescription = describeValue(this.default);\n    }\n\n    if (!this.typeDescription) {\n      this.typeDescription = describeType(this.type);\n    } // hint is only used for non-boolean values\n\n\n    if (!this.hint) {\n      if (this.type === Number) {\n        this.hint = '<number>';\n      } else {\n        this.hint = `<${this.key}>`;\n      }\n    }\n\n    if (!this.usage) {\n      this.usage = describeUsage(this);\n    }\n  }\n\n  validate() {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req)) {\n        throw new Error(`config lacks ${req}: ${this.key}`);\n      }\n    }\n\n    if (!this.key) {\n      throw new Error(`config lacks key: ${this.key}`);\n    }\n\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field)) {\n        throw new Error(`config defines unknown field ${field}: ${this.key}`);\n      }\n    }\n  } // a textual description of this config, suitable for help output\n\n\n  describe() {\n    const description = unindent(this.description);\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`;\n    const deprecated = !this.deprecated ? '' : `* DEPRECATED: ${unindent(this.deprecated)}\\n`;\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`);\n  }\n\n}\n\nconst describeUsage = def => {\n  let key = ''; // Single type\n\n  if (!Array.isArray(def.type)) {\n    if (def.short) {\n      key = `-${def.short}|`;\n    }\n\n    if (def.type === Boolean && def.default !== false) {\n      key = `${key}--no-${def.key}`;\n    } else {\n      key = `${key}--${def.key}`;\n    }\n\n    if (def.type !== Boolean) {\n      key = `${key} ${def.hint}`;\n    }\n\n    return key;\n  }\n\n  key = `--${def.key}`;\n\n  if (def.short) {\n    key = `-${def.short}|--${def.key}`;\n  } // Multiple types\n\n\n  let types = def.type;\n  const multiple = types.includes(Array);\n  const bool = types.includes(Boolean); // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean);\n\n  if (!types.length) {\n    return key;\n  }\n\n  let description;\n\n  if (!types.some(t => typeof t !== 'string')) {\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`;\n  } else {\n    // Generic values, use hint\n    description = def.hint;\n  }\n\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`;\n  }\n\n  const usage = `${key} ${description}`;\n\n  if (multiple) {\n    return `${usage} [${usage} ...]`;\n  } else {\n    return usage;\n  }\n};\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type.filter(t => t !== Array).map(t => describeType(t)); // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n\n    const last = descriptions.length > 1 ? [descriptions.pop()] : [];\n    const oxford = descriptions.length > 1 ? ', or ' : ' or ';\n    const words = [descriptions.join(', ')].concat(last).join(oxford);\n    const multiple = type.includes(Array) ? ' (can be set multiple times)' : '';\n    return `${words}${multiple}`;\n  } // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n\n\n  switch (type) {\n    case String:\n      return 'String';\n\n    case Number:\n      return 'Number';\n\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)';\n\n    case Boolean:\n      return 'Boolean';\n\n    case Date:\n      return 'Date';\n\n    case path:\n      return 'Path';\n\n    case semver:\n      return 'SemVer string';\n\n    case url:\n      return 'URL';\n\n    default:\n      return describeValue(type);\n  }\n}; // if it's a string, quote it.  otherwise, just cast to string.\n\n\nconst describeValue = val => typeof val === 'string' ? JSON.stringify(val) : String(val);\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/);\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim();\n};\n\nconst wrap = s => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5;\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop();\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' ';\n    return left + join + right;\n  });\n};\n\nconst wrapAll = s => {\n  let inCodeBlock = false;\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```');\n      return block;\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.slice(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ');\n      }).join('\\n* ');\n    } else {\n      return wrap(block);\n    }\n  }).join('\\n\\n');\n};\n\nmodule.exports = Definition;","map":{"version":3,"names":["required","allowed","typeDefs","semver","type","Umask","url","path","require","Definition","constructor","key","def","envExport","Object","assign","validate","defaultDescription","describeValue","default","typeDescription","describeType","hint","Number","usage","describeUsage","req","prototype","hasOwnProperty","call","Error","field","keys","includes","describe","description","unindent","noEnvExport","deprecated","wrapAll","Array","isArray","short","Boolean","types","multiple","bool","filter","t","length","some","d","join","descriptions","map","last","pop","oxford","words","concat","String","Date","val","JSON","stringify","s","match","trim","split","wrap","cols","Math","min","max","process","stdout","columns","reduce","left","right","inCodeBlock","block","startsWith","endsWith","charAt","slice","li","replace","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/utils/config/definition.js"],"sourcesContent":["// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\n\nconst required = ['type', 'description', 'default', 'key']\n\nconst allowed = [\n  'default',\n  'defaultDescription',\n  'deprecated',\n  'description',\n  'flatten',\n  'hint',\n  'key',\n  'short',\n  'type',\n  'typeDescription',\n  'usage',\n  'envExport',\n]\n\nconst {\n  typeDefs: {\n    semver: { type: semver },\n    Umask: { type: Umask },\n    url: { type: url },\n    path: { type: path },\n  },\n} = require('@npmcli/config')\n\nclass Definition {\n  constructor (key, def) {\n    this.key = key\n    // if it's set falsey, don't export it, otherwise we do by default\n    this.envExport = true\n    Object.assign(this, def)\n    this.validate()\n    if (!this.defaultDescription) {\n      this.defaultDescription = describeValue(this.default)\n    }\n    if (!this.typeDescription) {\n      this.typeDescription = describeType(this.type)\n    }\n    // hint is only used for non-boolean values\n    if (!this.hint) {\n      if (this.type === Number) {\n        this.hint = '<number>'\n      } else {\n        this.hint = `<${this.key}>`\n      }\n    }\n    if (!this.usage) {\n      this.usage = describeUsage(this)\n    }\n  }\n\n  validate () {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req)) {\n        throw new Error(`config lacks ${req}: ${this.key}`)\n      }\n    }\n    if (!this.key) {\n      throw new Error(`config lacks key: ${this.key}`)\n    }\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field)) {\n        throw new Error(`config defines unknown field ${field}: ${this.key}`)\n      }\n    }\n  }\n\n  // a textual description of this config, suitable for help output\n  describe () {\n    const description = unindent(this.description)\n    const noEnvExport = this.envExport\n      ? ''\n      : `\nThis value is not exported to the environment for child processes.\n`\n    const deprecated = !this.deprecated ? '' : `* DEPRECATED: ${unindent(this.deprecated)}\\n`\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`)\n  }\n}\n\nconst describeUsage = def => {\n  let key = ''\n\n  // Single type\n  if (!Array.isArray(def.type)) {\n    if (def.short) {\n      key = `-${def.short}|`\n    }\n\n    if (def.type === Boolean && def.default !== false) {\n      key = `${key}--no-${def.key}`\n    } else {\n      key = `${key}--${def.key}`\n    }\n\n    if (def.type !== Boolean) {\n      key = `${key} ${def.hint}`\n    }\n\n    return key\n  }\n\n  key = `--${def.key}`\n  if (def.short) {\n    key = `-${def.short}|--${def.key}`\n  }\n\n  // Multiple types\n  let types = def.type\n  const multiple = types.includes(Array)\n  const bool = types.includes(Boolean)\n\n  // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean)\n\n  if (!types.length) {\n    return key\n  }\n\n  let description\n  if (!types.some(t => typeof t !== 'string')) {\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`\n  } else {\n    // Generic values, use hint\n    description = def.hint\n  }\n\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`\n  }\n\n  const usage = `${key} ${description}`\n  if (multiple) {\n    return `${usage} [${usage} ...]`\n  } else {\n    return usage\n  }\n}\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type.filter(t => t !== Array).map(t => describeType(t))\n\n    // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n    const last = descriptions.length > 1 ? [descriptions.pop()] : []\n    const oxford = descriptions.length > 1 ? ', or ' : ' or '\n    const words = [descriptions.join(', ')].concat(last).join(oxford)\n    const multiple = type.includes(Array) ? ' (can be set multiple times)' : ''\n    return `${words}${multiple}`\n  }\n\n  // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n  switch (type) {\n    case String:\n      return 'String'\n    case Number:\n      return 'Number'\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)'\n    case Boolean:\n      return 'Boolean'\n    case Date:\n      return 'Date'\n    case path:\n      return 'Path'\n    case semver:\n      return 'SemVer string'\n    case url:\n      return 'URL'\n    default:\n      return describeValue(type)\n  }\n}\n\n// if it's a string, quote it.  otherwise, just cast to string.\nconst describeValue = val => (typeof val === 'string' ? JSON.stringify(val) : String(val))\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/)\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim()\n}\n\nconst wrap = s => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5\n  return unindent(s)\n    .split(/[ \\n]+/)\n    .reduce((left, right) => {\n      const last = left.split('\\n').pop()\n      const join = last.length && last.length + right.length > cols ? '\\n' : ' '\n      return left + join + right\n    })\n}\n\nconst wrapAll = s => {\n  let inCodeBlock = false\n  return s\n    .split('\\n\\n')\n    .map(block => {\n      if (inCodeBlock || block.startsWith('```')) {\n        inCodeBlock = !block.endsWith('```')\n        return block\n      }\n\n      if (block.charAt(0) === '*') {\n        return (\n          '* ' +\n          block\n            .slice(1)\n            .trim()\n            .split('\\n* ')\n            .map(li => {\n              return wrap(li).replace(/\\n/g, '\\n  ')\n            })\n            .join('\\n* ')\n        )\n      } else {\n        return wrap(block)\n      }\n    })\n    .join('\\n\\n')\n}\n\nmodule.exports = Definition\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}