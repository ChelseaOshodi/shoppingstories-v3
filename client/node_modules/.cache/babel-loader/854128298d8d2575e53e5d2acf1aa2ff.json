{"ast":null,"code":"// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst rpj = require('read-package-json-fast');\n\nconst binLinks = require('bin-links');\n\nconst runScript = require('@npmcli/run-script');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\n\nconst log = require('proc-log');\n\nconst boolEnv = b => b ? '1' : '';\n\nconst sortNodes = (a, b) => a.depth - b.depth || localeCompare(a.path, b.path);\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _build = Symbol('build');\n\nconst _loadDefaultNodes = Symbol('loadDefaultNodes');\n\nconst _retrieveNodesByType = Symbol('retrieveNodesByType');\n\nconst _resetQueues = Symbol('resetQueues');\n\nconst _rebuildBundle = Symbol('rebuildBundle');\n\nconst _ignoreScripts = Symbol('ignoreScripts');\n\nconst _binLinks = Symbol('binLinks');\n\nconst _oldMeta = Symbol('oldMeta');\n\nconst _createBinLinks = Symbol('createBinLinks');\n\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure');\n\nconst _linkAllBins = Symbol('linkAllBins');\n\nconst _runScripts = Symbol('runScripts');\n\nconst _buildQueues = Symbol('buildQueues');\n\nconst _addToBuildSet = Symbol('addToBuildSet');\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _queues = Symbol('queues');\n\nconst _scriptShell = Symbol('scriptShell');\n\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot');\n\nconst _workspacesEnabled = Symbol.for('workspacesEnabled');\n\nconst _force = Symbol.for('force');\n\nconst _global = Symbol.for('global'); // defined by reify mixin\n\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _trashList = Symbol.for('trashList');\n\nmodule.exports = cls => class Builder extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true\n    } = options;\n    this.scriptsRun = new Set();\n    this[_binLinks] = binLinks;\n    this[_ignoreScripts] = !!ignoreScripts;\n    this[_scriptShell] = scriptShell;\n    this[_rebuildBundle] = !!rebuildBundle;\n\n    this[_resetQueues]();\n\n    this[_oldMeta] = null;\n  }\n\n  async rebuild() {\n    let {\n      nodes,\n      handleOptionalFailure = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return;\n    } // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n\n\n    this[_doHandleOptionalFailure] = handleOptionalFailure;\n\n    if (!nodes) {\n      nodes = await this[_loadDefaultNodes]();\n    } // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n\n\n    process.emit('time', 'build');\n\n    const {\n      depNodes,\n      linkNodes\n    } = this[_retrieveNodesByType](nodes); // build regular deps\n\n\n    await this[_build](depNodes, {}); // build link deps\n\n    if (linkNodes.size) {\n      this[_resetQueues]();\n\n      await this[_build](linkNodes, {\n        type: 'links'\n      });\n    }\n\n    process.emit('timeEnd', 'build');\n  } // if we don't have a set of nodes, then just rebuild\n  // the actual tree on disk.\n\n\n  async [_loadDefaultNodes]() {\n    let nodes;\n    const tree = await this.loadActual();\n    let filterSet;\n\n    if (!this[_workspacesEnabled]) {\n      filterSet = this.excludeWorkspacesDependencySet(tree);\n      nodes = tree.inventory.filter(node => filterSet.has(node) || node.isProjectRoot);\n    } else if (this[_workspaces] && this[_workspaces].length) {\n      filterSet = this.workspaceDependencySet(tree, this[_workspaces], this[_includeWorkspaceRoot]);\n      nodes = tree.inventory.filter(node => filterSet.has(node));\n    } else {\n      nodes = tree.inventory.values();\n    }\n\n    return nodes;\n  }\n\n  [_retrieveNodesByType](nodes) {\n    const depNodes = new Set();\n    const linkNodes = new Set();\n\n    for (const node of nodes) {\n      if (node.isLink) {\n        linkNodes.add(node);\n      } else {\n        depNodes.add(node);\n      }\n    } // deduplicates link nodes and their targets, avoids\n    // calling lifecycle scripts twice when running `npm rebuild`\n    // ref: https://github.com/npm/cli/issues/2905\n    //\n    // we avoid doing so if global=true since `bin-links` relies\n    // on having the target nodes available in global mode.\n\n\n    if (!this[_global]) {\n      for (const node of linkNodes) {\n        depNodes.delete(node.target);\n      }\n    }\n\n    return {\n      depNodes,\n      linkNodes\n    };\n  }\n\n  [_resetQueues]() {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: []\n    };\n  }\n\n  async [_build](nodes, _ref) {\n    let {\n      type = 'deps'\n    } = _ref;\n    process.emit('time', `build:${type}`);\n    await this[_buildQueues](nodes);\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall');\n    } // links should run prepare scripts and only link bins after that\n\n\n    if (type === 'links') {\n      await this[_runScripts]('prepare');\n    }\n\n    if (this[_binLinks]) {\n      await this[_linkAllBins]();\n    }\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install');\n      await this[_runScripts]('postinstall');\n    }\n\n    process.emit('timeEnd', `build:${type}`);\n  }\n\n  async [_buildQueues](nodes) {\n    process.emit('time', 'build:queue');\n    const set = new Set();\n    const promises = [];\n\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set)); // if it has bundle deps, add those too, if rebuildBundle\n\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies;\n\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle\n          });\n        }\n      }\n    }\n\n    await promiseAllRejectLate(promises); // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n\n    const queue = [...set].sort(sortNodes);\n\n    for (const node of queue) {\n      const {\n        package: {\n          bin,\n          scripts = {}\n        }\n      } = node.target;\n      const {\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      } = scripts;\n      const tests = {\n        bin,\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      };\n\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node);\n        }\n      }\n    }\n\n    process.emit('timeEnd', 'build:queue');\n  }\n\n  async [_checkBins](node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return;\n    }\n\n    const {\n      path,\n      package: pkg\n    } = node;\n    await binLinks.checkBins({\n      pkg,\n      path,\n      top: true,\n      global: true\n    });\n  }\n\n  async [_addToBuildSet](node, set) {\n    let refreshed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (set.has(node)) {\n      return;\n    }\n\n    if (this[_oldMeta] === null) {\n      const {\n        root: {\n          meta\n        }\n      } = node;\n      this[_oldMeta] = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    }\n\n    const {\n      package: pkg,\n      hasInstallScript\n    } = node.target;\n    const {\n      gypfile,\n      bin,\n      scripts = {}\n    } = pkg;\n    const {\n      preinstall,\n      install,\n      postinstall,\n      prepare\n    } = scripts;\n    const anyScript = preinstall || install || postinstall || prepare;\n\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node);\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}));\n      set.delete(node);\n      const {\n        scripts = {}\n      } = pkg;\n      node.package.scripts = scripts;\n      return this[_addToBuildSet](node, set, true);\n    } // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n\n\n    const isGyp = gypfile !== false && !install && !preinstall && (await isNodeGypPackage(node.path));\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node);\n      }\n\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript;\n        node.package.scripts = scripts;\n      }\n\n      set.add(node);\n    }\n  }\n\n  async [_runScripts](event) {\n    const queue = this[_queues][event];\n\n    if (!queue.length) {\n      return;\n    }\n\n    process.emit('time', `build:run:${event}`);\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe';\n    const limit = this.options.foregroundScripts ? 1 : undefined;\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location\n      } = node.target; // skip any that we know we'll be deleting\n\n      if (this[_trashList].has(path)) {\n        return;\n      }\n\n      const timer = `build:run:${event}:${location}`;\n      process.emit('time', timer);\n      log.info('run', pkg._id, event, location, pkg.scripts[event]);\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)\n      };\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell]\n      };\n      const p = runScript(runOpts).catch(er => {\n        const {\n          code,\n          signal\n        } = er;\n        log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n        throw er;\n      }).then(_ref2 => {\n        let {\n          args,\n          code,\n          signal,\n          stdout,\n          stderr\n        } = _ref2;\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr\n        });\n        log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n      });\n      await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n      process.emit('timeEnd', timer);\n    }), limit);\n    process.emit('timeEnd', `build:run:${event}`);\n  }\n\n  async [_linkAllBins]() {\n    const queue = this[_queues].bin;\n\n    if (!queue.length) {\n      return;\n    }\n\n    process.emit('time', 'build:link');\n    const promises = []; // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node));\n    }\n\n    await promiseAllRejectLate(promises);\n    process.emit('timeEnd', 'build:link');\n  }\n\n  async [_createBinLinks](node) {\n    if (this[_trashList].has(node.path)) {\n      return;\n    }\n\n    process.emit('time', `build:link:${node.location}`);\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop\n    });\n    await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n    process.emit('timeEnd', `build:link:${node.location}`);\n  }\n\n};","map":{"version":3,"names":["localeCompare","require","depth","dfwalk","promiseAllRejectLate","rpj","binLinks","runScript","promiseCallLimit","resolve","isNodeGypPackage","defaultGypInstallScript","log","boolEnv","b","sortNodes","a","path","_workspaces","Symbol","for","_build","_loadDefaultNodes","_retrieveNodesByType","_resetQueues","_rebuildBundle","_ignoreScripts","_binLinks","_oldMeta","_createBinLinks","_doHandleOptionalFailure","_linkAllBins","_runScripts","_buildQueues","_addToBuildSet","_checkBins","_queues","_scriptShell","_includeWorkspaceRoot","_workspacesEnabled","_force","_global","_handleOptionalFailure","_trashList","module","exports","cls","Builder","constructor","options","ignoreScripts","scriptShell","rebuildBundle","scriptsRun","Set","rebuild","nodes","handleOptionalFailure","process","emit","depNodes","linkNodes","size","type","tree","loadActual","filterSet","excludeWorkspacesDependencySet","inventory","filter","node","has","isProjectRoot","length","workspaceDependencySet","values","isLink","add","delete","target","preinstall","install","postinstall","prepare","bin","set","promises","push","bd","package","bundleDependencies","leave","getChildren","children","inBundle","queue","sort","scripts","tests","key","Object","entries","globalTop","pkg","checkBins","top","global","refreshed","root","meta","loadedFromDisk","originalLockfileVersion","hasInstallScript","gypfile","anyScript","catch","isGyp","event","stdio","foregroundScripts","limit","undefined","map","integrity","resolved","optional","peer","dev","devOptional","location","timer","info","_id","env","npm_package_resolved","npm_package_integrity","npm_package_json","npm_package_optional","npm_package_dev","npm_package_peer","npm_package_dev_optional","runOpts","stdioString","p","er","code","signal","then","args","stdout","stderr","cmd","isTop","force"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/rebuild.js"],"sourcesContent":["// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst { depth: dfwalk } = require('treeverse')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst rpj = require('read-package-json-fast')\nconst binLinks = require('bin-links')\nconst runScript = require('@npmcli/run-script')\nconst promiseCallLimit = require('promise-call-limit')\nconst { resolve } = require('path')\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript,\n} = require('@npmcli/node-gyp')\nconst log = require('proc-log')\n\nconst boolEnv = b => b ? '1' : ''\nconst sortNodes = (a, b) =>\n  (a.depth - b.depth) || localeCompare(a.path, b.path)\n\nconst _workspaces = Symbol.for('workspaces')\nconst _build = Symbol('build')\nconst _loadDefaultNodes = Symbol('loadDefaultNodes')\nconst _retrieveNodesByType = Symbol('retrieveNodesByType')\nconst _resetQueues = Symbol('resetQueues')\nconst _rebuildBundle = Symbol('rebuildBundle')\nconst _ignoreScripts = Symbol('ignoreScripts')\nconst _binLinks = Symbol('binLinks')\nconst _oldMeta = Symbol('oldMeta')\nconst _createBinLinks = Symbol('createBinLinks')\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure')\nconst _linkAllBins = Symbol('linkAllBins')\nconst _runScripts = Symbol('runScripts')\nconst _buildQueues = Symbol('buildQueues')\nconst _addToBuildSet = Symbol('addToBuildSet')\nconst _checkBins = Symbol.for('checkBins')\nconst _queues = Symbol('queues')\nconst _scriptShell = Symbol('scriptShell')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\n\nconst _force = Symbol.for('force')\nconst _global = Symbol.for('global')\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _trashList = Symbol.for('trashList')\n\nmodule.exports = cls => class Builder extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true,\n    } = options\n\n    this.scriptsRun = new Set()\n    this[_binLinks] = binLinks\n    this[_ignoreScripts] = !!ignoreScripts\n    this[_scriptShell] = scriptShell\n    this[_rebuildBundle] = !!rebuildBundle\n    this[_resetQueues]()\n    this[_oldMeta] = null\n  }\n\n  async rebuild ({ nodes, handleOptionalFailure = false } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return\n    }\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure\n\n    if (!nodes) {\n      nodes = await this[_loadDefaultNodes]()\n    }\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build')\n\n    const {\n      depNodes,\n      linkNodes,\n    } = this[_retrieveNodesByType](nodes)\n\n    // build regular deps\n    await this[_build](depNodes, {})\n\n    // build link deps\n    if (linkNodes.size) {\n      this[_resetQueues]()\n      await this[_build](linkNodes, { type: 'links' })\n    }\n\n    process.emit('timeEnd', 'build')\n  }\n\n  // if we don't have a set of nodes, then just rebuild\n  // the actual tree on disk.\n  async [_loadDefaultNodes] () {\n    let nodes\n    const tree = await this.loadActual()\n    let filterSet\n    if (!this[_workspacesEnabled]) {\n      filterSet = this.excludeWorkspacesDependencySet(tree)\n      nodes = tree.inventory.filter(node =>\n        filterSet.has(node) || node.isProjectRoot\n      )\n    } else if (this[_workspaces] && this[_workspaces].length) {\n      filterSet = this.workspaceDependencySet(\n        tree,\n        this[_workspaces],\n        this[_includeWorkspaceRoot]\n      )\n      nodes = tree.inventory.filter(node => filterSet.has(node))\n    } else {\n      nodes = tree.inventory.values()\n    }\n    return nodes\n  }\n\n  [_retrieveNodesByType] (nodes) {\n    const depNodes = new Set()\n    const linkNodes = new Set()\n\n    for (const node of nodes) {\n      if (node.isLink) {\n        linkNodes.add(node)\n      } else {\n        depNodes.add(node)\n      }\n    }\n\n    // deduplicates link nodes and their targets, avoids\n    // calling lifecycle scripts twice when running `npm rebuild`\n    // ref: https://github.com/npm/cli/issues/2905\n    //\n    // we avoid doing so if global=true since `bin-links` relies\n    // on having the target nodes available in global mode.\n    if (!this[_global]) {\n      for (const node of linkNodes) {\n        depNodes.delete(node.target)\n      }\n    }\n\n    return {\n      depNodes,\n      linkNodes,\n    }\n  }\n\n  [_resetQueues] () {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: [],\n    }\n  }\n\n  async [_build] (nodes, { type = 'deps' }) {\n    process.emit('time', `build:${type}`)\n\n    await this[_buildQueues](nodes)\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall')\n    }\n\n    // links should run prepare scripts and only link bins after that\n    if (type === 'links') {\n      await this[_runScripts]('prepare')\n    }\n    if (this[_binLinks]) {\n      await this[_linkAllBins]()\n    }\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install')\n      await this[_runScripts]('postinstall')\n    }\n\n    process.emit('timeEnd', `build:${type}`)\n  }\n\n  async [_buildQueues] (nodes) {\n    process.emit('time', 'build:queue')\n    const set = new Set()\n\n    const promises = []\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set))\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle,\n          })\n        }\n      }\n    }\n    await promiseAllRejectLate(promises)\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes)\n\n    for (const node of queue) {\n      const { package: { bin, scripts = {} } } = node.target\n      const { preinstall, install, postinstall, prepare } = scripts\n      const tests = { bin, preinstall, install, postinstall, prepare }\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node)\n        }\n      }\n    }\n    process.emit('timeEnd', 'build:queue')\n  }\n\n  async [_checkBins] (node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return\n    }\n    const { path, package: pkg } = node\n    await binLinks.checkBins({ pkg, path, top: true, global: true })\n  }\n\n  async [_addToBuildSet] (node, set, refreshed = false) {\n    if (set.has(node)) {\n      return\n    }\n\n    if (this[_oldMeta] === null) {\n      const { root: { meta } } = node\n      this[_oldMeta] = meta && meta.loadedFromDisk &&\n        !(meta.originalLockfileVersion >= 2)\n    }\n\n    const { package: pkg, hasInstallScript } = node.target\n    const { gypfile, bin, scripts = {} } = pkg\n\n    const { preinstall, install, postinstall, prepare } = scripts\n    const anyScript = preinstall || install || postinstall || prepare\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node)\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}))\n      set.delete(node)\n\n      const { scripts = {} } = pkg\n      node.package.scripts = scripts\n      return this[_addToBuildSet](node, set, true)\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false &&\n      !install &&\n      !preinstall &&\n      await isNodeGypPackage(node.path)\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node)\n      }\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript\n        node.package.scripts = scripts\n      }\n      set.add(node)\n    }\n  }\n\n  async [_runScripts] (event) {\n    const queue = this[_queues][event]\n\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', `build:run:${event}`)\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n    const limit = this.options.foregroundScripts ? 1 : undefined\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location,\n      } = node.target\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path)) {\n        return\n      }\n\n      const timer = `build:run:${event}:${location}`\n      process.emit('time', timer)\n      log.info('run', pkg._id, event, location, pkg.scripts[event])\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional:\n          boolEnv(devOptional && !dev && !optional),\n      }\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell],\n      }\n      const p = runScript(runOpts).catch(er => {\n        const { code, signal } = er\n        log.info('run', pkg._id, event, { code, signal })\n        throw er\n      }).then(({ args, code, signal, stdout, stderr }) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr,\n        })\n        log.info('run', pkg._id, event, { code, signal })\n      })\n\n      await (this[_doHandleOptionalFailure]\n        ? this[_handleOptionalFailure](node, p)\n        : p)\n\n      process.emit('timeEnd', timer)\n    }), limit)\n    process.emit('timeEnd', `build:run:${event}`)\n  }\n\n  async [_linkAllBins] () {\n    const queue = this[_queues].bin\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', 'build:link')\n    const promises = []\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node))\n    }\n\n    await promiseAllRejectLate(promises)\n    process.emit('timeEnd', 'build:link')\n  }\n\n  async [_createBinLinks] (node) {\n    if (this[_trashList].has(node.path)) {\n      return\n    }\n\n    process.emit('time', `build:link:${node.location}`)\n\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop,\n    })\n\n    await (this[_doHandleOptionalFailure]\n      ? this[_handleOptionalFailure](node, p)\n      : p)\n\n    process.emit('timeEnd', `build:link:${node.location}`)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}