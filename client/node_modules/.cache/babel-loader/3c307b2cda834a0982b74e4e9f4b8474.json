{"ast":null,"code":"// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst log = require('proc-log');\n\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\n\nconst CanPlaceDep = require('./can-place-dep.js');\n\nconst {\n  KEEP,\n  CONFLICT\n} = CanPlaceDep;\n\nconst debug = require('./debug.js');\n\nconst Link = require('./link.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst peerEntrySets = require('./peer-entry-sets.js');\n\nclass PlaceDep {\n  constructor(options) {\n    const {\n      dep,\n      edge,\n      parent = null\n    } = options;\n    this.name = edge.name;\n    this.dep = dep;\n    this.edge = edge;\n    this.canPlace = null;\n    this.target = null;\n    this.placed = null; // inherit all these fields from the parent to ensure consistency.\n\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      installLinks,\n      legacyPeerDeps,\n      globalStyle\n    } = parent || options;\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      installLinks,\n      legacyPeerDeps,\n      globalStyle\n    });\n    this.children = [];\n    this.parent = parent;\n    this.peerConflict = null;\n    this.needEvaluation = new Set();\n    this.checks = new Map();\n    this.place();\n  }\n\n  place() {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks\n    } = this; // nothing to do if the edge is fine as it is\n\n    if (edge.to && !edge.error && !explicitRequest && !updateNames.includes(edge.name) && !this.isVulnerable(edge.to)) {\n      return;\n    } // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n\n\n    const start = this.getStartNode();\n    let canPlace = null;\n    let canPlaceSelf = null;\n\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name);\n\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue;\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest\n      });\n      checks.set(target, cpd); // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd;\n      } // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n\n\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd;\n      } else {\n        break;\n      } // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n\n\n      if (dep.errors.length) {\n        break;\n      } // nest packages like npm v1 and v2\n      // very disk-inefficient\n\n\n      if (legacyBundling) {\n        break;\n      } // when installing globally, or just in global style, we never place\n      // deps above the first level.\n\n\n      if (globalStyle) {\n        const rp = target.resolveParent;\n\n        if (rp && rp.isProjectRoot) {\n          break;\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf\n    });\n    this.current = edge.to; // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict();\n      } // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n\n\n      if (!canPlaceSelf) {\n        this.warnPeerConflict();\n        return;\n      }\n\n      this.canPlace = canPlaceSelf;\n    } // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n\n\n    this.placeInTree();\n  }\n\n  placeInTree() {\n    const {\n      dep,\n      canPlace,\n      edge\n    } = this;\n    /* istanbul ignore next */\n\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree');\n      });\n      return;\n    }\n\n    const {\n      target\n    } = canPlace;\n    log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description, `for: ${this.edge.from.package._id || this.edge.from.location}`, `want: ${edge.spec || '*'}`);\n    const placementType = canPlace.canPlace === CONFLICT ? canPlace.canPlaceSelf : canPlace.canPlace; // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n\n    if (placementType === KEEP) {\n      // this was a peerConflicted peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict();\n      } // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n\n\n      this.pruneDedupable(target);\n      return;\n    } // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n\n\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({\n          parent: target,\n          target: p\n        });\n        return;\n      }\n    } // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n\n    const virtualRoot = dep.parent;\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.overrides ? {\n        overrides: dep.overrides\n      } : {}),\n      ...(dep.isLink ? {\n        target: dep.target,\n        realpath: dep.realpath\n      } : {})\n    });\n    this.oldDep = target.children.get(this.name);\n\n    if (this.oldDep) {\n      this.replaceOldDep();\n    } else {\n      this.placed.parent = target;\n    } // if it's a peerConflicted peer dep, warn about it\n\n\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict();\n    } // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n\n\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false);\n    } // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n\n\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false); // only walk the direct children of the ones we kept\n\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false);\n          }\n        }\n      }\n    } // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n\n\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.peerConflicted) {\n        continue;\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name); // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n\n      if (!peer) {\n        continue;\n      } // peerConflicted peerEdge, just accept what's there already\n\n\n      if (!peer.satisfies(peerEdge)) {\n        continue;\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge\n      }));\n    }\n  }\n\n  replaceOldDep() {\n    const target = this.oldDep.parent; // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n\n    const oldDeps = [];\n\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n    } // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n\n\n    const prunePeerSets = [];\n\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) || !edge.peer || edge.from.parent !== target || edge.peerConflicted) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue;\n      }\n\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as peerConflicted and warned about.  If the entryEdge comes in from\n        // the root or a workspace, then we have to leave it alone, and in that\n        // case, it will have already warned or crashed by getting to this point\n        const entryNode = entryEdge.to;\n        const deepestTarget = deepestNestingTarget(entryNode);\n\n        if (deepestTarget !== target && !(entryEdge.from.isProjectRoot || entryEdge.from.isWorkspace)) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.peerConflicted;\n          }));\n        } else {\n          this.warnPeerConflict(edge, this.dep);\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep);\n    this.pruneForReplacement(this.placed, oldDeps);\n\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from);\n      }\n\n      dep.root = null;\n    }\n  }\n\n  pruneForReplacement(node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n\n      for (const dep of set) {\n        invalidDeps.add(dep);\n      }\n    } // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n\n\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid); // now just delete whatever's left, because it's junk\n\n    for (const dep of deps) {\n      dep.root = null;\n    }\n  } // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n\n\n  pruneDedupable(node) {\n    let descend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid);\n\n      for (const node of deps) {\n        node.root = null;\n      }\n\n      return;\n    }\n\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location);\n\n      const children = [...node.children.values()].sort(nodeSort);\n\n      for (const child of children) {\n        this.pruneDedupable(child);\n      }\n\n      const fsChildren = [...node.fsChildren].sort(nodeSort);\n\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort);\n\n        for (const child of children) {\n          this.pruneDedupable(child);\n        }\n      }\n    }\n  }\n\n  get conflictOk() {\n    return this.force || !this.isMine && !this.strictPeerDeps;\n  }\n\n  get isMine() {\n    const {\n      edge\n    } = this.top;\n    const {\n      from: node\n    } = edge;\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true;\n    }\n\n    if (!edge.peer) {\n      return false;\n    } // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n\n\n    let hasPeerEdges = false;\n\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true;\n        continue;\n      }\n\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true;\n      }\n    }\n\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  warnPeerConflict(edge, dep) {\n    edge = edge || this.edge;\n    dep = dep || this.dep;\n    edge.peerConflicted = true;\n    const expl = this.explainPeerConflict(edge, dep);\n    log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  }\n\n  failPeerConflict(edge, dep) {\n    edge = edge || this.top.edge;\n    dep = dep || this.top.dep;\n    const expl = this.explainPeerConflict(edge, dep);\n    throw Object.assign(new Error('could not resolve'), expl);\n  }\n\n  explainPeerConflict(edge, dep) {\n    const {\n      from: node\n    } = edge;\n    const curNode = node.resolve(edge.name);\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge)\n    };\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge);\n      expl.peerConflict = this.current && this.current.explain(this.edge);\n    } else {\n      expl.current = curNode && curNode.explain();\n\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf;\n\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge)\n            };\n            break;\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge)\n        };\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine\n    } = this;\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine\n    }); // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n\n    return expl;\n  }\n\n  getStartNode() {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from;\n    return deepestNestingTarget(from, this.name);\n  }\n\n  get top() {\n    return this.parent ? this.parent.top : this;\n  }\n\n  isVulnerable(node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  get allChildren() {\n    const set = new Set(this.children);\n\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n\n    return [...set];\n  }\n\n}\n\nmodule.exports = PlaceDep;","map":{"version":3,"names":["localeCompare","require","log","deepestNestingTarget","CanPlaceDep","KEEP","CONFLICT","debug","Link","gatherDepSet","peerEntrySets","PlaceDep","constructor","options","dep","edge","parent","name","canPlace","target","placed","preferDedupe","force","explicitRequest","updateNames","auditReport","legacyBundling","strictPeerDeps","installLinks","legacyPeerDeps","globalStyle","Object","assign","children","peerConflict","needEvaluation","Set","checks","Map","place","to","error","includes","isVulnerable","start","getStartNode","canPlaceSelf","ancestry","targetEdge","edgesOut","get","isTop","peer","cpd","set","errors","length","rp","resolveParent","isProjectRoot","current","conflictOk","failPeerConflict","warnPeerConflict","placeInTree","Error","silly","location","version","description","from","package","_id","spec","placementType","valid","pruneDedupable","p","matches","virtualRoot","pkg","resolved","integrity","overrides","isLink","realpath","oldDep","replaceOldDep","satisfies","node","root","inventory","query","isDescendantOf","kid","values","peerEdge","peerConflicted","push","oldDeps","entries","has","e","prunePeerSets","edgesIn","entryEdge","keys","entryNode","deepestTarget","isWorkspace","replace","pruneForReplacement","add","invalidDeps","filter","map","deps","descend","canDedupe","nodeSort","a","b","sort","child","fsChildren","topNode","isMine","top","hasPeerEdges","expl","explainPeerConflict","warn","curNode","resolve","code","explain","cps","conflictChildren","allChildren","grandchild","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/place-dep.js"],"sourcesContent":["// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst log = require('proc-log')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\nconst CanPlaceDep = require('./can-place-dep.js')\nconst {\n  KEEP,\n  CONFLICT,\n} = CanPlaceDep\nconst debug = require('./debug.js')\n\nconst Link = require('./link.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\n\nclass PlaceDep {\n  constructor (options) {\n    const {\n      dep,\n      edge,\n      parent = null,\n    } = options\n    this.name = edge.name\n    this.dep = dep\n    this.edge = edge\n    this.canPlace = null\n\n    this.target = null\n    this.placed = null\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      installLinks,\n      legacyPeerDeps,\n      globalStyle,\n    } = parent || options\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      installLinks,\n      legacyPeerDeps,\n      globalStyle,\n    })\n\n    this.children = []\n    this.parent = parent\n    this.peerConflict = null\n\n    this.needEvaluation = new Set()\n\n    this.checks = new Map()\n\n    this.place()\n  }\n\n  place () {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks,\n    } = this\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to &&\n        !edge.error &&\n        !explicitRequest &&\n        !updateNames.includes(edge.name) &&\n        !this.isVulnerable(edge.to)) {\n      return\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode()\n\n    let canPlace = null\n    let canPlaceSelf = null\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name)\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest,\n      })\n      checks.set(target, cpd)\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd\n      } else {\n        break\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent\n        if (rp && rp.isProjectRoot) {\n          break\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf,\n    })\n    this.current = edge.to\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict()\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict()\n        return\n      }\n\n      this.canPlace = canPlaceSelf\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree()\n  }\n\n  placeInTree () {\n    const {\n      dep,\n      canPlace,\n      edge,\n    } = this\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree')\n      })\n      return\n    }\n\n    const { target } = canPlace\n\n    log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description,\n      `for: ${this.edge.from.package._id || this.edge.from.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    const placementType = canPlace.canPlace === CONFLICT\n      ? canPlace.canPlaceSelf\n      : canPlace.canPlace\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was a peerConflicted peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict()\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target)\n      return\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({ parent: target, target: p })\n        return\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.overrides ? { overrides: dep.overrides } : {}),\n      ...(dep.isLink ? { target: dep.target, realpath: dep.realpath } : {}),\n    })\n\n    this.oldDep = target.children.get(this.name)\n    if (this.oldDep) {\n      this.replaceOldDep()\n    } else {\n      this.placed.parent = target\n    }\n\n    // if it's a peerConflicted peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict()\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false)\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false)\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false)\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.peerConflicted) {\n        continue\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue\n      }\n\n      // peerConflicted peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge,\n      }))\n    }\n  }\n\n  replaceOldDep () {\n    const target = this.oldDep.parent\n\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = []\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n    }\n\n    // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n    const prunePeerSets = []\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) ||\n          !edge.peer ||\n          edge.from.parent !== target ||\n          edge.peerConflicted) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue\n      }\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as peerConflicted and warned about.  If the entryEdge comes in from\n        // the root or a workspace, then we have to leave it alone, and in that\n        // case, it will have already warned or crashed by getting to this point\n        const entryNode = entryEdge.to\n        const deepestTarget = deepestNestingTarget(entryNode)\n        if (deepestTarget !== target &&\n            !(entryEdge.from.isProjectRoot || entryEdge.from.isWorkspace)) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.peerConflicted\n          }))\n        } else {\n          this.warnPeerConflict(edge, this.dep)\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep)\n    this.pruneForReplacement(this.placed, oldDeps)\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from)\n      }\n      dep.root = null\n    }\n  }\n\n  pruneForReplacement (node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set) {\n        invalidDeps.add(dep)\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable (node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid)\n      for (const node of deps) {\n        node.root = null\n      }\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location)\n\n      const children = [...node.children.values()].sort(nodeSort)\n      for (const child of children) {\n        this.pruneDedupable(child)\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children) {\n          this.pruneDedupable(child)\n        }\n      }\n    }\n  }\n\n  get conflictOk () {\n    return this.force || (!this.isMine && !this.strictPeerDeps)\n  }\n\n  get isMine () {\n    const { edge } = this.top\n    const { from: node } = edge\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true\n    }\n\n    if (!edge.peer) {\n      return false\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true\n        continue\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  warnPeerConflict (edge, dep) {\n    edge = edge || this.edge\n    dep = dep || this.dep\n    edge.peerConflicted = true\n    const expl = this.explainPeerConflict(edge, dep)\n    log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  failPeerConflict (edge, dep) {\n    edge = edge || this.top.edge\n    dep = dep || this.top.dep\n    const expl = this.explainPeerConflict(edge, dep)\n    throw Object.assign(new Error('could not resolve'), expl)\n  }\n\n  explainPeerConflict (edge, dep) {\n    const { from: node } = edge\n    const curNode = node.resolve(edge.name)\n\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge),\n    }\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge)\n      expl.peerConflict = this.current && this.current.explain(this.edge)\n    } else {\n      expl.current = curNode && curNode.explain()\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge),\n            }\n            break\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge),\n        }\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine,\n    } = this\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine,\n    })\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl\n  }\n\n  getStartNode () {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from\n    return deepestNestingTarget(from, this.name)\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  isVulnerable (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n}\n\nmodule.exports = PlaceDep\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}