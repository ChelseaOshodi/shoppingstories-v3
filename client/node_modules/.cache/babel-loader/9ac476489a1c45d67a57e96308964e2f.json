{"ast":null,"code":"// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst defaultLockfileVersion = 2; // for comparing nodes to yarn.lock entries\n\nconst mismatch = (a, b) => a && b && a !== b; // this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\n\nconst log = require('proc-log');\n\nconst YarnLock = require('./yarn-lock.js');\n\nconst {\n  promisify\n} = require('util');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst stat = promisify(fs.stat);\nconst readdir_ = promisify(fs.readdir);\nconst readlink = promisify(fs.readlink); // XXX remove when drop support for node v10\n\nconst lstat = promisify(fs.lstat);\n/* istanbul ignore next - version specific polyfill */\n\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt);\n  }\n\n  const ents = await readdir_(path, opt);\n\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), {\n        name: ent\n      });\n    }));\n  }\n\n  return ents;\n};\n\nconst {\n  resolve,\n  basename\n} = require('path');\n\nconst specFromLock = require('./spec-from-lock.js');\n\nconst versionFromTgz = require('./version-from-tgz.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst parseJSON = require('parse-conflict-json');\n\nconst stringify = require('json-stringify-nice');\n\nconst swKeyOrder = ['name', 'version', 'lockfileVersion', 'resolved', 'integrity', 'requires', 'packages', 'dependencies']; // used to rewrite from yarn registry to npm registry\n\nconst yarnRegRe = /^https?:\\/\\/registry\\.yarnpkg\\.com\\//;\nconst npmRegRe = /^https?:\\/\\/registry\\.npmjs\\.org\\//; // sometimes resolved: is weird or broken, or something npa can't handle\n\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved);\n  } catch (er) {\n    return {};\n  }\n};\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst {\n  overrideResolves\n} = require('./override-resolves.js');\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return '';\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null;\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst pkgMetaKeys = [// note: name is included if necessary, for alias packages\n'version', 'dependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies', 'acceptDependencies', 'funding', 'engines', 'os', 'cpu', '_integrity', 'license', '_hasShrinkwrap', 'hasInstallScript', 'bin', 'deprecated', 'workspaces'];\nconst nodeMetaKeys = ['integrity', 'inBundle', 'hasShrinkwrap', 'hasInstallScript'];\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]; // get the license type, not an object\n\n  return key === 'license' && val && typeof val === 'object' && val.type ? val.type // skip empty objects and falsey values\n  : val && !(typeof val === 'object' && !Object.keys(val).length) ? val : null;\n}; // check to make sure that there are no packages newer than the hidden lockfile\n\n\nconst assertNoNewer = async function (path, data, lockTime) {\n  let dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : path;\n  let seen = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  const base = basename(dir);\n  const isNM = dir !== path && base === 'node_modules';\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@';\n  const isParent = dir === path || isNM || isScope;\n  const rel = relpath(path, dir);\n\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime;\n\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel;\n    }\n\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel;\n    }\n\n    seen.add(rel);\n  } else {\n    seen = new Set([rel]);\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules');\n  const children = dir === path ? Promise.resolve([{\n    name: 'node_modules',\n    isDirectory: () => true\n  }]) : readdir(parent, {\n    withFileTypes: true\n  });\n  return children.catch(() => []).then(ents => Promise.all(ents.map(async ent => {\n    const child = resolve(parent, ent.name);\n\n    if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n      await assertNoNewer(path, data, lockTime, child, seen);\n    } else if (ent.isSymbolicLink()) {\n      const target = resolve(parent, await readlink(child));\n      const tstat = await stat(target).catch(\n      /* istanbul ignore next - windows */\n      () => null);\n      seen.add(relpath(path, child));\n      /* istanbul ignore next - windows cannot do this */\n\n      if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n        await assertNoNewer(path, data, lockTime, target, seen);\n      }\n    }\n  }))).then(() => {\n    if (dir !== path) {\n      return;\n    } // assert that all the entries in the lockfile were seen\n\n\n    for (const loc of new Set(Object.keys(data.packages))) {\n      if (!seen.has(loc)) {\n        throw 'missing from node_modules: ' + loc;\n      }\n    }\n  });\n};\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate');\n\nconst _updateWaitingNode = Symbol('_updateWaitingNode');\n\nconst _lockFromLoc = Symbol('_lockFromLoc');\n\nconst _pathToLoc = Symbol('_pathToLoc');\n\nconst _loadAll = Symbol('_loadAll');\n\nconst _metaFromLock = Symbol('_metaFromLock');\n\nconst _resolveMetaNode = Symbol('_resolveMetaNode');\n\nconst _fixDependencies = Symbol('_fixDependencies');\n\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile');\n\nconst _filenameSet = Symbol('_filenameSet');\n\nconst _maybeRead = Symbol('_maybeRead');\n\nconst _maybeStat = Symbol('_maybeStat');\n\nclass Shrinkwrap {\n  static get defaultLockfileVersion() {\n    return defaultLockfileVersion;\n  }\n\n  static load(options) {\n    return new Shrinkwrap(options).load();\n  }\n\n  static get keyOrder() {\n    return swKeyOrder;\n  }\n\n  static async reset(options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options);\n    s.reset();\n    const [sw, lock] = await s[_maybeStat]();\n    s.filename = resolve(s.path, (s.hiddenLockfile ? 'node_modules/.package-lock' : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n    s.loadedFromDisk = !!(sw || lock);\n    s.type = basename(s.filename);\n\n    try {\n      if (s.loadedFromDisk && !s.lockfileVersion) {\n        const json = parseJSON(await maybeReadFile(s.filename));\n\n        if (json.lockfileVersion > defaultLockfileVersion) {\n          s.lockfileVersion = json.lockfileVersion;\n        }\n      }\n    } catch (e) {}\n\n    return s;\n  }\n\n  static metaFromNode(node, path) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true\n      };\n    }\n\n    const meta = {};\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key);\n\n      if (val) {\n        meta[key.replace(/^_/, '')] = val;\n      }\n    }); // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n\n    const pname = node.packageName;\n\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname;\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies;\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key];\n      }\n    });\n    const resolved = consistentResolve(node.resolved, node.path, path, true); // hide resolved from registry dependencies.\n\n    if (!resolved) {// no-op\n    } else if (node.isRegistryDependency) {\n      meta.resolved = overrideResolves(resolved, options);\n    } else {\n      meta.resolved = resolved;\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true;\n    } else {\n      if (node.peer) {\n        meta.peer = true;\n      }\n\n      if (node.dev) {\n        meta.dev = true;\n      }\n\n      if (node.optional) {\n        meta.optional = true;\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true;\n      }\n    }\n\n    return meta;\n  }\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      lockfileVersion,\n      resolveOptions = {}\n    } = options;\n    this.lockfileVersion = hiddenLockfile ? 3 : lockfileVersion ? parseInt(lockfileVersion, 10) : null;\n    this[_awaitingUpdate] = new Map();\n    this.tree = null;\n    this.path = resolve(path || '.');\n    this.filename = null;\n    this.data = null;\n    this.indent = indent;\n    this.newline = newline;\n    this.loadedFromDisk = false;\n    this.type = null;\n    this.yarnLock = null;\n    this.hiddenLockfile = hiddenLockfile;\n    this.loadingError = null;\n    this.resolveOptions = resolveOptions; // only load npm-shrinkwrap.json in dep trees, not package-lock\n\n    this.shrinkwrapOnly = shrinkwrapOnly;\n  } // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n\n\n  checkYarnLock(spec) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    spec = npa(spec);\n    const {\n      yarnLock,\n      loadedFromDisk\n    } = this;\n    const useYarnLock = yarnLock && !loadedFromDisk;\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw);\n\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {\n        resolved,\n        version,\n        integrity\n      } = fromYarn;\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved);\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved);\n      const isReg = isnpmReg || isYarnReg; // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {};\n      const yspec = tgz.name === spec.name && tgz.version === version ? version : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}` : resolved;\n\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n        options.integrity = integrity;\n        return npa(`${spec.name}@${yspec}`);\n      }\n    }\n\n    return spec;\n  } // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n\n\n  reset() {\n    this.tree = null;\n    this[_awaitingUpdate] = new Map();\n    const lockfileVersion = this.lockfileVersion || defaultLockfileVersion;\n    this.originalLockfileVersion = lockfileVersion;\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {}\n    };\n  }\n\n  [_filenameSet]() {\n    return this.shrinkwrapOnly ? [this.path + '/npm-shrinkwrap.json'] : this.hiddenLockfile ? [null, this.path + '/node_modules/.package-lock.json'] : [this.path + '/npm-shrinkwrap.json', this.path + '/package-lock.json', this.path + '/yarn.lock'];\n  }\n\n  [_maybeRead]() {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)));\n  }\n\n  [_maybeStat]() {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2).map(fn => fn && maybeStatFile(fn)));\n  }\n\n  inferFormattingOptions(packageJSONData) {\n    // don't use detect-indent, just pick the first line.\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // which will default to 2 at save time.\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline\n    } = packageJSONData;\n    this.indent = indent !== undefined ? indent : this.indent;\n    this.newline = newline !== undefined ? newline : this.newline;\n  }\n\n  load() {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(_ref => {\n      let [sw, lock, yarn] = _ref;\n      const data = sw || lock || ''; // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n\n      this.filename = resolve(this.path, (this.hiddenLockfile ? 'node_modules/.package-lock' : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      this.type = basename(this.filename);\n      this.loadedFromDisk = !!data;\n\n      if (yarn) {\n        this.yarnLock = new YarnLock(); // ignore invalid yarn data.  we'll likely clobber it later anyway.\n\n        try {\n          this.yarnLock.parse(yarn);\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {};\n    }).then(async data => {\n      this.inferFormattingOptions(data);\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data;\n      } // add a few ms just to account for jitter\n\n\n      const lockTime = +(await stat(this.filename)).mtime + 10;\n      await assertNoNewer(this.path, data, lockTime); // all good!  hidden lockfile is the newest thing in here.\n\n      return data;\n    }).catch(er => {\n      /* istanbul ignore else */\n      if (typeof this.filename === 'string') {\n        const rel = relpath(this.path, this.filename);\n        log.verbose('shrinkwrap', `failed to load ${rel}`, er);\n      } else {\n        log.verbose('shrinkwrap', `failed to load ${this.path}`, er);\n      }\n\n      this.loadingError = er;\n      this.loadedFromDisk = false;\n      this.ancientLockfile = false;\n      return {};\n    }).then(lock => {\n      const lockfileVersion = this.lockfileVersion ? this.lockfileVersion : Math.max(lock.lockfileVersion || 0, defaultLockfileVersion);\n      this.data = { ...lock,\n        lockfileVersion: lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        dependencies: lock.dependencies || {}\n      };\n      this.originalLockfileVersion = lock.lockfileVersion; // use default if it wasn't explicitly set, and the current file is\n      // less than our default.  otherwise, keep whatever is in the file,\n      // unless we had an explicit setting already.\n\n      if (!this.lockfileVersion) {\n        this.lockfileVersion = this.data.lockfileVersion = lockfileVersion;\n      }\n\n      this.ancientLockfile = this.loadedFromDisk && !(lock.lockfileVersion >= 2) && !lock.requires; // load old lockfile deps into the packages listing\n\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({})).then(pkg => {\n          this[_loadAll]('', null, this.data);\n\n          this[_fixDependencies](pkg);\n        });\n      }\n    }).then(() => this);\n  }\n\n  [_loadAll](location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock); // dependencies nested under a link are actually under the link target\n\n\n    if (meta.link) {\n      location = meta.resolved;\n    }\n\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name;\n\n        this[_loadAll](loc, name, dep);\n      }\n    }\n  } // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n\n\n  [_fixDependencies](pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages[''];\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key);\n      const k = key.replace(/^_/, '');\n\n      if (val) {\n        root[k] = val;\n      }\n    });\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue;\n      } // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n\n\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name); // this overwrites the false value set above\n\n\n        const depType = dep && dep.optional && !meta.optional ? 'optionalDependencies' :\n        /* istanbul ignore next - dev deps are only for the root level */\n        dep && dep.dev && !meta.dev ? 'devDependencies' // also land here if the dep just isn't in the tree, which maybe\n        // should be an error, since it means that the shrinkwrap is\n        // invalid, but we can't do much better without any info.\n        : 'dependencies';\n        meta[depType] = meta[depType] || {};\n        meta[depType][name] = spec;\n      }\n\n      delete meta.requires;\n    }\n  }\n\n  [_resolveMetaNode](loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`;\n\n      if (this.data.packages[check]) {\n        return this.data.packages[check];\n      }\n\n      if (!path) {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n  [_lockFromLoc](lock, path) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (!lock) {\n      return null;\n    }\n\n    if (path[i] === '') {\n      i++;\n    }\n\n    if (i >= path.length) {\n      return lock;\n    }\n\n    if (!lock.dependencies) {\n      return null;\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1);\n  } // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n\n\n  [_pathToLoc](path) {\n    return relpath(this.path, resolve(this.path, path));\n  }\n\n  delete(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    const location = this[_pathToLoc](nodePath);\n\n    this[_awaitingUpdate].delete(location);\n\n    delete this.data.packages[location];\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path.pop();\n\n    const pLock = this[_lockFromLoc](this.data, path);\n\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name];\n    }\n  }\n\n  get(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    const location = this[_pathToLoc](nodePath);\n\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location);\n    } // first try to get from the newer spot, which we know has\n    // all the things we need.\n\n\n    if (this.data.packages[location]) {\n      return this.data.packages[location];\n    } // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n\n\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path[path.length - 1];\n\n    const lock = this[_lockFromLoc](this.data, path);\n\n    return this[_metaFromLock](location, name, lock);\n  }\n\n  [_metaFromLock](location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {};\n    } // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n\n\n    const spec = specFromLock(name, lock, this.path);\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec);\n      this.data.packages[location] = {\n        link: true,\n        resolved: target\n      }; // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock,\n          version: null\n        });\n      }\n\n      return this.data.packages[location];\n    }\n\n    const meta = {}; // when calling loadAll we'll change these into proper dep objects\n\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires;\n    }\n\n    if (lock.optional) {\n      meta.optional = true;\n    }\n\n    if (lock.dev) {\n      meta.dev = true;\n    } // the root will typically have a name from the root project's\n    // package.json file.\n\n\n    if (location === '') {\n      meta.name = lock.name;\n    } // if we have integrity, save it now.\n\n\n    if (lock.integrity) {\n      meta.integrity = lock.integrity;\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path); // return early because there is nothing else we can do with this\n\n        return this.data.packages[location] = meta;\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version;\n      } // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n\n    } // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n\n\n    if (lock.resolved || spec.type && !spec.registry) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved;\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true);\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec;\n      }\n    } // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n\n\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);\n\n        if (fromTgz) {\n          meta.version = fromTgz.version;\n\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name;\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name;\n        meta.version = spec.subSpec.fetchSpec;\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec;\n      } // ok, I did my best!  good luck!\n\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true;\n    } // save it for next time\n\n\n    return this.data.packages[location] = meta;\n  }\n\n  add(node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    } // will be actually updated on read\n\n\n    const loc = relpath(this.path, node.path);\n\n    if (node.path === this.path) {\n      this.tree = node;\n    } // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n\n\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version\n      } = this.get(node.path);\n      const pathFixed = !resolved ? null : !/^file:/.test(resolved) ? resolved // resolve onto the metadata path\n      : `file:${resolve(this.path, resolved.slice(5)).replace(/#/g, '%23')}`; // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n\n      const resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed;\n      const integrityOk = !integrity || !node.integrity || node.integrity === integrity;\n      const versionOk = !version || !node.version || version === node.version;\n      const allOk = (resolved || integrity || version) && resolvedOk && integrityOk && versionOk;\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap\n        } = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);\n        node.resolved = node.resolved || resolved || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      }\n    }\n\n    this[_awaitingUpdate].set(loc, node);\n  }\n\n  addEdge(edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return;\n    }\n\n    const {\n      to: node\n    } = edge; // if it's already set up, nothing to do\n\n    if (node.resolved !== null && node.integrity !== null) {\n      return;\n    } // if the yarn lock is empty, nothing to do\n\n\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return;\n    } // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n\n\n    const pathFixed = !node.resolved ? null : !/file:/.test(node.resolved) ? node.resolved : consistentResolve(node.resolved, node.path, this.path, true);\n    const spec = npa(`${node.name}@${edge.spec}`);\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);\n\n    if (!entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved)) {\n      return;\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n    }\n\n    node.integrity = node.integrity || entry.integrity || null;\n    node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null;\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node);\n  }\n\n  [_updateWaitingNode](loc) {\n    const node = this[_awaitingUpdate].get(loc);\n\n    this[_awaitingUpdate].delete(loc);\n\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);\n  }\n\n  commit() {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree);\n      }\n\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path, this.resolveOptions);\n      this.data.packages = {};\n\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root;\n      }\n\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue;\n        }\n\n        const loc = relpath(this.path, node.path);\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc);\n      }\n    } // if we haven't set it by now, use the default\n\n\n    if (!this.lockfileVersion) {\n      this.lockfileVersion = defaultLockfileVersion;\n    }\n\n    this.data.lockfileVersion = this.lockfileVersion; // hidden lockfiles don't include legacy metadata or a root entry\n\n    if (this.hiddenLockfile) {\n      delete this.data.packages[''];\n      delete this.data.dependencies;\n    } else if (this.tree && this.lockfileVersion <= 3) {\n      this[_buildLegacyLockfile](this.tree, this.data);\n    } // lf version 1 = dependencies only\n    // lf version 2 = dependencies and packages\n    // lf version 3 = packages only\n\n\n    if (this.lockfileVersion >= 3) {\n      const {\n        dependencies,\n        ...data\n      } = this.data;\n      return data;\n    } else if (this.lockfileVersion < 2) {\n      const {\n        packages,\n        ...data\n      } = this.data;\n      return data;\n    } else {\n      return { ...this.data\n      };\n    }\n  }\n\n  [_buildLegacyLockfile](node, lock) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name;\n\n      if (node.version) {\n        lock.version = node.version;\n      }\n    } // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n\n\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules');\n      const bloc = b.from.location.split('node_modules');\n      /* istanbul ignore next - sort calling order is indeterminate */\n\n      return aloc.length > bloc.length ? 1 : bloc.length > aloc.length ? -1 : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1]);\n    })[0];\n    const res = consistentResolve(node.resolved, this.path, this.path, true);\n    const rSpec = specFromResolved(res); // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n\n    const spec = !edge ? rSpec : npa.resolve(node.name, edge.spec, edge.from.realpath);\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath).replace(/#/g, '%23')}`;\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec;\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved;\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n\n      if (spec.raw) {\n        lock.from = spec.raw;\n      }\n    } else if (!node.isRoot && node.package && node.packageName && node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`;\n    } else if (node.package && node.version) {\n      lock.version = node.version;\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true;\n    } // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n\n\n    if (node.resolved && !node.isLink && rSpec.type !== 'git' && rSpec.type !== 'file' && rSpec.type !== 'directory' && spec.type !== 'directory' && spec.type !== 'git' && spec.type !== 'file' && spec.type !== 'remote') {\n      lock.resolved = overrideResolves(node.resolved, this.resolveOptions);\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity;\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true;\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true;\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true;\n      }\n\n      if (node.dev) {\n        lock.dev = true;\n      }\n\n      if (node.optional) {\n        lock.optional = true;\n      }\n    }\n\n    const depender = node.target;\n\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()];\n        lock.requires = entries.reduce((set, _ref2) => {\n          let [k, v] = _ref2;\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const {\n            spec,\n            peer\n          } = v;\n\n          if (peer) {\n            return set;\n          }\n\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.slice('file:'.length));\n            set[k] = `file:${relpath(node.realpath, p).replace(/#/g, '%23')}`;\n          } else {\n            set[k] = spec;\n          }\n\n          return set;\n        }, {});\n      } else {\n        lock.requires = true;\n      }\n    } // now we walk the children, putting them in the 'dependencies' object\n\n\n    const {\n      children\n    } = node.target;\n\n    if (!children.size) {\n      delete lock.dependencies;\n    } else {\n      const kidPath = [...path, node.realpath];\n      const dependencies = {}; // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n\n      let found = false;\n\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue;\n        }\n\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath);\n        found = true;\n      }\n\n      if (found) {\n        lock.dependencies = dependencies;\n      }\n    }\n\n    return lock;\n  }\n\n  toJSON() {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    return this.commit();\n  }\n\n  toString() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = this.toJSON();\n    const {\n      format = true\n    } = options;\n    const defaultIndent = this.indent || 2;\n    const indent = format === true ? defaultIndent : format || 0;\n    const eol = format ? this.newline || '\\n' : '';\n    return stringify(data, swKeyOrder, indent).replace(/\\n/g, eol);\n  }\n\n  save() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.data) {\n      throw new Error('run load() before saving data');\n    }\n\n    const json = this.toString(options);\n    return Promise.all([writeFile(this.filename, json).catch(er => {\n      if (this.hiddenLockfile) {\n        // well, we did our best.\n        // if we reify, and there's nothing there, then it might be lacking\n        // a node_modules folder, but then the lockfile is not important.\n        // Remove the file, so that in case there WERE deps, but we just\n        // failed to update the file for some reason, it's not out of sync.\n        return rimraf(this.filename);\n      }\n\n      throw er;\n    }), this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + '/yarn.lock', this.yarnLock.toString())]);\n  }\n\n}\n\nmodule.exports = Shrinkwrap;","map":{"version":3,"names":["localeCompare","require","defaultLockfileVersion","mismatch","a","b","log","YarnLock","promisify","rimraf","fs","readFile","writeFile","stat","readdir_","readdir","readlink","lstat","path","opt","withFileTypes","ents","Promise","all","map","ent","Object","assign","name","resolve","basename","specFromLock","versionFromTgz","npa","rpj","parseJSON","stringify","swKeyOrder","yarnRegRe","npmRegRe","specFromResolved","resolved","er","relpath","consistentResolve","overrideResolves","maybeReadFile","file","then","d","code","maybeStatFile","st","isFile","pkgMetaKeys","nodeMetaKeys","metaFieldFromPkg","pkg","key","val","type","keys","length","assertNoNewer","data","lockTime","dir","seen","base","isNM","isScope","charAt","isParent","rel","dirTime","mtime","packages","add","Set","parent","children","isDirectory","catch","child","test","isSymbolicLink","target","tstat","has","loc","_awaitingUpdate","Symbol","_updateWaitingNode","_lockFromLoc","_pathToLoc","_loadAll","_metaFromLock","_resolveMetaNode","_fixDependencies","_buildLegacyLockfile","_filenameSet","_maybeRead","_maybeStat","Shrinkwrap","load","options","keyOrder","reset","s","sw","lock","filename","hiddenLockfile","shrinkwrapOnly","loadedFromDisk","lockfileVersion","json","e","metaFromNode","node","isLink","realpath","link","meta","forEach","package","replace","pname","packageName","root","isTop","devDependencies","isRegistryDependency","extraneous","peer","dev","optional","devOptional","constructor","indent","newline","resolveOptions","parseInt","Map","tree","yarnLock","loadingError","checkYarnLock","spec","useYarnLock","fromYarn","entries","get","raw","version","integrity","isYarnReg","registry","isnpmReg","isReg","tgz","yspec","originalLockfileVersion","requires","dependencies","fn","slice","inferFormattingOptions","packageJSONData","for","undefined","yarn","parse","_","verbose","ancientLockfile","Math","max","location","dep","k","depType","check","i","delete","nodePath","Error","split","pop","pLock","fetchSpec","fromTgz","subSpec","bundled","inBundle","hasShrinkwrap","pathFixed","resolvedOk","integrityOk","versionOk","allOk","set","addEdge","edge","valid","to","size","entry","commit","fromTree","inventory","values","isRoot","edgesIn","filter","sort","aloc","from","bloc","res","rSpec","saveSpec","inDepBundle","depender","edgesOut","reduce","v","startsWith","p","kidPath","found","kid","includes","toJSON","toString","format","defaultIndent","eol","save","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/shrinkwrap.js"],"sourcesContent":["// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst defaultLockfileVersion = 2\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst log = require('proc-log')\nconst YarnLock = require('./yarn-lock.js')\nconst { promisify } = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst stat = promisify(fs.stat)\nconst readdir_ = promisify(fs.readdir)\nconst readlink = promisify(fs.readlink)\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat)\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt)\n  }\n  const ents = await readdir_(path, opt)\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), { name: ent })\n    }))\n  }\n  return ents\n}\n\nconst { resolve, basename } = require('path')\nconst specFromLock = require('./spec-from-lock.js')\nconst versionFromTgz = require('./version-from-tgz.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst parseJSON = require('parse-conflict-json')\n\nconst stringify = require('json-stringify-nice')\nconst swKeyOrder = [\n  'name',\n  'version',\n  'lockfileVersion',\n  'resolved',\n  'integrity',\n  'requires',\n  'packages',\n  'dependencies',\n]\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry\\.yarnpkg\\.com\\//\nconst npmRegRe = /^https?:\\/\\/registry\\.npmjs\\.org\\//\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved)\n  } catch (er) {\n    return {}\n  }\n}\n\nconst relpath = require('./relpath.js')\n\nconst consistentResolve = require('./consistent-resolve.js')\nconst { overrideResolves } = require('./override-resolves.js')\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return ''\n    } else {\n      throw er\n    }\n  })\n}\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null\n    } else {\n      throw er\n    }\n  })\n}\n\nconst pkgMetaKeys = [\n  // note: name is included if necessary, for alias packages\n  'version',\n  'dependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n  'acceptDependencies',\n  'funding',\n  'engines',\n  'os',\n  'cpu',\n  '_integrity',\n  'license',\n  '_hasShrinkwrap',\n  'hasInstallScript',\n  'bin',\n  'deprecated',\n  'workspaces',\n]\n\nconst nodeMetaKeys = [\n  'integrity',\n  'inBundle',\n  'hasShrinkwrap',\n  'hasInstallScript',\n]\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]\n  // get the license type, not an object\n  return (key === 'license' && val && typeof val === 'object' && val.type)\n    ? val.type\n    // skip empty objects and falsey values\n    : (val && !(typeof val === 'object' && !Object.keys(val).length)) ? val\n    : null\n}\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir)\n  const isNM = dir !== path && base === 'node_modules'\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@'\n  const isParent = dir === path || isNM || isScope\n\n  const rel = relpath(path, dir)\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel\n    }\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel\n    }\n    seen.add(rel)\n  } else {\n    seen = new Set([rel])\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules')\n  const children = dir === path\n    ? Promise.resolve([{ name: 'node_modules', isDirectory: () => true }])\n    : readdir(parent, { withFileTypes: true })\n\n  return children.catch(() => [])\n    .then(ents => Promise.all(ents.map(async ent => {\n      const child = resolve(parent, ent.name)\n      if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n        await assertNoNewer(path, data, lockTime, child, seen)\n      } else if (ent.isSymbolicLink()) {\n        const target = resolve(parent, await readlink(child))\n        const tstat = await stat(target).catch(\n          /* istanbul ignore next - windows */ () => null)\n        seen.add(relpath(path, child))\n        /* istanbul ignore next - windows cannot do this */\n        if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n          await assertNoNewer(path, data, lockTime, target, seen)\n        }\n      }\n    })))\n    .then(() => {\n      if (dir !== path) {\n        return\n      }\n\n      // assert that all the entries in the lockfile were seen\n      for (const loc of new Set(Object.keys(data.packages))) {\n        if (!seen.has(loc)) {\n          throw 'missing from node_modules: ' + loc\n        }\n      }\n    })\n}\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate')\nconst _updateWaitingNode = Symbol('_updateWaitingNode')\nconst _lockFromLoc = Symbol('_lockFromLoc')\nconst _pathToLoc = Symbol('_pathToLoc')\nconst _loadAll = Symbol('_loadAll')\nconst _metaFromLock = Symbol('_metaFromLock')\nconst _resolveMetaNode = Symbol('_resolveMetaNode')\nconst _fixDependencies = Symbol('_fixDependencies')\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile')\nconst _filenameSet = Symbol('_filenameSet')\nconst _maybeRead = Symbol('_maybeRead')\nconst _maybeStat = Symbol('_maybeStat')\nclass Shrinkwrap {\n  static get defaultLockfileVersion () {\n    return defaultLockfileVersion\n  }\n\n  static load (options) {\n    return new Shrinkwrap(options).load()\n  }\n\n  static get keyOrder () {\n    return swKeyOrder\n  }\n\n  static async reset (options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options)\n    s.reset()\n\n    const [sw, lock] = await s[_maybeStat]()\n\n    s.filename = resolve(s.path,\n      (s.hiddenLockfile ? 'node_modules/.package-lock'\n      : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n      : 'package-lock') + '.json')\n    s.loadedFromDisk = !!(sw || lock)\n    s.type = basename(s.filename)\n\n    try {\n      if (s.loadedFromDisk && !s.lockfileVersion) {\n        const json = parseJSON(await maybeReadFile(s.filename))\n        if (json.lockfileVersion > defaultLockfileVersion) {\n          s.lockfileVersion = json.lockfileVersion\n        }\n      }\n    } catch (e) {}\n\n    return s\n  }\n\n  static metaFromNode (node, path, options = {}) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true,\n      }\n    }\n\n    const meta = {}\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key)\n      if (val) {\n        meta[key.replace(/^_/, '')] = val\n      }\n    })\n    // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n    const pname = node.packageName\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key]\n      }\n    })\n\n    const resolved = consistentResolve(node.resolved, node.path, path, true)\n    // hide resolved from registry dependencies.\n    if (!resolved) {\n      // no-op\n    } else if (node.isRegistryDependency) {\n      meta.resolved = overrideResolves(resolved, options)\n    } else {\n      meta.resolved = resolved\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true\n    } else {\n      if (node.peer) {\n        meta.peer = true\n      }\n      if (node.dev) {\n        meta.dev = true\n      }\n      if (node.optional) {\n        meta.optional = true\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true\n      }\n    }\n    return meta\n  }\n\n  constructor (options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      lockfileVersion,\n      resolveOptions = {},\n    } = options\n\n    this.lockfileVersion = hiddenLockfile ? 3\n      : lockfileVersion ? parseInt(lockfileVersion, 10)\n      : null\n    this[_awaitingUpdate] = new Map()\n    this.tree = null\n    this.path = resolve(path || '.')\n    this.filename = null\n    this.data = null\n    this.indent = indent\n    this.newline = newline\n    this.loadedFromDisk = false\n    this.type = null\n    this.yarnLock = null\n    this.hiddenLockfile = hiddenLockfile\n    this.loadingError = null\n    this.resolveOptions = resolveOptions\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock (spec, options = {}) {\n    spec = npa(spec)\n    const { yarnLock, loadedFromDisk } = this\n    const useYarnLock = yarnLock && !loadedFromDisk\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw)\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const { resolved, version, integrity } = fromYarn\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved)\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved)\n      const isReg = isnpmReg || isYarnReg\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {}\n      const yspec = tgz.name === spec.name && tgz.version === version ? version\n        : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}`\n        : resolved\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n        options.integrity = integrity\n        return npa(`${spec.name}@${yspec}`)\n      }\n    }\n    return spec\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset () {\n    this.tree = null\n    this[_awaitingUpdate] = new Map()\n    const lockfileVersion = this.lockfileVersion || defaultLockfileVersion\n    this.originalLockfileVersion = lockfileVersion\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {},\n    }\n  }\n\n  [_filenameSet] () {\n    return this.shrinkwrapOnly ? [\n      this.path + '/npm-shrinkwrap.json',\n    ] : this.hiddenLockfile ? [\n      null,\n      this.path + '/node_modules/.package-lock.json',\n    ] : [\n      this.path + '/npm-shrinkwrap.json',\n      this.path + '/package-lock.json',\n      this.path + '/yarn.lock',\n    ]\n  }\n\n  [_maybeRead] () {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)))\n  }\n\n  [_maybeStat] () {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2)\n      .map(fn => fn && maybeStatFile(fn)))\n  }\n\n  inferFormattingOptions (packageJSONData) {\n    // don't use detect-indent, just pick the first line.\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // which will default to 2 at save time.\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline,\n    } = packageJSONData\n    this.indent = indent !== undefined ? indent : this.indent\n    this.newline = newline !== undefined ? newline : this.newline\n  }\n\n  load () {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path,\n        (this.hiddenLockfile ? 'node_modules/.package-lock'\n        : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n\n      this.type = basename(this.filename)\n      this.loadedFromDisk = !!data\n\n      if (yarn) {\n        this.yarnLock = new YarnLock()\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn)\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {}\n    }).then(async data => {\n      this.inferFormattingOptions(data)\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data\n      }\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10\n      await assertNoNewer(this.path, data, lockTime)\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data\n    }).catch(er => {\n      /* istanbul ignore else */\n      if (typeof this.filename === 'string') {\n        const rel = relpath(this.path, this.filename)\n        log.verbose('shrinkwrap', `failed to load ${rel}`, er)\n      } else {\n        log.verbose('shrinkwrap', `failed to load ${this.path}`, er)\n      }\n      this.loadingError = er\n      this.loadedFromDisk = false\n      this.ancientLockfile = false\n      return {}\n    }).then(lock => {\n      const lockfileVersion = this.lockfileVersion ? this.lockfileVersion\n        : Math.max(lock.lockfileVersion || 0, defaultLockfileVersion)\n      this.data = {\n        ...lock,\n        lockfileVersion: lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        dependencies: lock.dependencies || {},\n      }\n\n      this.originalLockfileVersion = lock.lockfileVersion\n      // use default if it wasn't explicitly set, and the current file is\n      // less than our default.  otherwise, keep whatever is in the file,\n      // unless we had an explicit setting already.\n      if (!this.lockfileVersion) {\n        this.lockfileVersion = this.data.lockfileVersion = lockfileVersion\n      }\n      this.ancientLockfile = this.loadedFromDisk &&\n        !(lock.lockfileVersion >= 2) && !lock.requires\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({}))\n          .then(pkg => {\n            this[_loadAll]('', null, this.data)\n            this[_fixDependencies](pkg)\n          })\n      }\n    })\n      .then(() => this)\n  }\n\n  [_loadAll] (location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock)\n    // dependencies nested under a link are actually under the link target\n    if (meta.link) {\n      location = meta.resolved\n    }\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name\n        this[_loadAll](loc, name, dep)\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies] (pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages['']\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key)\n      const k = key.replace(/^_/, '')\n      if (val) {\n        root[k] = val\n      }\n    })\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue\n      }\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name)\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional\n          ? 'optionalDependencies'\n          : /* istanbul ignore next - dev deps are only for the root level */\n          dep && dep.dev && !meta.dev ? 'devDependencies'\n          // also land here if the dep just isn't in the tree, which maybe\n          // should be an error, since it means that the shrinkwrap is\n          // invalid, but we can't do much better without any info.\n          : 'dependencies'\n        meta[depType] = meta[depType] || {}\n        meta[depType][name] = spec\n      }\n      delete meta.requires\n    }\n  }\n\n  [_resolveMetaNode] (loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`\n      if (this.data.packages[check]) {\n        return this.data.packages[check]\n      }\n\n      if (!path) {\n        break\n      }\n    }\n    return null\n  }\n\n  [_lockFromLoc] (lock, path, i = 0) {\n    if (!lock) {\n      return null\n    }\n\n    if (path[i] === '') {\n      i++\n    }\n\n    if (i >= path.length) {\n      return lock\n    }\n\n    if (!lock.dependencies) {\n      return null\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1)\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc] (path) {\n    return relpath(this.path, resolve(this.path, path))\n  }\n\n  delete (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n    const location = this[_pathToLoc](nodePath)\n    this[_awaitingUpdate].delete(location)\n\n    delete this.data.packages[location]\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path.pop()\n    const pLock = this[_lockFromLoc](this.data, path)\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name]\n    }\n  }\n\n  get (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    const location = this[_pathToLoc](nodePath)\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location)\n    }\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location]) {\n      return this.data.packages[location]\n    }\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path[path.length - 1]\n    const lock = this[_lockFromLoc](this.data, path)\n\n    return this[_metaFromLock](location, name, lock)\n  }\n\n  [_metaFromLock] (location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {}\n    }\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path)\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec)\n      this.data.packages[location] = {\n        link: true,\n        resolved: target,\n      }\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock, version: null })\n      }\n      return this.data.packages[location]\n    }\n\n    const meta = {}\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires\n    }\n\n    if (lock.optional) {\n      meta.optional = true\n    }\n    if (lock.dev) {\n      meta.dev = true\n    }\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '') {\n      meta.name = lock.name\n    }\n\n    // if we have integrity, save it now.\n    if (lock.integrity) {\n      meta.integrity = lock.integrity\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path)\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || (spec.type && !spec.registry)) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true)\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec\n      }\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) ||\n          versionFromTgz(spec.name, meta.resolved)\n        if (fromTgz) {\n          meta.version = fromTgz.version\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name\n        meta.version = spec.subSpec.fetchSpec\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec\n      }\n      // ok, I did my best!  good luck!\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true\n    }\n\n    // save it for next time\n    return this.data.packages[location] = meta\n  }\n\n  add (node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path)\n    if (node.path === this.path) {\n      this.tree = node\n    }\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version,\n      } = this.get(node.path)\n\n      const pathFixed = !resolved ? null\n        : !/^file:/.test(resolved) ? resolved\n        // resolve onto the metadata path\n        : `file:${resolve(this.path, resolved.slice(5)).replace(/#/g, '%23')}`\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved ||\n        node.resolved === pathFixed\n      const integrityOk = !integrity || !node.integrity ||\n        node.integrity === integrity\n      const versionOk = !version || !node.version || version === node.version\n\n      const allOk = (resolved || integrity || version) &&\n        resolvedOk && integrityOk && versionOk\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap,\n        } = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions)\n        node.resolved = node.resolved || resolved || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      }\n    }\n    this[_awaitingUpdate].set(loc, node)\n  }\n\n  addEdge (edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return\n    }\n\n    const { to: node } = edge\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null) {\n      return\n    }\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return\n    }\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null\n      : !/file:/.test(node.resolved) ? node.resolved\n      : consistentResolve(node.resolved, node.path, this.path, true)\n\n    const spec = npa(`${node.name}@${edge.spec}`)\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`)\n\n    if (!entry ||\n        mismatch(node.version, entry.version) ||\n        mismatch(node.integrity, entry.integrity) ||\n        mismatch(pathFixed, entry.resolved)) {\n      return\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n    }\n\n    node.integrity = node.integrity || entry.integrity || null\n    node.resolved = node.resolved ||\n      consistentResolve(entry.resolved, this.path, node.path) || null\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node)\n  }\n\n  [_updateWaitingNode] (loc) {\n    const node = this[_awaitingUpdate].get(loc)\n    this[_awaitingUpdate].delete(loc)\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(\n      node,\n      this.path,\n      this.resolveOptions)\n  }\n\n  commit () {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree)\n      }\n      const root = Shrinkwrap.metaFromNode(\n        this.tree.target,\n        this.path,\n        this.resolveOptions)\n      this.data.packages = {}\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root\n      }\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue\n        }\n        const loc = relpath(this.path, node.path)\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(\n          node,\n          this.path,\n          this.resolveOptions)\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc)\n      }\n    }\n\n    // if we haven't set it by now, use the default\n    if (!this.lockfileVersion) {\n      this.lockfileVersion = defaultLockfileVersion\n    }\n    this.data.lockfileVersion = this.lockfileVersion\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages['']\n      delete this.data.dependencies\n    } else if (this.tree && this.lockfileVersion <= 3) {\n      this[_buildLegacyLockfile](this.tree, this.data)\n    }\n\n    // lf version 1 = dependencies only\n    // lf version 2 = dependencies and packages\n    // lf version 3 = packages only\n    if (this.lockfileVersion >= 3) {\n      const { dependencies, ...data } = this.data\n      return data\n    } else if (this.lockfileVersion < 2) {\n      const { packages, ...data } = this.data\n      return data\n    } else {\n      return { ...this.data }\n    }\n  }\n\n  [_buildLegacyLockfile] (node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name\n      if (node.version) {\n        lock.version = node.version\n      }\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules')\n      const bloc = b.from.location.split('node_modules')\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1\n        : bloc.length > aloc.length ? -1\n        : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1])\n    })[0]\n\n    const res = consistentResolve(node.resolved, this.path, this.path, true)\n    const rSpec = specFromResolved(res)\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec\n      : npa.resolve(node.name, edge.spec, edge.from.realpath)\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath).replace(/#/g, '%23')}`\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw) {\n        lock.from = spec.raw\n      }\n    } else if (!node.isRoot &&\n        node.package &&\n        node.packageName &&\n        node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`\n    } else if (node.package && node.version) {\n      lock.version = node.version\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true\n    }\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved &&\n        !node.isLink &&\n        rSpec.type !== 'git' &&\n        rSpec.type !== 'file' &&\n        rSpec.type !== 'directory' &&\n        spec.type !== 'directory' &&\n        spec.type !== 'git' &&\n        spec.type !== 'file' &&\n        spec.type !== 'remote') {\n      lock.resolved = overrideResolves(node.resolved, this.resolveOptions)\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true\n      }\n\n      if (node.dev) {\n        lock.dev = true\n      }\n\n      if (node.optional) {\n        lock.optional = true\n      }\n    }\n\n    const depender = node.target\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()]\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const { spec, peer } = v\n          if (peer) {\n            return set\n          }\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.slice('file:'.length))\n            set[k] = `file:${relpath(node.realpath, p).replace(/#/g, '%23')}`\n          } else {\n            set[k] = spec\n          }\n          return set\n        }, {})\n      } else {\n        lock.requires = true\n      }\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const { children } = node.target\n    if (!children.size) {\n      delete lock.dependencies\n    } else {\n      const kidPath = [...path, node.realpath]\n      const dependencies = {}\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue\n        }\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath)\n        found = true\n      }\n      if (found) {\n        lock.dependencies = dependencies\n      }\n    }\n    return lock\n  }\n\n  toJSON () {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    return this.commit()\n  }\n\n  toString (options = {}) {\n    const data = this.toJSON()\n    const { format = true } = options\n    const defaultIndent = this.indent || 2\n    const indent = format === true ? defaultIndent\n      : format || 0\n    const eol = format ? this.newline || '\\n' : ''\n    return stringify(data, swKeyOrder, indent).replace(/\\n/g, eol)\n  }\n\n  save (options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data')\n    }\n    const json = this.toString(options)\n    return Promise.all([\n      writeFile(this.filename, json).catch(er => {\n        if (this.hiddenLockfile) {\n          // well, we did our best.\n          // if we reify, and there's nothing there, then it might be lacking\n          // a node_modules folder, but then the lockfile is not important.\n          // Remove the file, so that in case there WERE deps, but we just\n          // failed to update the file for some reason, it's not out of sync.\n          return rimraf(this.filename)\n        }\n        throw er\n      }),\n      this.yarnLock && this.yarnLock.entries.size &&\n        writeFile(this.path + '/yarn.lock', this.yarnLock.toString()),\n    ])\n  }\n}\n\nmodule.exports = Shrinkwrap\n"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,+BAAD,CAAP,CAAyC,IAAzC,CAAtB;;AACA,MAAMC,sBAAsB,GAAG,CAA/B,C,CAEA;;AACA,MAAMC,QAAQ,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAL,IAAUD,CAAC,KAAKC,CAA3C,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,GAAG,GAAGL,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAMM,QAAQ,GAAGN,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAM;EAAEO;AAAF,IAAgBP,OAAO,CAAC,MAAD,CAA7B;;AACA,MAAMQ,MAAM,GAAGD,SAAS,CAACP,OAAO,CAAC,QAAD,CAAR,CAAxB;;AACA,MAAMS,EAAE,GAAGT,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMU,QAAQ,GAAGH,SAAS,CAACE,EAAE,CAACC,QAAJ,CAA1B;AACA,MAAMC,SAAS,GAAGJ,SAAS,CAACE,EAAE,CAACE,SAAJ,CAA3B;AACA,MAAMC,IAAI,GAAGL,SAAS,CAACE,EAAE,CAACG,IAAJ,CAAtB;AACA,MAAMC,QAAQ,GAAGN,SAAS,CAACE,EAAE,CAACK,OAAJ,CAA1B;AACA,MAAMC,QAAQ,GAAGR,SAAS,CAACE,EAAE,CAACM,QAAJ,CAA1B,C,CAEA;;AACA,MAAMC,KAAK,GAAGT,SAAS,CAACE,EAAE,CAACO,KAAJ,CAAvB;AACA;;AACA,MAAMF,OAAO,GAAG,OAAOG,IAAP,EAAaC,GAAb,KAAqB;EACnC,IAAI,CAACA,GAAD,IAAQ,CAACA,GAAG,CAACC,aAAjB,EAAgC;IAC9B,OAAON,QAAQ,CAACI,IAAD,EAAOC,GAAP,CAAf;EACD;;EACD,MAAME,IAAI,GAAG,MAAMP,QAAQ,CAACI,IAAD,EAAOC,GAAP,CAA3B;;EACA,IAAI,OAAOE,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;IAC/B,OAAOC,OAAO,CAACC,GAAR,CAAYF,IAAI,CAACG,GAAL,CAAS,MAAMC,GAAN,IAAa;MACvC,OAAOC,MAAM,CAACC,MAAP,CAAc,MAAMV,KAAK,CAACC,IAAI,GAAG,GAAP,GAAaO,GAAd,CAAzB,EAA6C;QAAEG,IAAI,EAAEH;MAAR,CAA7C,CAAP;IACD,CAFkB,CAAZ,CAAP;EAGD;;EACD,OAAOJ,IAAP;AACD,CAXD;;AAaA,MAAM;EAAEQ,OAAF;EAAWC;AAAX,IAAwB7B,OAAO,CAAC,MAAD,CAArC;;AACA,MAAM8B,YAAY,GAAG9B,OAAO,CAAC,qBAAD,CAA5B;;AACA,MAAM+B,cAAc,GAAG/B,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAMgC,GAAG,GAAGhC,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMiC,GAAG,GAAGjC,OAAO,CAAC,wBAAD,CAAnB;;AACA,MAAMkC,SAAS,GAAGlC,OAAO,CAAC,qBAAD,CAAzB;;AAEA,MAAMmC,SAAS,GAAGnC,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAMoC,UAAU,GAAG,CACjB,MADiB,EAEjB,SAFiB,EAGjB,iBAHiB,EAIjB,UAJiB,EAKjB,WALiB,EAMjB,UANiB,EAOjB,UAPiB,EAQjB,cARiB,CAAnB,C,CAWA;;AACA,MAAMC,SAAS,GAAG,sCAAlB;AACA,MAAMC,QAAQ,GAAG,oCAAjB,C,CAEA;;AACA,MAAMC,gBAAgB,GAAGC,QAAQ,IAAI;EACnC,IAAI;IACF,OAAOR,GAAG,CAACQ,QAAD,CAAV;EACD,CAFD,CAEE,OAAOC,EAAP,EAAW;IACX,OAAO,EAAP;EACD;AACF,CAND;;AAQA,MAAMC,OAAO,GAAG1C,OAAO,CAAC,cAAD,CAAvB;;AAEA,MAAM2C,iBAAiB,GAAG3C,OAAO,CAAC,yBAAD,CAAjC;;AACA,MAAM;EAAE4C;AAAF,IAAuB5C,OAAO,CAAC,wBAAD,CAApC;;AAEA,MAAM6C,aAAa,GAAGC,IAAI,IAAI;EAC5B,OAAOpC,QAAQ,CAACoC,IAAD,EAAO,MAAP,CAAR,CAAuBC,IAAvB,CAA4BC,CAAC,IAAIA,CAAjC,EAAoCP,EAAE,IAAI;IAC/C;IACA,IAAIA,EAAE,CAACQ,IAAH,KAAY,QAAhB,EAA0B;MACxB,OAAO,EAAP;IACD,CAFD,MAEO;MACL,MAAMR,EAAN;IACD;EACF,CAPM,CAAP;AAQD,CATD;;AAWA,MAAMS,aAAa,GAAGJ,IAAI,IAAI;EAC5B,OAAOlC,IAAI,CAACkC,IAAD,CAAJ,CAAWC,IAAX,CAAgBI,EAAE,IAAIA,EAAE,CAACC,MAAH,EAAtB,EAAmCX,EAAE,IAAI;IAC9C;IACA,IAAIA,EAAE,CAACQ,IAAH,KAAY,QAAhB,EAA0B;MACxB,OAAO,IAAP;IACD,CAFD,MAEO;MACL,MAAMR,EAAN;IACD;EACF,CAPM,CAAP;AAQD,CATD;;AAWA,MAAMY,WAAW,GAAG,CAClB;AACA,SAFkB,EAGlB,cAHkB,EAIlB,kBAJkB,EAKlB,sBALkB,EAMlB,sBANkB,EAOlB,oBAPkB,EAQlB,oBARkB,EASlB,SATkB,EAUlB,SAVkB,EAWlB,IAXkB,EAYlB,KAZkB,EAalB,YAbkB,EAclB,SAdkB,EAelB,gBAfkB,EAgBlB,kBAhBkB,EAiBlB,KAjBkB,EAkBlB,YAlBkB,EAmBlB,YAnBkB,CAApB;AAsBA,MAAMC,YAAY,GAAG,CACnB,WADmB,EAEnB,UAFmB,EAGnB,eAHmB,EAInB,kBAJmB,CAArB;;AAOA,MAAMC,gBAAgB,GAAG,CAACC,GAAD,EAAMC,GAAN,KAAc;EACrC,MAAMC,GAAG,GAAGF,GAAG,CAACC,GAAD,CAAf,CADqC,CAErC;;EACA,OAAQA,GAAG,KAAK,SAAR,IAAqBC,GAArB,IAA4B,OAAOA,GAAP,KAAe,QAA3C,IAAuDA,GAAG,CAACC,IAA5D,GACHD,GAAG,CAACC,IADD,CAEL;EAFK,EAGFD,GAAG,IAAI,EAAE,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAACjC,MAAM,CAACmC,IAAP,CAAYF,GAAZ,EAAiBG,MAA/C,CAAR,GAAkEH,GAAlE,GACA,IAJJ;AAKD,CARD,C,CAUA;;;AACA,MAAMI,aAAa,GAAG,gBAAO7C,IAAP,EAAa8C,IAAb,EAAmBC,QAAnB,EAAyD;EAAA,IAA5BC,GAA4B,uEAAtBhD,IAAsB;EAAA,IAAhBiD,IAAgB,uEAAT,IAAS;EAC7E,MAAMC,IAAI,GAAGtC,QAAQ,CAACoC,GAAD,CAArB;EACA,MAAMG,IAAI,GAAGH,GAAG,KAAKhD,IAAR,IAAgBkD,IAAI,KAAK,cAAtC;EACA,MAAME,OAAO,GAAGJ,GAAG,KAAKhD,IAAR,IAAgB,CAACmD,IAAjB,IAAyBD,IAAI,CAACG,MAAL,CAAY,CAAZ,MAAmB,GAA5D;EACA,MAAMC,QAAQ,GAAGN,GAAG,KAAKhD,IAAR,IAAgBmD,IAAhB,IAAwBC,OAAzC;EAEA,MAAMG,GAAG,GAAG9B,OAAO,CAACzB,IAAD,EAAOgD,GAAP,CAAnB;;EACA,IAAIA,GAAG,KAAKhD,IAAZ,EAAkB;IAChB,MAAMwD,OAAO,GAAG,CAAC,MAAM7D,IAAI,CAACqD,GAAD,CAAX,EAAkBS,KAAlC;;IACA,IAAID,OAAO,GAAGT,QAAd,EAAwB;MACtB,MAAM,2BAA2BQ,GAAjC;IACD;;IACD,IAAI,CAACH,OAAD,IAAY,CAACD,IAAb,IAAqB,CAACL,IAAI,CAACY,QAAL,CAAcH,GAAd,CAA1B,EAA8C;MAC5C,MAAM,4BAA4BA,GAAlC;IACD;;IACDN,IAAI,CAACU,GAAL,CAASJ,GAAT;EACD,CATD,MASO;IACLN,IAAI,GAAG,IAAIW,GAAJ,CAAQ,CAACL,GAAD,CAAR,CAAP;EACD;;EAED,MAAMM,MAAM,GAAGP,QAAQ,GAAGN,GAAH,GAASrC,OAAO,CAACqC,GAAD,EAAM,cAAN,CAAvC;EACA,MAAMc,QAAQ,GAAGd,GAAG,KAAKhD,IAAR,GACbI,OAAO,CAACO,OAAR,CAAgB,CAAC;IAAED,IAAI,EAAE,cAAR;IAAwBqD,WAAW,EAAE,MAAM;EAA3C,CAAD,CAAhB,CADa,GAEblE,OAAO,CAACgE,MAAD,EAAS;IAAE3D,aAAa,EAAE;EAAjB,CAAT,CAFX;EAIA,OAAO4D,QAAQ,CAACE,KAAT,CAAe,MAAM,EAArB,EACJlC,IADI,CACC3B,IAAI,IAAIC,OAAO,CAACC,GAAR,CAAYF,IAAI,CAACG,GAAL,CAAS,MAAMC,GAAN,IAAa;IAC9C,MAAM0D,KAAK,GAAGtD,OAAO,CAACkD,MAAD,EAAStD,GAAG,CAACG,IAAb,CAArB;;IACA,IAAIH,GAAG,CAACwD,WAAJ,MAAqB,CAAC,MAAMG,IAAN,CAAW3D,GAAG,CAACG,IAAf,CAA1B,EAAgD;MAC9C,MAAMmC,aAAa,CAAC7C,IAAD,EAAO8C,IAAP,EAAaC,QAAb,EAAuBkB,KAAvB,EAA8BhB,IAA9B,CAAnB;IACD,CAFD,MAEO,IAAI1C,GAAG,CAAC4D,cAAJ,EAAJ,EAA0B;MAC/B,MAAMC,MAAM,GAAGzD,OAAO,CAACkD,MAAD,EAAS,MAAM/D,QAAQ,CAACmE,KAAD,CAAvB,CAAtB;MACA,MAAMI,KAAK,GAAG,MAAM1E,IAAI,CAACyE,MAAD,CAAJ,CAAaJ,KAAb;MAClB;MAAqC,MAAM,IADzB,CAApB;MAEAf,IAAI,CAACU,GAAL,CAASlC,OAAO,CAACzB,IAAD,EAAOiE,KAAP,CAAhB;MACA;;MACA,IAAII,KAAK,IAAIA,KAAK,CAACN,WAAN,EAAT,IAAgC,CAACd,IAAI,CAACqB,GAAL,CAAS7C,OAAO,CAACzB,IAAD,EAAOoE,MAAP,CAAhB,CAArC,EAAsE;QACpE,MAAMvB,aAAa,CAAC7C,IAAD,EAAO8C,IAAP,EAAaC,QAAb,EAAuBqB,MAAvB,EAA+BnB,IAA/B,CAAnB;MACD;IACF;EACF,CAdyB,CAAZ,CADT,EAgBJnB,IAhBI,CAgBC,MAAM;IACV,IAAIkB,GAAG,KAAKhD,IAAZ,EAAkB;MAChB;IACD,CAHS,CAKV;;;IACA,KAAK,MAAMuE,GAAX,IAAkB,IAAIX,GAAJ,CAAQpD,MAAM,CAACmC,IAAP,CAAYG,IAAI,CAACY,QAAjB,CAAR,CAAlB,EAAuD;MACrD,IAAI,CAACT,IAAI,CAACqB,GAAL,CAASC,GAAT,CAAL,EAAoB;QAClB,MAAM,gCAAgCA,GAAtC;MACD;IACF;EACF,CA3BI,CAAP;AA4BD,CArDD;;AAuDA,MAAMC,eAAe,GAAGC,MAAM,CAAC,iBAAD,CAA9B;;AACA,MAAMC,kBAAkB,GAAGD,MAAM,CAAC,oBAAD,CAAjC;;AACA,MAAME,YAAY,GAAGF,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMG,UAAU,GAAGH,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMI,QAAQ,GAAGJ,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAMK,aAAa,GAAGL,MAAM,CAAC,eAAD,CAA5B;;AACA,MAAMM,gBAAgB,GAAGN,MAAM,CAAC,kBAAD,CAA/B;;AACA,MAAMO,gBAAgB,GAAGP,MAAM,CAAC,kBAAD,CAA/B;;AACA,MAAMQ,oBAAoB,GAAGR,MAAM,CAAC,sBAAD,CAAnC;;AACA,MAAMS,YAAY,GAAGT,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMU,UAAU,GAAGV,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMW,UAAU,GAAGX,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMY,UAAN,CAAiB;EACkB,WAAtBrG,sBAAsB,GAAI;IACnC,OAAOA,sBAAP;EACD;;EAEU,OAAJsG,IAAI,CAAEC,OAAF,EAAW;IACpB,OAAO,IAAIF,UAAJ,CAAeE,OAAf,EAAwBD,IAAxB,EAAP;EACD;;EAEkB,WAARE,QAAQ,GAAI;IACrB,OAAOrE,UAAP;EACD;;EAEiB,aAALsE,KAAK,CAAEF,OAAF,EAAW;IAC3B;IACA;IACA,MAAMG,CAAC,GAAG,IAAIL,UAAJ,CAAeE,OAAf,CAAV;IACAG,CAAC,CAACD,KAAF;IAEA,MAAM,CAACE,EAAD,EAAKC,IAAL,IAAa,MAAMF,CAAC,CAACN,UAAD,CAAD,EAAzB;IAEAM,CAAC,CAACG,QAAF,GAAalF,OAAO,CAAC+E,CAAC,CAAC1F,IAAH,EAClB,CAAC0F,CAAC,CAACI,cAAF,GAAmB,4BAAnB,GACCJ,CAAC,CAACK,cAAF,IAAoBJ,EAApB,GAAyB,gBAAzB,GACA,cAFF,IAEoB,OAHF,CAApB;IAIAD,CAAC,CAACM,cAAF,GAAmB,CAAC,EAAEL,EAAE,IAAIC,IAAR,CAApB;IACAF,CAAC,CAAChD,IAAF,GAAS9B,QAAQ,CAAC8E,CAAC,CAACG,QAAH,CAAjB;;IAEA,IAAI;MACF,IAAIH,CAAC,CAACM,cAAF,IAAoB,CAACN,CAAC,CAACO,eAA3B,EAA4C;QAC1C,MAAMC,IAAI,GAAGjF,SAAS,CAAC,MAAMW,aAAa,CAAC8D,CAAC,CAACG,QAAH,CAApB,CAAtB;;QACA,IAAIK,IAAI,CAACD,eAAL,GAAuBjH,sBAA3B,EAAmD;UACjD0G,CAAC,CAACO,eAAF,GAAoBC,IAAI,CAACD,eAAzB;QACD;MACF;IACF,CAPD,CAOE,OAAOE,CAAP,EAAU,CAAE;;IAEd,OAAOT,CAAP;EACD;;EAEkB,OAAZU,YAAY,CAAEC,IAAF,EAAQrG,IAAR,EAA4B;IAAA,IAAduF,OAAc,uEAAJ,EAAI;;IAC7C,IAAIc,IAAI,CAACC,MAAT,EAAiB;MACf,OAAO;QACL/E,QAAQ,EAAEE,OAAO,CAACzB,IAAD,EAAOqG,IAAI,CAACE,QAAZ,CADZ;QAELC,IAAI,EAAE;MAFD,CAAP;IAID;;IAED,MAAMC,IAAI,GAAG,EAAb;IACArE,WAAW,CAACsE,OAAZ,CAAoBlE,GAAG,IAAI;MACzB,MAAMC,GAAG,GAAGH,gBAAgB,CAAC+D,IAAI,CAACM,OAAN,EAAenE,GAAf,CAA5B;;MACA,IAAIC,GAAJ,EAAS;QACPgE,IAAI,CAACjE,GAAG,CAACoE,OAAJ,CAAY,IAAZ,EAAkB,EAAlB,CAAD,CAAJ,GAA8BnE,GAA9B;MACD;IACF,CALD,EAT6C,CAe7C;IACA;IACA;;IACA,MAAMoE,KAAK,GAAGR,IAAI,CAACS,WAAnB;;IACA,IAAID,KAAK,KAAKR,IAAI,KAAKA,IAAI,CAACU,IAAd,IAAsBF,KAAK,KAAKR,IAAI,CAAC3F,IAA1C,CAAT,EAA0D;MACxD+F,IAAI,CAAC/F,IAAL,GAAYmG,KAAZ;IACD;;IAED,IAAIR,IAAI,CAACW,KAAL,IAAcX,IAAI,CAACM,OAAL,CAAaM,eAA/B,EAAgD;MAC9CR,IAAI,CAACQ,eAAL,GAAuBZ,IAAI,CAACM,OAAL,CAAaM,eAApC;IACD;;IAED5E,YAAY,CAACqE,OAAb,CAAqBlE,GAAG,IAAI;MAC1B,IAAI6D,IAAI,CAAC7D,GAAD,CAAR,EAAe;QACbiE,IAAI,CAACjE,GAAD,CAAJ,GAAY6D,IAAI,CAAC7D,GAAD,CAAhB;MACD;IACF,CAJD;IAMA,MAAMjB,QAAQ,GAAGG,iBAAiB,CAAC2E,IAAI,CAAC9E,QAAN,EAAgB8E,IAAI,CAACrG,IAArB,EAA2BA,IAA3B,EAAiC,IAAjC,CAAlC,CAjC6C,CAkC7C;;IACA,IAAI,CAACuB,QAAL,EAAe,CACb;IACD,CAFD,MAEO,IAAI8E,IAAI,CAACa,oBAAT,EAA+B;MACpCT,IAAI,CAAClF,QAAL,GAAgBI,gBAAgB,CAACJ,QAAD,EAAWgE,OAAX,CAAhC;IACD,CAFM,MAEA;MACLkB,IAAI,CAAClF,QAAL,GAAgBA,QAAhB;IACD;;IAED,IAAI8E,IAAI,CAACc,UAAT,EAAqB;MACnBV,IAAI,CAACU,UAAL,GAAkB,IAAlB;IACD,CAFD,MAEO;MACL,IAAId,IAAI,CAACe,IAAT,EAAe;QACbX,IAAI,CAACW,IAAL,GAAY,IAAZ;MACD;;MACD,IAAIf,IAAI,CAACgB,GAAT,EAAc;QACZZ,IAAI,CAACY,GAAL,GAAW,IAAX;MACD;;MACD,IAAIhB,IAAI,CAACiB,QAAT,EAAmB;QACjBb,IAAI,CAACa,QAAL,GAAgB,IAAhB;MACD;;MACD,IAAIjB,IAAI,CAACkB,WAAL,IAAoB,CAAClB,IAAI,CAACgB,GAA1B,IAAiC,CAAChB,IAAI,CAACiB,QAA3C,EAAqD;QACnDb,IAAI,CAACc,WAAL,GAAmB,IAAnB;MACD;IACF;;IACD,OAAOd,IAAP;EACD;;EAEDe,WAAW,GAAgB;IAAA,IAAdjC,OAAc,uEAAJ,EAAI;IACzB,MAAM;MACJvF,IADI;MAEJyH,MAAM,GAAG,CAFL;MAGJC,OAAO,GAAG,IAHN;MAIJ3B,cAAc,GAAG,KAJb;MAKJD,cAAc,GAAG,KALb;MAMJG,eANI;MAOJ0B,cAAc,GAAG;IAPb,IAQFpC,OARJ;IAUA,KAAKU,eAAL,GAAuBH,cAAc,GAAG,CAAH,GACjCG,eAAe,GAAG2B,QAAQ,CAAC3B,eAAD,EAAkB,EAAlB,CAAX,GACf,IAFJ;IAGA,KAAKzB,eAAL,IAAwB,IAAIqD,GAAJ,EAAxB;IACA,KAAKC,IAAL,GAAY,IAAZ;IACA,KAAK9H,IAAL,GAAYW,OAAO,CAACX,IAAI,IAAI,GAAT,CAAnB;IACA,KAAK6F,QAAL,GAAgB,IAAhB;IACA,KAAK/C,IAAL,GAAY,IAAZ;IACA,KAAK2E,MAAL,GAAcA,MAAd;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAK1B,cAAL,GAAsB,KAAtB;IACA,KAAKtD,IAAL,GAAY,IAAZ;IACA,KAAKqF,QAAL,GAAgB,IAAhB;IACA,KAAKjC,cAAL,GAAsBA,cAAtB;IACA,KAAKkC,YAAL,GAAoB,IAApB;IACA,KAAKL,cAAL,GAAsBA,cAAtB,CA1ByB,CA2BzB;;IACA,KAAK5B,cAAL,GAAsBA,cAAtB;EACD,CAnIc,CAqIf;EACA;EACA;EACA;EACA;;;EACAkC,aAAa,CAAEC,IAAF,EAAsB;IAAA,IAAd3C,OAAc,uEAAJ,EAAI;IACjC2C,IAAI,GAAGnH,GAAG,CAACmH,IAAD,CAAV;IACA,MAAM;MAAEH,QAAF;MAAY/B;IAAZ,IAA+B,IAArC;IACA,MAAMmC,WAAW,GAAGJ,QAAQ,IAAI,CAAC/B,cAAjC;IACA,MAAMoC,QAAQ,GAAGD,WAAW,IAAIJ,QAAQ,CAACM,OAAT,CAAiBC,GAAjB,CAAqBJ,IAAI,CAACK,GAA1B,CAAhC;;IACA,IAAIH,QAAQ,IAAIA,QAAQ,CAACI,OAAzB,EAAkC;MAChC;MACA;MACA,MAAM;QAAEjH,QAAF;QAAYiH,OAAZ;QAAqBC;MAArB,IAAmCL,QAAzC;MACA,MAAMM,SAAS,GAAGR,IAAI,CAACS,QAAL,IAAiBvH,SAAS,CAAC8C,IAAV,CAAe3C,QAAf,CAAnC;MACA,MAAMqH,QAAQ,GAAGV,IAAI,CAACS,QAAL,IAAiB,CAACD,SAAlB,IAA+BrH,QAAQ,CAAC6C,IAAT,CAAc3C,QAAd,CAAhD;MACA,MAAMsH,KAAK,GAAGD,QAAQ,IAAIF,SAA1B,CANgC,CAOhC;MACA;;MACA,MAAMI,GAAG,GAAGD,KAAK,IAAI/H,cAAc,CAACoH,IAAI,CAACxH,IAAN,EAAYa,QAAZ,CAAvB,IAAgD,EAA5D;MACA,MAAMwH,KAAK,GAAGD,GAAG,CAACpI,IAAJ,KAAawH,IAAI,CAACxH,IAAlB,IAA0BoI,GAAG,CAACN,OAAJ,KAAgBA,OAA1C,GAAoDA,OAApD,GACVK,KAAK,IAAIC,GAAG,CAACpI,IAAb,IAAqBoI,GAAG,CAACN,OAAzB,GAAoC,OAAMM,GAAG,CAACpI,IAAK,IAAGoI,GAAG,CAACN,OAAQ,EAAlE,GACAjH,QAFJ;;MAGA,IAAIwH,KAAJ,EAAW;QACTxD,OAAO,CAAChE,QAAR,GAAmBA,QAAQ,CAACqF,OAAT,CAAiBxF,SAAjB,EAA4B,6BAA5B,CAAnB;QACAmE,OAAO,CAACkD,SAAR,GAAoBA,SAApB;QACA,OAAO1H,GAAG,CAAE,GAAEmH,IAAI,CAACxH,IAAK,IAAGqI,KAAM,EAAvB,CAAV;MACD;IACF;;IACD,OAAOb,IAAP;EACD,CAnKc,CAqKf;EACA;;;EACAzC,KAAK,GAAI;IACP,KAAKqC,IAAL,GAAY,IAAZ;IACA,KAAKtD,eAAL,IAAwB,IAAIqD,GAAJ,EAAxB;IACA,MAAM5B,eAAe,GAAG,KAAKA,eAAL,IAAwBjH,sBAAhD;IACA,KAAKgK,uBAAL,GAA+B/C,eAA/B;IACA,KAAKnD,IAAL,GAAY;MACVmD,eADU;MAEVgD,QAAQ,EAAE,IAFA;MAGVvF,QAAQ,EAAE,EAHA;MAIVwF,YAAY,EAAE;IAJJ,CAAZ;EAMD;;EAEY,CAAZhE,YAAY,IAAK;IAChB,OAAO,KAAKa,cAAL,GAAsB,CAC3B,KAAK/F,IAAL,GAAY,sBADe,CAAtB,GAEH,KAAK8F,cAAL,GAAsB,CACxB,IADwB,EAExB,KAAK9F,IAAL,GAAY,kCAFY,CAAtB,GAGA,CACF,KAAKA,IAAL,GAAY,sBADV,EAEF,KAAKA,IAAL,GAAY,oBAFV,EAGF,KAAKA,IAAL,GAAY,YAHV,CALJ;EAUD;;EAEU,CAAVmF,UAAU,IAAK;IACd,OAAO/E,OAAO,CAACC,GAAR,CAAY,KAAK6E,YAAL,IAAqB5E,GAArB,CAAyB6I,EAAE,IAAIA,EAAE,IAAIvH,aAAa,CAACuH,EAAD,CAAlD,CAAZ,CAAP;EACD;;EAEU,CAAV/D,UAAU,IAAK;IACd;IACA;IACA,OAAOhF,OAAO,CAACC,GAAR,CAAY,KAAK6E,YAAL,IAAqBkE,KAArB,CAA2B,CAA3B,EAA8B,CAA9B,EAChB9I,GADgB,CACZ6I,EAAE,IAAIA,EAAE,IAAIlH,aAAa,CAACkH,EAAD,CADb,CAAZ,CAAP;EAED;;EAEDE,sBAAsB,CAAEC,eAAF,EAAmB;IACvC;IACA;IACA;IACA,MAAM;MACJ,CAAC7E,MAAM,CAAC8E,GAAP,CAAW,QAAX,CAAD,GAAwB9B,MADpB;MAEJ,CAAChD,MAAM,CAAC8E,GAAP,CAAW,SAAX,CAAD,GAAyB7B;IAFrB,IAGF4B,eAHJ;IAIA,KAAK7B,MAAL,GAAcA,MAAM,KAAK+B,SAAX,GAAuB/B,MAAvB,GAAgC,KAAKA,MAAnD;IACA,KAAKC,OAAL,GAAeA,OAAO,KAAK8B,SAAZ,GAAwB9B,OAAxB,GAAkC,KAAKA,OAAtD;EACD;;EAEDpC,IAAI,GAAI;IACN;IACA;IACA,OAAO,KAAKH,UAAL,IAAmBrD,IAAnB,CAAwB,QAAsB;MAAA,IAArB,CAAC6D,EAAD,EAAKC,IAAL,EAAW6D,IAAX,CAAqB;MACnD,MAAM3G,IAAI,GAAG6C,EAAE,IAAIC,IAAN,IAAc,EAA3B,CADmD,CAGnD;MACA;MACA;;MACA,KAAKC,QAAL,GAAgBlF,OAAO,CAAC,KAAKX,IAAN,EACrB,CAAC,KAAK8F,cAAL,GAAsB,4BAAtB,GACC,KAAKC,cAAL,IAAuBJ,EAAvB,GAA4B,gBAA5B,GACA,cAFF,IAEoB,OAHC,CAAvB;MAKA,KAAKjD,IAAL,GAAY9B,QAAQ,CAAC,KAAKiF,QAAN,CAApB;MACA,KAAKG,cAAL,GAAsB,CAAC,CAAClD,IAAxB;;MAEA,IAAI2G,IAAJ,EAAU;QACR,KAAK1B,QAAL,GAAgB,IAAI1I,QAAJ,EAAhB,CADQ,CAER;;QACA,IAAI;UACF,KAAK0I,QAAL,CAAc2B,KAAd,CAAoBD,IAApB;QACD,CAFD,CAEE,OAAOE,CAAP,EAAU,CAAE;MACf;;MAED,OAAO7G,IAAI,GAAG7B,SAAS,CAAC6B,IAAD,CAAZ,GAAqB,EAAhC;IACD,CAvBM,EAuBJhB,IAvBI,CAuBC,MAAMgB,IAAN,IAAc;MACpB,KAAKuG,sBAAL,CAA4BvG,IAA5B;;MAEA,IAAI,CAAC,KAAKgD,cAAN,IAAwB,CAAChD,IAAI,CAACY,QAAlC,EAA4C;QAC1C,OAAOZ,IAAP;MACD,CALmB,CAOpB;;;MACA,MAAMC,QAAQ,GAAG,CAAC,CAAC,MAAMpD,IAAI,CAAC,KAAKkG,QAAN,CAAX,EAA4BpC,KAA7B,GAAqC,EAAtD;MACA,MAAMZ,aAAa,CAAC,KAAK7C,IAAN,EAAY8C,IAAZ,EAAkBC,QAAlB,CAAnB,CAToB,CAWpB;;MACA,OAAOD,IAAP;IACD,CApCM,EAoCJkB,KApCI,CAoCExC,EAAE,IAAI;MACb;MACA,IAAI,OAAO,KAAKqE,QAAZ,KAAyB,QAA7B,EAAuC;QACrC,MAAMtC,GAAG,GAAG9B,OAAO,CAAC,KAAKzB,IAAN,EAAY,KAAK6F,QAAjB,CAAnB;QACAzG,GAAG,CAACwK,OAAJ,CAAY,YAAZ,EAA2B,kBAAiBrG,GAAI,EAAhD,EAAmD/B,EAAnD;MACD,CAHD,MAGO;QACLpC,GAAG,CAACwK,OAAJ,CAAY,YAAZ,EAA2B,kBAAiB,KAAK5J,IAAK,EAAtD,EAAyDwB,EAAzD;MACD;;MACD,KAAKwG,YAAL,GAAoBxG,EAApB;MACA,KAAKwE,cAAL,GAAsB,KAAtB;MACA,KAAK6D,eAAL,GAAuB,KAAvB;MACA,OAAO,EAAP;IACD,CAhDM,EAgDJ/H,IAhDI,CAgDC8D,IAAI,IAAI;MACd,MAAMK,eAAe,GAAG,KAAKA,eAAL,GAAuB,KAAKA,eAA5B,GACpB6D,IAAI,CAACC,GAAL,CAASnE,IAAI,CAACK,eAAL,IAAwB,CAAjC,EAAoCjH,sBAApC,CADJ;MAEA,KAAK8D,IAAL,GAAY,EACV,GAAG8C,IADO;QAEVK,eAAe,EAAEA,eAFP;QAGVgD,QAAQ,EAAE,IAHA;QAIVvF,QAAQ,EAAEkC,IAAI,CAAClC,QAAL,IAAiB,EAJjB;QAKVwF,YAAY,EAAEtD,IAAI,CAACsD,YAAL,IAAqB;MALzB,CAAZ;MAQA,KAAKF,uBAAL,GAA+BpD,IAAI,CAACK,eAApC,CAXc,CAYd;MACA;MACA;;MACA,IAAI,CAAC,KAAKA,eAAV,EAA2B;QACzB,KAAKA,eAAL,GAAuB,KAAKnD,IAAL,CAAUmD,eAAV,GAA4BA,eAAnD;MACD;;MACD,KAAK4D,eAAL,GAAuB,KAAK7D,cAAL,IACrB,EAAEJ,IAAI,CAACK,eAAL,IAAwB,CAA1B,CADqB,IACW,CAACL,IAAI,CAACqD,QADxC,CAlBc,CAqBd;;MACA,IAAIrD,IAAI,CAACsD,YAAL,IAAqB,CAACtD,IAAI,CAAClC,QAA/B,EAAyC;QACvC,OAAO1C,GAAG,CAAC,KAAKhB,IAAL,GAAY,eAAb,CAAH,CAAiC8B,IAAjC,CAAsCS,GAAG,IAAIA,GAA7C,EAAkDf,EAAE,KAAK,EAAL,CAApD,EACJM,IADI,CACCS,GAAG,IAAI;UACX,KAAKsC,QAAL,EAAe,EAAf,EAAmB,IAAnB,EAAyB,KAAK/B,IAA9B;;UACA,KAAKkC,gBAAL,EAAuBzC,GAAvB;QACD,CAJI,CAAP;MAKD;IACF,CA7EM,EA8EJT,IA9EI,CA8EC,MAAM,IA9EP,CAAP;EA+ED;;EAEQ,CAAR+C,QAAQ,EAAGmF,QAAH,EAAatJ,IAAb,EAAmBkF,IAAnB,EAAyB;IAChC;IACA,MAAMa,IAAI,GAAG,KAAK3B,aAAL,EAAoBkF,QAApB,EAA8BtJ,IAA9B,EAAoCkF,IAApC,CAAb,CAFgC,CAGhC;;;IACA,IAAIa,IAAI,CAACD,IAAT,EAAe;MACbwD,QAAQ,GAAGvD,IAAI,CAAClF,QAAhB;IACD;;IACD,IAAIqE,IAAI,CAACsD,YAAT,EAAuB;MACrB,KAAK,MAAM,CAACxI,IAAD,EAAOuJ,GAAP,CAAX,IAA0BzJ,MAAM,CAAC6H,OAAP,CAAezC,IAAI,CAACsD,YAApB,CAA1B,EAA6D;QAC3D,MAAM3E,GAAG,GAAGyF,QAAQ,IAAIA,QAAQ,GAAG,GAAH,GAAS,EAArB,CAAR,GAAmC,eAAnC,GAAqDtJ,IAAjE;;QACA,KAAKmE,QAAL,EAAeN,GAAf,EAAoB7D,IAApB,EAA0BuJ,GAA1B;MACD;IACF;EACF,CAzTc,CA2Tf;EACA;EACA;;;EACiB,CAAhBjF,gBAAgB,EAAGzC,GAAH,EAAQ;IACvB;IACA;IACA;IACA,MAAMwE,IAAI,GAAG,KAAKjE,IAAL,CAAUY,QAAV,CAAmB,EAAnB,CAAb;IACAtB,WAAW,CAACsE,OAAZ,CAAoBlE,GAAG,IAAI;MACzB,MAAMC,GAAG,GAAGH,gBAAgB,CAACC,GAAD,EAAMC,GAAN,CAA5B;MACA,MAAM0H,CAAC,GAAG1H,GAAG,CAACoE,OAAJ,CAAY,IAAZ,EAAkB,EAAlB,CAAV;;MACA,IAAInE,GAAJ,EAAS;QACPsE,IAAI,CAACmD,CAAD,CAAJ,GAAUzH,GAAV;MACD;IACF,CAND;;IAQA,KAAK,MAAM,CAAC8B,GAAD,EAAMkC,IAAN,CAAX,IAA0BjG,MAAM,CAAC6H,OAAP,CAAe,KAAKvF,IAAL,CAAUY,QAAzB,CAA1B,EAA8D;MAC5D,IAAI,CAAC+C,IAAI,CAACwC,QAAN,IAAkB,CAAC1E,GAAvB,EAA4B;QAC1B;MACD,CAH2D,CAK5D;MACA;MACA;MACA;MACA;MACA;;;MACA,KAAK,MAAM,CAAC7D,IAAD,EAAOwH,IAAP,CAAX,IAA2B1H,MAAM,CAAC6H,OAAP,CAAe5B,IAAI,CAACwC,QAApB,CAA3B,EAA0D;QACxD,MAAMgB,GAAG,GAAG,KAAKlF,gBAAL,EAAuBR,GAAvB,EAA4B7D,IAA5B,CAAZ,CADwD,CAExD;;;QACA,MAAMyJ,OAAO,GAAGF,GAAG,IAAIA,GAAG,CAAC3C,QAAX,IAAuB,CAACb,IAAI,CAACa,QAA7B,GACZ,sBADY;QAEZ;QACF2C,GAAG,IAAIA,GAAG,CAAC5C,GAAX,IAAkB,CAACZ,IAAI,CAACY,GAAxB,GAA8B,iBAA9B,CACA;QACA;QACA;QAHA,EAIE,cAPJ;QAQAZ,IAAI,CAAC0D,OAAD,CAAJ,GAAgB1D,IAAI,CAAC0D,OAAD,CAAJ,IAAiB,EAAjC;QACA1D,IAAI,CAAC0D,OAAD,CAAJ,CAAczJ,IAAd,IAAsBwH,IAAtB;MACD;;MACD,OAAOzB,IAAI,CAACwC,QAAZ;IACD;EACF;;EAEgB,CAAhBlE,gBAAgB,EAAGR,GAAH,EAAQ7D,IAAR,EAAc;IAC7B,KAAK,IAAIV,IAAI,GAAGuE,GAAhB,EAAqB,IAArB,EAA2BvE,IAAI,GAAGA,IAAI,CAAC4G,OAAL,CAAa,cAAb,EAA6B,EAA7B,CAAlC,EAAoE;MAClE,MAAMwD,KAAK,GAAI,GAAEpK,IAAK,GAAEA,IAAI,GAAG,GAAH,GAAS,EAAG,gBAAeU,IAAK,EAA5D;;MACA,IAAI,KAAKoC,IAAL,CAAUY,QAAV,CAAmB0G,KAAnB,CAAJ,EAA+B;QAC7B,OAAO,KAAKtH,IAAL,CAAUY,QAAV,CAAmB0G,KAAnB,CAAP;MACD;;MAED,IAAI,CAACpK,IAAL,EAAW;QACT;MACD;IACF;;IACD,OAAO,IAAP;EACD;;EAEY,CAAZ2E,YAAY,EAAGiB,IAAH,EAAS5F,IAAT,EAAsB;IAAA,IAAPqK,CAAO,uEAAH,CAAG;;IACjC,IAAI,CAACzE,IAAL,EAAW;MACT,OAAO,IAAP;IACD;;IAED,IAAI5F,IAAI,CAACqK,CAAD,CAAJ,KAAY,EAAhB,EAAoB;MAClBA,CAAC;IACF;;IAED,IAAIA,CAAC,IAAIrK,IAAI,CAAC4C,MAAd,EAAsB;MACpB,OAAOgD,IAAP;IACD;;IAED,IAAI,CAACA,IAAI,CAACsD,YAAV,EAAwB;MACtB,OAAO,IAAP;IACD;;IAED,OAAO,KAAKvE,YAAL,EAAmBiB,IAAI,CAACsD,YAAL,CAAkBlJ,IAAI,CAACqK,CAAD,CAAtB,CAAnB,EAA+CrK,IAA/C,EAAqDqK,CAAC,GAAG,CAAzD,CAAP;EACD,CAxYc,CA0Yf;EACA;;;EACW,CAAVzF,UAAU,EAAG5E,IAAH,EAAS;IAClB,OAAOyB,OAAO,CAAC,KAAKzB,IAAN,EAAYW,OAAO,CAAC,KAAKX,IAAN,EAAYA,IAAZ,CAAnB,CAAd;EACD;;EAEDsK,MAAM,CAAEC,QAAF,EAAY;IAChB,IAAI,CAAC,KAAKzH,IAAV,EAAgB;MACd,MAAM,IAAI0H,KAAJ,CAAU,2CAAV,CAAN;IACD;;IACD,MAAMR,QAAQ,GAAG,KAAKpF,UAAL,EAAiB2F,QAAjB,CAAjB;;IACA,KAAK/F,eAAL,EAAsB8F,MAAtB,CAA6BN,QAA7B;;IAEA,OAAO,KAAKlH,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,CAAP;IACA,MAAMhK,IAAI,GAAGgK,QAAQ,CAACS,KAAT,CAAe,wBAAf,CAAb;IACA,MAAM/J,IAAI,GAAGV,IAAI,CAAC0K,GAAL,EAAb;;IACA,MAAMC,KAAK,GAAG,KAAKhG,YAAL,EAAmB,KAAK7B,IAAxB,EAA8B9C,IAA9B,CAAd;;IACA,IAAI2K,KAAK,IAAIA,KAAK,CAACzB,YAAnB,EAAiC;MAC/B,OAAOyB,KAAK,CAACzB,YAAN,CAAmBxI,IAAnB,CAAP;IACD;EACF;;EAED4H,GAAG,CAAEiC,QAAF,EAAY;IACb,IAAI,CAAC,KAAKzH,IAAV,EAAgB;MACd,MAAM,IAAI0H,KAAJ,CAAU,2CAAV,CAAN;IACD;;IAED,MAAMR,QAAQ,GAAG,KAAKpF,UAAL,EAAiB2F,QAAjB,CAAjB;;IACA,IAAI,KAAK/F,eAAL,EAAsBF,GAAtB,CAA0B0F,QAA1B,CAAJ,EAAyC;MACvC,KAAKtF,kBAAL,EAAyBsF,QAAzB;IACD,CARY,CAUb;IACA;;;IACA,IAAI,KAAKlH,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,CAAJ,EAAkC;MAChC,OAAO,KAAKlH,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,CAAP;IACD,CAdY,CAgBb;IACA;;;IACA,MAAMhK,IAAI,GAAGgK,QAAQ,CAACS,KAAT,CAAe,wBAAf,CAAb;IACA,MAAM/J,IAAI,GAAGV,IAAI,CAACA,IAAI,CAAC4C,MAAL,GAAc,CAAf,CAAjB;;IACA,MAAMgD,IAAI,GAAG,KAAKjB,YAAL,EAAmB,KAAK7B,IAAxB,EAA8B9C,IAA9B,CAAb;;IAEA,OAAO,KAAK8E,aAAL,EAAoBkF,QAApB,EAA8BtJ,IAA9B,EAAoCkF,IAApC,CAAP;EACD;;EAEa,CAAbd,aAAa,EAAGkF,QAAH,EAAatJ,IAAb,EAAmBkF,IAAnB,EAAyB;IACrC;IACA;IACA;IACA;IACA,IAAI,CAACA,IAAL,EAAW;MACT,OAAO,EAAP;IACD,CAPoC,CASrC;IACA;;;IACA,MAAMsC,IAAI,GAAGrH,YAAY,CAACH,IAAD,EAAOkF,IAAP,EAAa,KAAK5F,IAAlB,CAAzB;;IAEA,IAAIkI,IAAI,CAACxF,IAAL,KAAc,WAAlB,EAA+B;MAC7B;MACA;MACA;MACA,MAAM0B,MAAM,GAAG3C,OAAO,CAAC,KAAKzB,IAAN,EAAYkI,IAAI,CAAC0C,SAAjB,CAAtB;MACA,KAAK9H,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,IAA+B;QAC7BxD,IAAI,EAAE,IADuB;QAE7BjF,QAAQ,EAAE6C;MAFmB,CAA/B,CAL6B,CAS7B;MACA;;MACA,IAAI,CAAC,KAAKtB,IAAL,CAAUY,QAAV,CAAmBU,MAAnB,CAAL,EAAiC;QAC/B,KAAKU,aAAL,EAAoBV,MAApB,EAA4B1D,IAA5B,EAAkC,EAAE,GAAGkF,IAAL;UAAW4C,OAAO,EAAE;QAApB,CAAlC;MACD;;MACD,OAAO,KAAK1F,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,CAAP;IACD;;IAED,MAAMvD,IAAI,GAAG,EAAb,CA9BqC,CA+BrC;;IACA,IAAIb,IAAI,CAACqD,QAAL,IAAiB,OAAOrD,IAAI,CAACqD,QAAZ,KAAyB,QAA9C,EAAwD;MACtDxC,IAAI,CAACwC,QAAL,GAAgBrD,IAAI,CAACqD,QAArB;IACD;;IAED,IAAIrD,IAAI,CAAC0B,QAAT,EAAmB;MACjBb,IAAI,CAACa,QAAL,GAAgB,IAAhB;IACD;;IACD,IAAI1B,IAAI,CAACyB,GAAT,EAAc;MACZZ,IAAI,CAACY,GAAL,GAAW,IAAX;IACD,CAzCoC,CA2CrC;IACA;;;IACA,IAAI2C,QAAQ,KAAK,EAAjB,EAAqB;MACnBvD,IAAI,CAAC/F,IAAL,GAAYkF,IAAI,CAAClF,IAAjB;IACD,CA/CoC,CAiDrC;;;IACA,IAAIkF,IAAI,CAAC6C,SAAT,EAAoB;MAClBhC,IAAI,CAACgC,SAAL,GAAiB7C,IAAI,CAAC6C,SAAtB;IACD;;IAED,IAAI7C,IAAI,CAAC4C,OAAL,IAAgB,CAAC5C,IAAI,CAAC6C,SAA1B,EAAqC;MACnC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIP,IAAI,CAACxF,IAAL,KAAc,KAAlB,EAAyB;QACvB+D,IAAI,CAAClF,QAAL,GAAgBG,iBAAiB,CAACwG,IAAD,EAAO,KAAKlI,IAAZ,EAAkB,KAAKA,IAAvB,CAAjC,CADuB,CAGvB;;QACA,OAAO,KAAK8C,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,IAA+BvD,IAAtC;MACD,CALD,MAKO,IAAIyB,IAAI,CAACS,QAAT,EAAmB;QACxB;QACA;QACAlC,IAAI,CAAC+B,OAAL,GAAe5C,IAAI,CAAC4C,OAApB;MACD,CApBkC,CAqBnC;MACA;;IACD,CA7EoC,CA+ErC;IACA;IACA;IACA;IACA;;;IACA,IAAI5C,IAAI,CAACrE,QAAL,IAAkB2G,IAAI,CAACxF,IAAL,IAAa,CAACwF,IAAI,CAACS,QAAzC,EAAoD;MAClD,IAAIT,IAAI,CAACS,QAAT,EAAmB;QACjBlC,IAAI,CAAClF,QAAL,GAAgBqE,IAAI,CAACrE,QAArB;MACD,CAFD,MAEO,IAAI2G,IAAI,CAACxF,IAAL,KAAc,MAAlB,EAA0B;QAC/B+D,IAAI,CAAClF,QAAL,GAAgBG,iBAAiB,CAACwG,IAAD,EAAO,KAAKlI,IAAZ,EAAkB,KAAKA,IAAvB,EAA6B,IAA7B,CAAjC;MACD,CAFM,MAEA,IAAIkI,IAAI,CAAC0C,SAAT,EAAoB;QACzBnE,IAAI,CAAClF,QAAL,GAAgB2G,IAAI,CAAC0C,SAArB;MACD;IACF,CA5FoC,CA8FrC;IACA;IACA;;;IACA,IAAI,CAACnE,IAAI,CAAC+B,OAAV,EAAmB;MACjB,IAAIN,IAAI,CAACxF,IAAL,KAAc,MAAd,IAAwBwF,IAAI,CAACxF,IAAL,KAAc,QAA1C,EAAoD;QAClD,MAAMmI,OAAO,GAAG/J,cAAc,CAACoH,IAAI,CAACxH,IAAN,EAAYwH,IAAI,CAAC0C,SAAjB,CAAd,IACd9J,cAAc,CAACoH,IAAI,CAACxH,IAAN,EAAY+F,IAAI,CAAClF,QAAjB,CADhB;;QAEA,IAAIsJ,OAAJ,EAAa;UACXpE,IAAI,CAAC+B,OAAL,GAAeqC,OAAO,CAACrC,OAAvB;;UACA,IAAIqC,OAAO,CAACnK,IAAR,KAAiBA,IAArB,EAA2B;YACzB+F,IAAI,CAAC/F,IAAL,GAAYmK,OAAO,CAACnK,IAApB;UACD;QACF;MACF,CATD,MASO,IAAIwH,IAAI,CAACxF,IAAL,KAAc,OAAlB,EAA2B;QAChC+D,IAAI,CAAC/F,IAAL,GAAYwH,IAAI,CAAC4C,OAAL,CAAapK,IAAzB;QACA+F,IAAI,CAAC+B,OAAL,GAAeN,IAAI,CAAC4C,OAAL,CAAaF,SAA5B;MACD,CAHM,MAGA,IAAI1C,IAAI,CAACxF,IAAL,KAAc,SAAlB,EAA6B;QAClC+D,IAAI,CAAC+B,OAAL,GAAeN,IAAI,CAAC0C,SAApB;MACD,CAfgB,CAgBjB;;IACD;;IAED,IAAIhF,IAAI,CAACmF,OAAT,EAAkB;MAChBtE,IAAI,CAACuE,QAAL,GAAgB,IAAhB;IACD,CAtHoC,CAwHrC;;;IACA,OAAO,KAAKlI,IAAL,CAAUY,QAAV,CAAmBsG,QAAnB,IAA+BvD,IAAtC;EACD;;EAED9C,GAAG,CAAE0C,IAAF,EAAQ;IACT,IAAI,CAAC,KAAKvD,IAAV,EAAgB;MACd,MAAM,IAAI0H,KAAJ,CAAU,2CAAV,CAAN;IACD,CAHQ,CAKT;;;IACA,MAAMjG,GAAG,GAAG9C,OAAO,CAAC,KAAKzB,IAAN,EAAYqG,IAAI,CAACrG,IAAjB,CAAnB;;IACA,IAAIqG,IAAI,CAACrG,IAAL,KAAc,KAAKA,IAAvB,EAA6B;MAC3B,KAAK8H,IAAL,GAAYzB,IAAZ;IACD,CATQ,CAWT;IACA;;;IACA,IAAIA,IAAI,CAAC9E,QAAL,KAAkB,IAAlB,IAA0B8E,IAAI,CAACoC,SAAL,KAAmB,IAAjD,EAAuD;MACrD,MAAM;QACJlH,QADI;QAEJkH,SAFI;QAGJwC,aAHI;QAIJzC;MAJI,IAKF,KAAKF,GAAL,CAASjC,IAAI,CAACrG,IAAd,CALJ;MAOA,MAAMkL,SAAS,GAAG,CAAC3J,QAAD,GAAY,IAAZ,GACd,CAAC,SAAS2C,IAAT,CAAc3C,QAAd,CAAD,GAA2BA,QAA3B,CACF;MADE,EAEC,QAAOZ,OAAO,CAAC,KAAKX,IAAN,EAAYuB,QAAQ,CAAC6H,KAAT,CAAe,CAAf,CAAZ,CAAP,CAAsCxC,OAAtC,CAA8C,IAA9C,EAAoD,KAApD,CAA2D,EAHvE,CARqD,CAarD;MACA;;MACA,MAAMuE,UAAU,GAAG,CAAC5J,QAAD,IAAa,CAAC8E,IAAI,CAAC9E,QAAnB,IACjB8E,IAAI,CAAC9E,QAAL,KAAkB2J,SADpB;MAEA,MAAME,WAAW,GAAG,CAAC3C,SAAD,IAAc,CAACpC,IAAI,CAACoC,SAApB,IAClBpC,IAAI,CAACoC,SAAL,KAAmBA,SADrB;MAEA,MAAM4C,SAAS,GAAG,CAAC7C,OAAD,IAAY,CAACnC,IAAI,CAACmC,OAAlB,IAA6BA,OAAO,KAAKnC,IAAI,CAACmC,OAAhE;MAEA,MAAM8C,KAAK,GAAG,CAAC/J,QAAQ,IAAIkH,SAAZ,IAAyBD,OAA1B,KACZ2C,UADY,IACEC,WADF,IACiBC,SAD/B;;MAGA,IAAIC,KAAJ,EAAW;QACTjF,IAAI,CAAC9E,QAAL,GAAgB8E,IAAI,CAAC9E,QAAL,IAAiB2J,SAAjB,IAA8B,IAA9C;QACA7E,IAAI,CAACoC,SAAL,GAAiBpC,IAAI,CAACoC,SAAL,IAAkBA,SAAlB,IAA+B,IAAhD;QACApC,IAAI,CAAC4E,aAAL,GAAqB5E,IAAI,CAAC4E,aAAL,IAAsBA,aAAtB,IAAuC,KAA5D;MACD,CAJD,MAIO;QACL;QACA,MAAM;UACJ1J,QADI;UAEJkH,SAFI;UAGJwC;QAHI,IAIF5F,UAAU,CAACe,YAAX,CAAwBC,IAAxB,EAA8B,KAAKrG,IAAnC,EAAyC,KAAK2H,cAA9C,CAJJ;QAKAtB,IAAI,CAAC9E,QAAL,GAAgB8E,IAAI,CAAC9E,QAAL,IAAiBA,QAAjB,IAA6B,IAA7C;QACA8E,IAAI,CAACoC,SAAL,GAAiBpC,IAAI,CAACoC,SAAL,IAAkBA,SAAlB,IAA+B,IAAhD;QACApC,IAAI,CAAC4E,aAAL,GAAqB5E,IAAI,CAAC4E,aAAL,IAAsBA,aAAtB,IAAuC,KAA5D;MACD;IACF;;IACD,KAAKzG,eAAL,EAAsB+G,GAAtB,CAA0BhH,GAA1B,EAA+B8B,IAA/B;EACD;;EAEDmF,OAAO,CAAEC,IAAF,EAAQ;IACb,IAAI,CAAC,KAAK1D,QAAN,IAAkB,CAAC0D,IAAI,CAACC,KAA5B,EAAmC;MACjC;IACD;;IAED,MAAM;MAAEC,EAAE,EAAEtF;IAAN,IAAeoF,IAArB,CALa,CAOb;;IACA,IAAIpF,IAAI,CAAC9E,QAAL,KAAkB,IAAlB,IAA0B8E,IAAI,CAACoC,SAAL,KAAmB,IAAjD,EAAuD;MACrD;IACD,CAVY,CAYb;;;IACA,IAAI,CAAC,KAAKV,QAAL,CAAcM,OAAf,IAA0B,CAAC,KAAKN,QAAL,CAAcM,OAAd,CAAsBuD,IAArD,EAA2D;MACzD;IACD,CAfY,CAiBb;IACA;;;IACA,MAAMV,SAAS,GAAG,CAAC7E,IAAI,CAAC9E,QAAN,GAAiB,IAAjB,GACd,CAAC,QAAQ2C,IAAR,CAAamC,IAAI,CAAC9E,QAAlB,CAAD,GAA+B8E,IAAI,CAAC9E,QAApC,GACAG,iBAAiB,CAAC2E,IAAI,CAAC9E,QAAN,EAAgB8E,IAAI,CAACrG,IAArB,EAA2B,KAAKA,IAAhC,EAAsC,IAAtC,CAFrB;IAIA,MAAMkI,IAAI,GAAGnH,GAAG,CAAE,GAAEsF,IAAI,CAAC3F,IAAK,IAAG+K,IAAI,CAACvD,IAAK,EAA3B,CAAhB;IACA,MAAM2D,KAAK,GAAG,KAAK9D,QAAL,CAAcM,OAAd,CAAsBC,GAAtB,CAA2B,GAAEjC,IAAI,CAAC3F,IAAK,IAAG+K,IAAI,CAACvD,IAAK,EAApD,CAAd;;IAEA,IAAI,CAAC2D,KAAD,IACA5M,QAAQ,CAACoH,IAAI,CAACmC,OAAN,EAAeqD,KAAK,CAACrD,OAArB,CADR,IAEAvJ,QAAQ,CAACoH,IAAI,CAACoC,SAAN,EAAiBoD,KAAK,CAACpD,SAAvB,CAFR,IAGAxJ,QAAQ,CAACiM,SAAD,EAAYW,KAAK,CAACtK,QAAlB,CAHZ,EAGyC;MACvC;IACD;;IAED,IAAIsK,KAAK,CAACtK,QAAN,IAAkBH,SAAS,CAAC8C,IAAV,CAAe2H,KAAK,CAACtK,QAArB,CAAlB,IAAoD2G,IAAI,CAACS,QAA7D,EAAuE;MACrEkD,KAAK,CAACtK,QAAN,GAAiBsK,KAAK,CAACtK,QAAN,CAAeqF,OAAf,CAAuBxF,SAAvB,EAAkC,6BAAlC,CAAjB;IACD;;IAEDiF,IAAI,CAACoC,SAAL,GAAiBpC,IAAI,CAACoC,SAAL,IAAkBoD,KAAK,CAACpD,SAAxB,IAAqC,IAAtD;IACApC,IAAI,CAAC9E,QAAL,GAAgB8E,IAAI,CAAC9E,QAAL,IACdG,iBAAiB,CAACmK,KAAK,CAACtK,QAAP,EAAiB,KAAKvB,IAAtB,EAA4BqG,IAAI,CAACrG,IAAjC,CADH,IAC6C,IAD7D;;IAGA,KAAKwE,eAAL,EAAsB+G,GAAtB,CAA0B9J,OAAO,CAAC,KAAKzB,IAAN,EAAYqG,IAAI,CAACrG,IAAjB,CAAjC,EAAyDqG,IAAzD;EACD;;EAEkB,CAAlB3B,kBAAkB,EAAGH,GAAH,EAAQ;IACzB,MAAM8B,IAAI,GAAG,KAAK7B,eAAL,EAAsB8D,GAAtB,CAA0B/D,GAA1B,CAAb;;IACA,KAAKC,eAAL,EAAsB8F,MAAtB,CAA6B/F,GAA7B;;IACA,KAAKzB,IAAL,CAAUY,QAAV,CAAmBa,GAAnB,IAA0Bc,UAAU,CAACe,YAAX,CACxBC,IADwB,EAExB,KAAKrG,IAFmB,EAGxB,KAAK2H,cAHmB,CAA1B;EAID;;EAEDmE,MAAM,GAAI;IACR,IAAI,KAAKhE,IAAT,EAAe;MACb,IAAI,KAAKC,QAAT,EAAmB;QACjB,KAAKA,QAAL,CAAcgE,QAAd,CAAuB,KAAKjE,IAA5B;MACD;;MACD,MAAMf,IAAI,GAAG1B,UAAU,CAACe,YAAX,CACX,KAAK0B,IAAL,CAAU1D,MADC,EAEX,KAAKpE,IAFM,EAGX,KAAK2H,cAHM,CAAb;MAIA,KAAK7E,IAAL,CAAUY,QAAV,GAAqB,EAArB;;MACA,IAAIlD,MAAM,CAACmC,IAAP,CAAYoE,IAAZ,EAAkBnE,MAAtB,EAA8B;QAC5B,KAAKE,IAAL,CAAUY,QAAV,CAAmB,EAAnB,IAAyBqD,IAAzB;MACD;;MACD,KAAK,MAAMV,IAAX,IAAmB,KAAKyB,IAAL,CAAUf,IAAV,CAAeiF,SAAf,CAAyBC,MAAzB,EAAnB,EAAsD;QACpD;QACA,IAAI5F,IAAI,KAAK,KAAKyB,IAAd,IAAsBzB,IAAI,CAAC6F,MAA3B,IAAqC7F,IAAI,CAAC2D,QAAL,KAAkB,EAA3D,EAA+D;UAC7D;QACD;;QACD,MAAMzF,GAAG,GAAG9C,OAAO,CAAC,KAAKzB,IAAN,EAAYqG,IAAI,CAACrG,IAAjB,CAAnB;QACA,KAAK8C,IAAL,CAAUY,QAAV,CAAmBa,GAAnB,IAA0Bc,UAAU,CAACe,YAAX,CACxBC,IADwB,EAExB,KAAKrG,IAFmB,EAGxB,KAAK2H,cAHmB,CAA1B;MAID;IACF,CAvBD,MAuBO,IAAI,KAAKnD,eAAL,EAAsBoH,IAAtB,GAA6B,CAAjC,EAAoC;MACzC,KAAK,MAAMrH,GAAX,IAAkB,KAAKC,eAAL,EAAsB7B,IAAtB,EAAlB,EAAgD;QAC9C,KAAK+B,kBAAL,EAAyBH,GAAzB;MACD;IACF,CA5BO,CA8BR;;;IACA,IAAI,CAAC,KAAK0B,eAAV,EAA2B;MACzB,KAAKA,eAAL,GAAuBjH,sBAAvB;IACD;;IACD,KAAK8D,IAAL,CAAUmD,eAAV,GAA4B,KAAKA,eAAjC,CAlCQ,CAoCR;;IACA,IAAI,KAAKH,cAAT,EAAyB;MACvB,OAAO,KAAKhD,IAAL,CAAUY,QAAV,CAAmB,EAAnB,CAAP;MACA,OAAO,KAAKZ,IAAL,CAAUoG,YAAjB;IACD,CAHD,MAGO,IAAI,KAAKpB,IAAL,IAAa,KAAK7B,eAAL,IAAwB,CAAzC,EAA4C;MACjD,KAAKhB,oBAAL,EAA2B,KAAK6C,IAAhC,EAAsC,KAAKhF,IAA3C;IACD,CA1CO,CA4CR;IACA;IACA;;;IACA,IAAI,KAAKmD,eAAL,IAAwB,CAA5B,EAA+B;MAC7B,MAAM;QAAEiD,YAAF;QAAgB,GAAGpG;MAAnB,IAA4B,KAAKA,IAAvC;MACA,OAAOA,IAAP;IACD,CAHD,MAGO,IAAI,KAAKmD,eAAL,GAAuB,CAA3B,EAA8B;MACnC,MAAM;QAAEvC,QAAF;QAAY,GAAGZ;MAAf,IAAwB,KAAKA,IAAnC;MACA,OAAOA,IAAP;IACD,CAHM,MAGA;MACL,OAAO,EAAE,GAAG,KAAKA;MAAV,CAAP;IACD;EACF;;EAEoB,CAApBmC,oBAAoB,EAAGoB,IAAH,EAAST,IAAT,EAA0B;IAAA,IAAX5F,IAAW,uEAAJ,EAAI;;IAC7C,IAAIqG,IAAI,KAAK,KAAKyB,IAAlB,EAAwB;MACtB;MACAlC,IAAI,CAAClF,IAAL,GAAY2F,IAAI,CAACS,WAAL,IAAoBT,IAAI,CAAC3F,IAArC;;MACA,IAAI2F,IAAI,CAACmC,OAAT,EAAkB;QAChB5C,IAAI,CAAC4C,OAAL,GAAenC,IAAI,CAACmC,OAApB;MACD;IACF,CAP4C,CAS7C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IACA,MAAMiD,IAAI,GAAG,CAAC,GAAGpF,IAAI,CAAC8F,OAAT,EAAkBC,MAAlB,CAAyBjG,CAAC,IAAIA,CAAC,CAACuF,KAAhC,EAAuCW,IAAvC,CAA4C,CAACnN,CAAD,EAAIC,CAAJ,KAAU;MACjE,MAAMmN,IAAI,GAAGpN,CAAC,CAACqN,IAAF,CAAOvC,QAAP,CAAgBS,KAAhB,CAAsB,cAAtB,CAAb;MACA,MAAM+B,IAAI,GAAGrN,CAAC,CAACoN,IAAF,CAAOvC,QAAP,CAAgBS,KAAhB,CAAsB,cAAtB,CAAb;MACA;;MACA,OAAO6B,IAAI,CAAC1J,MAAL,GAAc4J,IAAI,CAAC5J,MAAnB,GAA4B,CAA5B,GACH4J,IAAI,CAAC5J,MAAL,GAAc0J,IAAI,CAAC1J,MAAnB,GAA4B,CAAC,CAA7B,GACA9D,aAAa,CAACwN,IAAI,CAACA,IAAI,CAAC1J,MAAL,GAAc,CAAf,CAAL,EAAwB4J,IAAI,CAACA,IAAI,CAAC5J,MAAL,GAAc,CAAf,CAA5B,CAFjB;IAGD,CAPY,EAOV,CAPU,CAAb;IASA,MAAM6J,GAAG,GAAG/K,iBAAiB,CAAC2E,IAAI,CAAC9E,QAAN,EAAgB,KAAKvB,IAArB,EAA2B,KAAKA,IAAhC,EAAsC,IAAtC,CAA7B;IACA,MAAM0M,KAAK,GAAGpL,gBAAgB,CAACmL,GAAD,CAA9B,CA3B6C,CA6B7C;IACA;IACA;IACA;IACA;;IACA,MAAMvE,IAAI,GAAG,CAACuD,IAAD,GAAQiB,KAAR,GACT3L,GAAG,CAACJ,OAAJ,CAAY0F,IAAI,CAAC3F,IAAjB,EAAuB+K,IAAI,CAACvD,IAA5B,EAAkCuD,IAAI,CAACc,IAAL,CAAUhG,QAA5C,CADJ;;IAGA,IAAIF,IAAI,CAACC,MAAT,EAAiB;MACfV,IAAI,CAAC4C,OAAL,GAAgB,QAAO/G,OAAO,CAAC,KAAKzB,IAAN,EAAYqG,IAAI,CAACE,QAAjB,CAAP,CAAkCK,OAAlC,CAA0C,IAA1C,EAAgD,KAAhD,CAAuD,EAA9E;IACD,CAFD,MAEO,IAAIsB,IAAI,KAAKA,IAAI,CAACxF,IAAL,KAAc,MAAd,IAAwBwF,IAAI,CAACxF,IAAL,KAAc,QAA3C,CAAR,EAA8D;MACnEkD,IAAI,CAAC4C,OAAL,GAAeN,IAAI,CAACyE,QAApB;IACD,CAFM,MAEA,IAAIzE,IAAI,IAAIA,IAAI,CAACxF,IAAL,KAAc,KAAtB,IAA+BgK,KAAK,CAAChK,IAAN,KAAe,KAAlD,EAAyD;MAC9DkD,IAAI,CAAC4C,OAAL,GAAenC,IAAI,CAAC9E,QAApB;MACA;AACN;;MACM,IAAI2G,IAAI,CAACK,GAAT,EAAc;QACZ3C,IAAI,CAAC2G,IAAL,GAAYrE,IAAI,CAACK,GAAjB;MACD;IACF,CAPM,MAOA,IAAI,CAAClC,IAAI,CAAC6F,MAAN,IACP7F,IAAI,CAACM,OADE,IAEPN,IAAI,CAACS,WAFE,IAGPT,IAAI,CAACS,WAAL,KAAqBT,IAAI,CAAC3F,IAHvB,EAG6B;MAClCkF,IAAI,CAAC4C,OAAL,GAAgB,OAAMnC,IAAI,CAACS,WAAY,IAAGT,IAAI,CAACmC,OAAQ,EAAvD;IACD,CALM,MAKA,IAAInC,IAAI,CAACM,OAAL,IAAgBN,IAAI,CAACmC,OAAzB,EAAkC;MACvC5C,IAAI,CAAC4C,OAAL,GAAenC,IAAI,CAACmC,OAApB;IACD;;IAED,IAAInC,IAAI,CAACuG,WAAT,EAAsB;MACpBhH,IAAI,CAACmF,OAAL,GAAe,IAAf;IACD,CA3D4C,CA6D7C;IACA;;;IACA,IAAI1E,IAAI,CAAC9E,QAAL,IACA,CAAC8E,IAAI,CAACC,MADN,IAEAoG,KAAK,CAAChK,IAAN,KAAe,KAFf,IAGAgK,KAAK,CAAChK,IAAN,KAAe,MAHf,IAIAgK,KAAK,CAAChK,IAAN,KAAe,WAJf,IAKAwF,IAAI,CAACxF,IAAL,KAAc,WALd,IAMAwF,IAAI,CAACxF,IAAL,KAAc,KANd,IAOAwF,IAAI,CAACxF,IAAL,KAAc,MAPd,IAQAwF,IAAI,CAACxF,IAAL,KAAc,QARlB,EAQ4B;MAC1BkD,IAAI,CAACrE,QAAL,GAAgBI,gBAAgB,CAAC0E,IAAI,CAAC9E,QAAN,EAAgB,KAAKoG,cAArB,CAAhC;IACD;;IAED,IAAItB,IAAI,CAACoC,SAAT,EAAoB;MAClB7C,IAAI,CAAC6C,SAAL,GAAiBpC,IAAI,CAACoC,SAAtB;IACD;;IAED,IAAIpC,IAAI,CAACc,UAAT,EAAqB;MACnBvB,IAAI,CAACuB,UAAL,GAAkB,IAAlB;IACD,CAFD,MAEO,IAAI,CAACd,IAAI,CAACC,MAAV,EAAkB;MACvB,IAAID,IAAI,CAACe,IAAT,EAAe;QACbxB,IAAI,CAACwB,IAAL,GAAY,IAAZ;MACD;;MAED,IAAIf,IAAI,CAACkB,WAAL,IAAoB,CAAClB,IAAI,CAACgB,GAA1B,IAAiC,CAAChB,IAAI,CAACiB,QAA3C,EAAqD;QACnD1B,IAAI,CAAC2B,WAAL,GAAmB,IAAnB;MACD;;MAED,IAAIlB,IAAI,CAACgB,GAAT,EAAc;QACZzB,IAAI,CAACyB,GAAL,GAAW,IAAX;MACD;;MAED,IAAIhB,IAAI,CAACiB,QAAT,EAAmB;QACjB1B,IAAI,CAAC0B,QAAL,GAAgB,IAAhB;MACD;IACF;;IAED,MAAMuF,QAAQ,GAAGxG,IAAI,CAACjC,MAAtB;;IACA,IAAIyI,QAAQ,CAACC,QAAT,CAAkBlB,IAAlB,GAAyB,CAA7B,EAAgC;MAC9B,IAAIvF,IAAI,KAAK,KAAKyB,IAAlB,EAAwB;QACtB,MAAMO,OAAO,GAAG,CAAC,GAAGwE,QAAQ,CAACC,QAAT,CAAkBzE,OAAlB,EAAJ,CAAhB;QACAzC,IAAI,CAACqD,QAAL,GAAgBZ,OAAO,CAAC0E,MAAR,CAAe,CAACxB,GAAD,YAAiB;UAAA,IAAX,CAACrB,CAAD,EAAI8C,CAAJ,CAAW;UAC9C;UACA;UACA;UACA,MAAM;YAAE9E,IAAF;YAAQd;UAAR,IAAiB4F,CAAvB;;UACA,IAAI5F,IAAJ,EAAU;YACR,OAAOmE,GAAP;UACD;;UACD,IAAIrD,IAAI,CAAC+E,UAAL,CAAgB,OAAhB,CAAJ,EAA8B;YAC5B;YACA;YACA;YACA,MAAMC,CAAC,GAAGvM,OAAO,CAAC0F,IAAI,CAACE,QAAN,EAAgB2B,IAAI,CAACkB,KAAL,CAAW,QAAQxG,MAAnB,CAAhB,CAAjB;YACA2I,GAAG,CAACrB,CAAD,CAAH,GAAU,QAAOzI,OAAO,CAAC4E,IAAI,CAACE,QAAN,EAAgB2G,CAAhB,CAAP,CAA0BtG,OAA1B,CAAkC,IAAlC,EAAwC,KAAxC,CAA+C,EAAhE;UACD,CAND,MAMO;YACL2E,GAAG,CAACrB,CAAD,CAAH,GAAShC,IAAT;UACD;;UACD,OAAOqD,GAAP;QACD,CAlBe,EAkBb,EAlBa,CAAhB;MAmBD,CArBD,MAqBO;QACL3F,IAAI,CAACqD,QAAL,GAAgB,IAAhB;MACD;IACF,CA7H4C,CA+H7C;;;IACA,MAAM;MAAEnF;IAAF,IAAeuC,IAAI,CAACjC,MAA1B;;IACA,IAAI,CAACN,QAAQ,CAAC8H,IAAd,EAAoB;MAClB,OAAOhG,IAAI,CAACsD,YAAZ;IACD,CAFD,MAEO;MACL,MAAMiE,OAAO,GAAG,CAAC,GAAGnN,IAAJ,EAAUqG,IAAI,CAACE,QAAf,CAAhB;MACA,MAAM2C,YAAY,GAAG,EAArB,CAFK,CAGL;MACA;;MACA,IAAIkE,KAAK,GAAG,KAAZ;;MACA,KAAK,MAAM,CAAC1M,IAAD,EAAO2M,GAAP,CAAX,IAA0BvJ,QAAQ,CAACuE,OAAT,EAA1B,EAA8C;QAC5C,IAAIrI,IAAI,CAACsN,QAAL,CAAcD,GAAG,CAAC9G,QAAlB,CAAJ,EAAiC;UAC/B;QACD;;QACD2C,YAAY,CAACxI,IAAD,CAAZ,GAAqB,KAAKuE,oBAAL,EAA2BoI,GAA3B,EAAgC,EAAhC,EAAoCF,OAApC,CAArB;QACAC,KAAK,GAAG,IAAR;MACD;;MACD,IAAIA,KAAJ,EAAW;QACTxH,IAAI,CAACsD,YAAL,GAAoBA,YAApB;MACD;IACF;;IACD,OAAOtD,IAAP;EACD;;EAED2H,MAAM,GAAI;IACR,IAAI,CAAC,KAAKzK,IAAV,EAAgB;MACd,MAAM,IAAI0H,KAAJ,CAAU,2CAAV,CAAN;IACD;;IAED,OAAO,KAAKsB,MAAL,EAAP;EACD;;EAED0B,QAAQ,GAAgB;IAAA,IAAdjI,OAAc,uEAAJ,EAAI;IACtB,MAAMzC,IAAI,GAAG,KAAKyK,MAAL,EAAb;IACA,MAAM;MAAEE,MAAM,GAAG;IAAX,IAAoBlI,OAA1B;IACA,MAAMmI,aAAa,GAAG,KAAKjG,MAAL,IAAe,CAArC;IACA,MAAMA,MAAM,GAAGgG,MAAM,KAAK,IAAX,GAAkBC,aAAlB,GACXD,MAAM,IAAI,CADd;IAEA,MAAME,GAAG,GAAGF,MAAM,GAAG,KAAK/F,OAAL,IAAgB,IAAnB,GAA0B,EAA5C;IACA,OAAOxG,SAAS,CAAC4B,IAAD,EAAO3B,UAAP,EAAmBsG,MAAnB,CAAT,CAAoCb,OAApC,CAA4C,KAA5C,EAAmD+G,GAAnD,CAAP;EACD;;EAEDC,IAAI,GAAgB;IAAA,IAAdrI,OAAc,uEAAJ,EAAI;;IAClB,IAAI,CAAC,KAAKzC,IAAV,EAAgB;MACd,MAAM,IAAI0H,KAAJ,CAAU,+BAAV,CAAN;IACD;;IACD,MAAMtE,IAAI,GAAG,KAAKsH,QAAL,CAAcjI,OAAd,CAAb;IACA,OAAOnF,OAAO,CAACC,GAAR,CAAY,CACjBX,SAAS,CAAC,KAAKmG,QAAN,EAAgBK,IAAhB,CAAT,CAA+BlC,KAA/B,CAAqCxC,EAAE,IAAI;MACzC,IAAI,KAAKsE,cAAT,EAAyB;QACvB;QACA;QACA;QACA;QACA;QACA,OAAOvG,MAAM,CAAC,KAAKsG,QAAN,CAAb;MACD;;MACD,MAAMrE,EAAN;IACD,CAVD,CADiB,EAYjB,KAAKuG,QAAL,IAAiB,KAAKA,QAAL,CAAcM,OAAd,CAAsBuD,IAAvC,IACElM,SAAS,CAAC,KAAKM,IAAL,GAAY,YAAb,EAA2B,KAAK+H,QAAL,CAAcyF,QAAd,EAA3B,CAbM,CAAZ,CAAP;EAeD;;AAz5Bc;;AA45BjBK,MAAM,CAACC,OAAP,GAAiBzI,UAAjB"},"metadata":{},"sourceType":"script"}