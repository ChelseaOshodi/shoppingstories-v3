{"ast":null,"code":"// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\nconst fs = require('@npmcli/fs');\n\nconst nopt = require('nopt');\n\nconst {\n  definitions,\n  shorthands\n} = require('../utils/config/index.js');\n\nconst {\n  aliases,\n  cmdList,\n  plumbing\n} = require('../utils/cmd-list.js');\n\nconst aliasNames = Object.keys(aliases);\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c));\nconst configNames = Object.keys(definitions);\nconst shorthandNames = Object.keys(shorthands);\nconst allConfs = configNames.concat(shorthandNames);\n\nconst {\n  isWindowsShell\n} = require('../utils/is-windows.js');\n\nconst fileExists = async file => {\n  try {\n    const stat = await fs.stat(file);\n    return stat.isFile();\n  } catch {\n    return false;\n  }\n};\n\nconst BaseCommand = require('../base-command.js');\n\nclass Completion extends BaseCommand {\n  static description = 'Tab Completion for npm';\n  static name = 'completion';\n  static ignoreImplicitWorkspace = false; // completion for the completion command\n\n  async completion(opts) {\n    if (opts.w > 2) {\n      return;\n    }\n\n    const {\n      resolve\n    } = require('path');\n\n    const [bashExists, zshExists] = await Promise.all([fileExists(resolve(process.env.HOME, '.bashrc')), fileExists(resolve(process.env.HOME, '.zshrc'))]);\n    const out = [];\n\n    if (zshExists) {\n      out.push(['>>', '~/.zshrc']);\n    }\n\n    if (bashExists) {\n      out.push(['>>', '~/.bashrc']);\n    }\n\n    return out;\n  }\n\n  async exec(args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows';\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP'\n      });\n    }\n\n    const {\n      COMP_CWORD,\n      COMP_LINE,\n      COMP_POINT\n    } = process.env; // if the COMP_* isn't in the env, then just dump the script.\n\n    if (COMP_CWORD === undefined || COMP_LINE === undefined || COMP_POINT === undefined) {\n      return dumpScript();\n    } // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n\n\n    const w = +COMP_CWORD;\n    const words = args.map(unescape);\n    const word = words[w];\n    const line = COMP_LINE;\n    const point = +COMP_POINT;\n    const partialLine = line.slice(0, point);\n    const partialWords = words.slice(0, w); // figure out where in that last word the point is.\n\n    const partialWordRaw = args[w];\n    let i = partialWordRaw.length;\n\n    while (partialWordRaw.slice(0, i) !== partialLine.slice(-1 * i) && i > 0) {\n      i--;\n    }\n\n    const partialWord = unescape(partialWordRaw.slice(0, i));\n    partialWords.push(partialWord);\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args\n    };\n\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-') {\n        return this.wrap(opts, configCompl(opts));\n      }\n\n      if (words[w - 1] && words[w - 1].charAt(0) === '-' && !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts));\n      }\n    } // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n\n\n    const types = Object.entries(definitions).reduce((types, _ref) => {\n      let [key, def] = _ref;\n      types[key] = def.type;\n      return types;\n    }, {});\n    const parsed = opts.conf = nopt(types, shorthands, partialWords.slice(0, -1), 0); // check if there's a command already.\n\n    const cmd = parsed.argv.remain[1];\n\n    if (!cmd) {\n      return this.wrap(opts, cmdCompl(opts, this.npm));\n    }\n\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k])); // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n\n    const impl = await this.npm.cmd(cmd);\n\n    if (impl.completion) {\n      const comps = await impl.completion(opts);\n      return this.wrap(opts, comps);\n    }\n  } // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n\n\n  wrap(opts, compls) {\n    // TODO this was dead code, leaving it in case we find some command we\n    // forgot that requires this. if so *that command should fix its\n    // completions*\n    // compls = compls.map(w => !/\\s+/.test(w) ? w : '\\'' + w + '\\'')\n    if (opts.partialWord) {\n      compls = compls.filter(c => c.startsWith(opts.partialWord));\n    }\n\n    if (compls.length > 0) {\n      this.npm.output(compls.join('\\n'));\n    }\n  }\n\n}\n\nconst dumpScript = async () => {\n  const {\n    resolve\n  } = require('path');\n\n  const p = resolve(__dirname, '..', 'utils', 'completion.sh');\n  const d = (await fs.readFile(p, 'utf8')).replace(/^#!.*?\\n/, '');\n  await new Promise((res, rej) => {\n    let done = false;\n    process.stdout.on('error', er => {\n      if (done) {\n        return;\n      }\n\n      done = true; // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      // TODO Ignoring coverage, see 'non EPIPE errors cause failures' test.\n\n      /* istanbul ignore next */\n\n      if (er.errno === 'EPIPE') {\n        res();\n      } else {\n        rej(er);\n      }\n    });\n    process.stdout.write(d, () => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      res();\n    });\n  });\n};\n\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '') : w.replace(/\\\\ /g, ' '); // the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\n\n\nconst configCompl = opts => {\n  const word = opts.word;\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/);\n  const dashes = split[1];\n  const no = split[2];\n  const flags = configNames.filter(isFlag);\n  return allConfs.map(c => dashes + c).concat(flags.map(f => dashes + (no || 'no-') + f));\n}; // expand with the valid values of various config values.\n// not yet implemented.\n\n\nconst configValueCompl = opts => []; // check if the thing is a flag or not.\n\n\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/);\n  const no = split[2];\n  const conf = split[3];\n  const {\n    type\n  } = definitions[conf];\n  return no || type === Boolean || Array.isArray(type) && type.includes(Boolean) || shorthands[conf];\n}; // complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\n\n\nconst cmdCompl = (opts, npm) => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord));\n\n  if (!matches.length) {\n    return matches;\n  }\n\n  const derefs = new Set([...matches.map(c => npm.deref(c))]);\n\n  if (derefs.size === 1) {\n    return [...derefs];\n  }\n\n  return fullList;\n};\n\nmodule.exports = Completion;","map":{"version":3,"names":["fs","require","nopt","definitions","shorthands","aliases","cmdList","plumbing","aliasNames","Object","keys","fullList","concat","filter","c","includes","configNames","shorthandNames","allConfs","isWindowsShell","fileExists","file","stat","isFile","BaseCommand","Completion","description","name","ignoreImplicitWorkspace","completion","opts","w","resolve","bashExists","zshExists","Promise","all","process","env","HOME","out","push","exec","args","msg","assign","Error","code","COMP_CWORD","COMP_LINE","COMP_POINT","undefined","dumpScript","words","map","unescape","word","line","point","partialLine","slice","partialWords","partialWordRaw","i","length","partialWord","lineLength","raw","indexOf","charAt","wrap","configCompl","isFlag","configValueCompl","types","entries","reduce","key","def","type","parsed","conf","cmd","argv","remain","cmdCompl","npm","forEach","k","config","set","impl","comps","compls","startsWith","output","join","p","__dirname","d","readFile","replace","res","rej","done","stdout","on","er","errno","write","split","match","dashes","no","flags","f","Boolean","Array","isArray","matches","derefs","Set","deref","size","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/completion.js"],"sourcesContent":["// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\n\nconst fs = require('@npmcli/fs')\nconst nopt = require('nopt')\n\nconst { definitions, shorthands } = require('../utils/config/index.js')\nconst { aliases, cmdList, plumbing } = require('../utils/cmd-list.js')\nconst aliasNames = Object.keys(aliases)\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c))\nconst configNames = Object.keys(definitions)\nconst shorthandNames = Object.keys(shorthands)\nconst allConfs = configNames.concat(shorthandNames)\nconst { isWindowsShell } = require('../utils/is-windows.js')\nconst fileExists = async (file) => {\n  try {\n    const stat = await fs.stat(file)\n    return stat.isFile()\n  } catch {\n    return false\n  }\n}\n\nconst BaseCommand = require('../base-command.js')\n\nclass Completion extends BaseCommand {\n  static description = 'Tab Completion for npm'\n  static name = 'completion'\n  static ignoreImplicitWorkspace = false\n\n  // completion for the completion command\n  async completion (opts) {\n    if (opts.w > 2) {\n      return\n    }\n\n    const { resolve } = require('path')\n    const [bashExists, zshExists] = await Promise.all([\n      fileExists(resolve(process.env.HOME, '.bashrc')),\n      fileExists(resolve(process.env.HOME, '.zshrc')),\n    ])\n    const out = []\n    if (zshExists) {\n      out.push(['>>', '~/.zshrc'])\n    }\n\n    if (bashExists) {\n      out.push(['>>', '~/.bashrc'])\n    }\n\n    return out\n  }\n\n  async exec (args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows'\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP',\n      })\n    }\n\n    const { COMP_CWORD, COMP_LINE, COMP_POINT } = process.env\n\n    // if the COMP_* isn't in the env, then just dump the script.\n    if (COMP_CWORD === undefined ||\n      COMP_LINE === undefined ||\n      COMP_POINT === undefined) {\n      return dumpScript()\n    }\n\n    // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n    const w = +COMP_CWORD\n    const words = args.map(unescape)\n    const word = words[w]\n    const line = COMP_LINE\n    const point = +COMP_POINT\n    const partialLine = line.slice(0, point)\n    const partialWords = words.slice(0, w)\n\n    // figure out where in that last word the point is.\n    const partialWordRaw = args[w]\n    let i = partialWordRaw.length\n    while (partialWordRaw.slice(0, i) !== partialLine.slice(-1 * i) && i > 0) {\n      i--\n    }\n\n    const partialWord = unescape(partialWordRaw.slice(0, i))\n    partialWords.push(partialWord)\n\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args,\n    }\n\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-') {\n        return this.wrap(opts, configCompl(opts))\n      }\n\n      if (words[w - 1] &&\n        words[w - 1].charAt(0) === '-' &&\n        !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts))\n      }\n    }\n\n    // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n    const types = Object.entries(definitions).reduce((types, [key, def]) => {\n      types[key] = def.type\n      return types\n    }, {})\n    const parsed = opts.conf =\n      nopt(types, shorthands, partialWords.slice(0, -1), 0)\n    // check if there's a command already.\n    const cmd = parsed.argv.remain[1]\n    if (!cmd) {\n      return this.wrap(opts, cmdCompl(opts, this.npm))\n    }\n\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k]))\n\n    // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n    const impl = await this.npm.cmd(cmd)\n    if (impl.completion) {\n      const comps = await impl.completion(opts)\n      return this.wrap(opts, comps)\n    }\n  }\n\n  // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n  wrap (opts, compls) {\n    // TODO this was dead code, leaving it in case we find some command we\n    // forgot that requires this. if so *that command should fix its\n    // completions*\n    // compls = compls.map(w => !/\\s+/.test(w) ? w : '\\'' + w + '\\'')\n\n    if (opts.partialWord) {\n      compls = compls.filter(c => c.startsWith(opts.partialWord))\n    }\n\n    if (compls.length > 0) {\n      this.npm.output(compls.join('\\n'))\n    }\n  }\n}\n\nconst dumpScript = async () => {\n  const { resolve } = require('path')\n  const p = resolve(__dirname, '..', 'utils', 'completion.sh')\n\n  const d = (await fs.readFile(p, 'utf8')).replace(/^#!.*?\\n/, '')\n  await new Promise((res, rej) => {\n    let done = false\n    process.stdout.on('error', er => {\n      if (done) {\n        return\n      }\n\n      done = true\n\n      // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      // TODO Ignoring coverage, see 'non EPIPE errors cause failures' test.\n      /* istanbul ignore next */\n      if (er.errno === 'EPIPE') {\n        res()\n      } else {\n        rej(er)\n      }\n    })\n\n    process.stdout.write(d, () => {\n      if (done) {\n        return\n      }\n\n      done = true\n      res()\n    })\n  })\n}\n\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '')\n  : w.replace(/\\\\ /g, ' ')\n\n// the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\nconst configCompl = opts => {\n  const word = opts.word\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/)\n  const dashes = split[1]\n  const no = split[2]\n  const flags = configNames.filter(isFlag)\n  return allConfs.map(c => dashes + c)\n    .concat(flags.map(f => dashes + (no || 'no-') + f))\n}\n\n// expand with the valid values of various config values.\n// not yet implemented.\nconst configValueCompl = opts => []\n\n// check if the thing is a flag or not.\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/)\n  const no = split[2]\n  const conf = split[3]\n  const { type } = definitions[conf]\n  return no ||\n    type === Boolean ||\n    (Array.isArray(type) && type.includes(Boolean)) ||\n    shorthands[conf]\n}\n\n// complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\nconst cmdCompl = (opts, npm) => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord))\n  if (!matches.length) {\n    return matches\n  }\n\n  const derefs = new Set([...matches.map(c => npm.deref(c))])\n  if (derefs.size === 1) {\n    return [...derefs]\n  }\n\n  return fullList\n}\n\nmodule.exports = Completion\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}