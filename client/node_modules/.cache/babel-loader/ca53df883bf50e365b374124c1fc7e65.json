{"ast":null,"code":"const {\n  NotCachedError\n} = require('./errors.js');\n\nconst CacheEntry = require('./entry.js');\n\nconst remote = require('../remote.js'); // do whatever is necessary to get a Response and return it\n\n\nconst cacheFetch = async (request, options) => {\n  // try to find a cached entry that satisfies this request\n  const entry = await CacheEntry.find(request, options);\n\n  if (!entry) {\n    // no cached result, if the cache mode is 'only-if-cached' that's a failure\n    if (options.cache === 'only-if-cached') {\n      throw new NotCachedError(request.url);\n    } // otherwise, we make a request, store it and return it\n\n\n    const response = await remote(request, options);\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options\n    });\n    return newEntry.store('miss');\n  } // we have a cached response that satisfies this request, however if the cache\n  // mode is 'no-cache' then we send the revalidation request no matter what\n\n\n  if (options.cache === 'no-cache') {\n    return entry.revalidate(request, options);\n  } // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n  // 'only-if-cached' we can respond with the cached entry. set the status\n  // based on the result of needsRevalidation and respond\n\n\n  const _needsRevalidation = entry.policy.needsRevalidation(request);\n\n  if (options.cache === 'force-cache' || options.cache === 'only-if-cached' || !_needsRevalidation) {\n    return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit');\n  } // if we got here, the cache entry is stale so revalidate it\n\n\n  return entry.revalidate(request, options);\n};\n\ncacheFetch.invalidate = async (request, options) => {\n  if (!options.cachePath) {\n    return;\n  }\n\n  return CacheEntry.invalidate(request, options);\n};\n\nmodule.exports = cacheFetch;","map":{"version":3,"names":["NotCachedError","require","CacheEntry","remote","cacheFetch","request","options","entry","find","cache","url","response","newEntry","store","revalidate","_needsRevalidation","policy","needsRevalidation","respond","method","invalidate","cachePath","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/make-fetch-happen/lib/cache/index.js"],"sourcesContent":["const { NotCachedError } = require('./errors.js')\nconst CacheEntry = require('./entry.js')\nconst remote = require('../remote.js')\n\n// do whatever is necessary to get a Response and return it\nconst cacheFetch = async (request, options) => {\n  // try to find a cached entry that satisfies this request\n  const entry = await CacheEntry.find(request, options)\n  if (!entry) {\n    // no cached result, if the cache mode is 'only-if-cached' that's a failure\n    if (options.cache === 'only-if-cached') {\n      throw new NotCachedError(request.url)\n    }\n\n    // otherwise, we make a request, store it and return it\n    const response = await remote(request, options)\n    const newEntry = new CacheEntry({ request, response, options })\n    return newEntry.store('miss')\n  }\n\n  // we have a cached response that satisfies this request, however if the cache\n  // mode is 'no-cache' then we send the revalidation request no matter what\n  if (options.cache === 'no-cache') {\n    return entry.revalidate(request, options)\n  }\n\n  // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n  // 'only-if-cached' we can respond with the cached entry. set the status\n  // based on the result of needsRevalidation and respond\n  const _needsRevalidation = entry.policy.needsRevalidation(request)\n  if (options.cache === 'force-cache' ||\n      options.cache === 'only-if-cached' ||\n      !_needsRevalidation) {\n    return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit')\n  }\n\n  // if we got here, the cache entry is stale so revalidate it\n  return entry.revalidate(request, options)\n}\n\ncacheFetch.invalidate = async (request, options) => {\n  if (!options.cachePath) {\n    return\n  }\n\n  return CacheEntry.invalidate(request, options)\n}\n\nmodule.exports = cacheFetch\n"],"mappings":"AAAA,MAAM;EAAEA;AAAF,IAAqBC,OAAO,CAAC,aAAD,CAAlC;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,cAAD,CAAtB,C,CAEA;;;AACA,MAAMG,UAAU,GAAG,OAAOC,OAAP,EAAgBC,OAAhB,KAA4B;EAC7C;EACA,MAAMC,KAAK,GAAG,MAAML,UAAU,CAACM,IAAX,CAAgBH,OAAhB,EAAyBC,OAAzB,CAApB;;EACA,IAAI,CAACC,KAAL,EAAY;IACV;IACA,IAAID,OAAO,CAACG,KAAR,KAAkB,gBAAtB,EAAwC;MACtC,MAAM,IAAIT,cAAJ,CAAmBK,OAAO,CAACK,GAA3B,CAAN;IACD,CAJS,CAMV;;;IACA,MAAMC,QAAQ,GAAG,MAAMR,MAAM,CAACE,OAAD,EAAUC,OAAV,CAA7B;IACA,MAAMM,QAAQ,GAAG,IAAIV,UAAJ,CAAe;MAAEG,OAAF;MAAWM,QAAX;MAAqBL;IAArB,CAAf,CAAjB;IACA,OAAOM,QAAQ,CAACC,KAAT,CAAe,MAAf,CAAP;EACD,CAb4C,CAe7C;EACA;;;EACA,IAAIP,OAAO,CAACG,KAAR,KAAkB,UAAtB,EAAkC;IAChC,OAAOF,KAAK,CAACO,UAAN,CAAiBT,OAAjB,EAA0BC,OAA1B,CAAP;EACD,CAnB4C,CAqB7C;EACA;EACA;;;EACA,MAAMS,kBAAkB,GAAGR,KAAK,CAACS,MAAN,CAAaC,iBAAb,CAA+BZ,OAA/B,CAA3B;;EACA,IAAIC,OAAO,CAACG,KAAR,KAAkB,aAAlB,IACAH,OAAO,CAACG,KAAR,KAAkB,gBADlB,IAEA,CAACM,kBAFL,EAEyB;IACvB,OAAOR,KAAK,CAACW,OAAN,CAAcb,OAAO,CAACc,MAAtB,EAA8Bb,OAA9B,EAAuCS,kBAAkB,GAAG,OAAH,GAAa,KAAtE,CAAP;EACD,CA7B4C,CA+B7C;;;EACA,OAAOR,KAAK,CAACO,UAAN,CAAiBT,OAAjB,EAA0BC,OAA1B,CAAP;AACD,CAjCD;;AAmCAF,UAAU,CAACgB,UAAX,GAAwB,OAAOf,OAAP,EAAgBC,OAAhB,KAA4B;EAClD,IAAI,CAACA,OAAO,CAACe,SAAb,EAAwB;IACtB;EACD;;EAED,OAAOnB,UAAU,CAACkB,UAAX,CAAsBf,OAAtB,EAA+BC,OAA/B,CAAP;AACD,CAND;;AAQAgB,MAAM,CAACC,OAAP,GAAiBnB,UAAjB"},"metadata":{},"sourceType":"script"}