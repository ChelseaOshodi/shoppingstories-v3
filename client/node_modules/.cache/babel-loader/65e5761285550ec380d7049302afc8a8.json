{"ast":null,"code":"'use strict';\n\nconst MinipassPipeline = require('minipass-pipeline');\n\nclass CachingMinipassPipeline extends MinipassPipeline {\n  #events = [];\n  #data = new Map();\n\n  constructor(opts) {\n    // CRITICAL: do NOT pass the streams to the call to super(), this will start\n    // the flow of data and potentially cause the events we need to catch to emit\n    // before we've finished our own setup. instead we call super() with no args,\n    // finish our setup, and then push the streams into ourselves to start the\n    // data flow\n    super();\n    this.#events = opts.events;\n    /* istanbul ignore next - coverage disabled because this is pointless to test here */\n\n    for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      streams[_key - 1] = arguments[_key];\n    }\n\n    if (streams.length) {\n      this.push(...streams);\n    }\n  }\n\n  on(event, handler) {\n    if (this.#events.includes(event) && this.#data.has(event)) {\n      return handler(...this.#data.get(event));\n    }\n\n    return super.on(event, handler);\n  }\n\n  emit(event) {\n    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n\n    if (this.#events.includes(event)) {\n      this.#data.set(event, data);\n    }\n\n    return super.emit(event, ...data);\n  }\n\n}\n\nmodule.exports = CachingMinipassPipeline;","map":{"version":3,"names":["MinipassPipeline","require","CachingMinipassPipeline","events","data","Map","constructor","opts","streams","length","push","on","event","handler","includes","has","get","emit","set","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/make-fetch-happen/lib/pipeline.js"],"sourcesContent":["'use strict'\n\nconst MinipassPipeline = require('minipass-pipeline')\n\nclass CachingMinipassPipeline extends MinipassPipeline {\n  #events = []\n  #data = new Map()\n\n  constructor (opts, ...streams) {\n    // CRITICAL: do NOT pass the streams to the call to super(), this will start\n    // the flow of data and potentially cause the events we need to catch to emit\n    // before we've finished our own setup. instead we call super() with no args,\n    // finish our setup, and then push the streams into ourselves to start the\n    // data flow\n    super()\n    this.#events = opts.events\n\n    /* istanbul ignore next - coverage disabled because this is pointless to test here */\n    if (streams.length) {\n      this.push(...streams)\n    }\n  }\n\n  on (event, handler) {\n    if (this.#events.includes(event) && this.#data.has(event)) {\n      return handler(...this.#data.get(event))\n    }\n\n    return super.on(event, handler)\n  }\n\n  emit (event, ...data) {\n    if (this.#events.includes(event)) {\n      this.#data.set(event, data)\n    }\n\n    return super.emit(event, ...data)\n  }\n}\n\nmodule.exports = CachingMinipassPipeline\n"],"mappings":"AAAA;;AAEA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,mBAAD,CAAhC;;AAEA,MAAMC,uBAAN,SAAsCF,gBAAtC,CAAuD;EACrD,CAACG,MAAD,GAAU,EAAV;EACA,CAACC,IAAD,GAAQ,IAAIC,GAAJ,EAAR;;EAEAC,WAAW,CAAEC,IAAF,EAAoB;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,CAACJ,MAAN,GAAeI,IAAI,CAACJ,MAApB;IAEA;;IAT6B,kCAATK,OAAS;MAATA,OAAS;IAAA;;IAU7B,IAAIA,OAAO,CAACC,MAAZ,EAAoB;MAClB,KAAKC,IAAL,CAAU,GAAGF,OAAb;IACD;EACF;;EAEDG,EAAE,CAAEC,KAAF,EAASC,OAAT,EAAkB;IAClB,IAAI,KAAK,CAACV,MAAN,CAAaW,QAAb,CAAsBF,KAAtB,KAAgC,KAAK,CAACR,IAAN,CAAWW,GAAX,CAAeH,KAAf,CAApC,EAA2D;MACzD,OAAOC,OAAO,CAAC,GAAG,KAAK,CAACT,IAAN,CAAWY,GAAX,CAAeJ,KAAf,CAAJ,CAAd;IACD;;IAED,OAAO,MAAMD,EAAN,CAASC,KAAT,EAAgBC,OAAhB,CAAP;EACD;;EAEDI,IAAI,CAAEL,KAAF,EAAkB;IAAA,mCAANR,IAAM;MAANA,IAAM;IAAA;;IACpB,IAAI,KAAK,CAACD,MAAN,CAAaW,QAAb,CAAsBF,KAAtB,CAAJ,EAAkC;MAChC,KAAK,CAACR,IAAN,CAAWc,GAAX,CAAeN,KAAf,EAAsBR,IAAtB;IACD;;IAED,OAAO,MAAMa,IAAN,CAAWL,KAAX,EAAkB,GAAGR,IAArB,CAAP;EACD;;AAjCoD;;AAoCvDe,MAAM,CAACC,OAAP,GAAiBlB,uBAAjB"},"metadata":{},"sourceType":"script"}