{"ast":null,"code":"// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node]);\n\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to);\n      }\n    }\n\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from);\n      }\n    }\n  }\n\n  const entrySets = new Map();\n\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // peerConflicted, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue;\n      } // this is the entry point into the peer set\n\n\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer]);\n\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to);\n            }\n          }\n        } // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n\n\n        if (sub.has(node)) {\n          entrySets.set(edge, sub);\n        }\n      }\n    }\n  }\n\n  return entrySets;\n};\n\nmodule.exports = peerEntrySets;","map":{"version":3,"names":["peerEntrySets","node","unionSet","Set","edge","edgesOut","values","valid","peer","to","add","edgesIn","from","entrySets","Map","isTop","sub","has","set","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/peer-entry-sets.js"],"sourcesContent":["// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\n\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node])\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to)\n      }\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from)\n      }\n    }\n  }\n  const entrySets = new Map()\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // peerConflicted, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue\n      }\n      // this is the entry point into the peer set\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer])\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to)\n            }\n          }\n        }\n        // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n        if (sub.has(node)) {\n          entrySets.set(edge, sub)\n        }\n      }\n    }\n  }\n\n  return entrySets\n}\n\nmodule.exports = peerEntrySets\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,aAAa,GAAGC,IAAI,IAAI;EAC5B;EACA;EACA;EACA,MAAMC,QAAQ,GAAG,IAAIC,GAAJ,CAAQ,CAACF,IAAD,CAAR,CAAjB;;EACA,KAAK,MAAMA,IAAX,IAAmBC,QAAnB,EAA6B;IAC3B,KAAK,MAAME,IAAX,IAAmBH,IAAI,CAACI,QAAL,CAAcC,MAAd,EAAnB,EAA2C;MACzC,IAAIF,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAnB,IAA2BJ,IAAI,CAACK,EAApC,EAAwC;QACtCP,QAAQ,CAACQ,GAAT,CAAaN,IAAI,CAACK,EAAlB;MACD;IACF;;IACD,KAAK,MAAML,IAAX,IAAmBH,IAAI,CAACU,OAAxB,EAAiC;MAC/B,IAAIP,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAvB,EAA6B;QAC3BN,QAAQ,CAACQ,GAAT,CAAaN,IAAI,CAACQ,IAAlB;MACD;IACF;EACF;;EACD,MAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;EACA,KAAK,MAAMN,IAAX,IAAmBN,QAAnB,EAA6B;IAC3B,KAAK,MAAME,IAAX,IAAmBI,IAAI,CAACG,OAAxB,EAAiC;MAC/B;MACA;MACA,IAAI,CAACP,IAAI,CAACG,KAAV,EAAiB;QACf;MACD,CAL8B,CAM/B;;;MACA,IAAI,CAACH,IAAI,CAACI,IAAN,IAAcJ,IAAI,CAACQ,IAAL,CAAUG,KAA5B,EAAmC;QACjC;QACA,MAAMC,GAAG,GAAG,IAAIb,GAAJ,CAAQ,CAACK,IAAD,CAAR,CAAZ;;QACA,KAAK,MAAMA,IAAX,IAAmBQ,GAAnB,EAAwB;UACtB,KAAK,MAAMZ,IAAX,IAAmBI,IAAI,CAACH,QAAL,CAAcC,MAAd,EAAnB,EAA2C;YACzC,IAAIF,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAnB,IAA2BJ,IAAI,CAACK,EAApC,EAAwC;cACtCO,GAAG,CAACN,GAAJ,CAAQN,IAAI,CAACK,EAAb;YACD;UACF;QACF,CATgC,CAUjC;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;;QACA,IAAIO,GAAG,CAACC,GAAJ,CAAQhB,IAAR,CAAJ,EAAmB;UACjBY,SAAS,CAACK,GAAV,CAAcd,IAAd,EAAoBY,GAApB;QACD;MACF;IACF;EACF;;EAED,OAAOH,SAAP;AACD,CAhED;;AAkEAM,MAAM,CAACC,OAAP,GAAiBpB,aAAjB"},"metadata":{},"sourceType":"script"}