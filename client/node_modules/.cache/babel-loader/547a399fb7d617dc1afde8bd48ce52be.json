{"ast":null,"code":"'use strict';\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  parser,\n  arrayDelimiter\n} = require('@npmcli/query');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst npa = require('npm-package-arg');\n\nconst minimatch = require('minimatch');\n\nconst semver = require('semver'); // handle results for parsed query asts, results are stored in a map that has a\n// key that points to each ast selector node and stores the resulting array of\n// arborist nodes as its value, that is essential to how we handle multiple\n// query selectors, e.g: `#a, #b, #c` <- 3 diff ast selector nodes\n\n\nclass Results {\n  #currentAstSelector;\n  #initialItems;\n  #inventory;\n  #pendingCombinator;\n  #results = new Map();\n  #targetNode;\n\n  constructor(opts) {\n    this.#currentAstSelector = opts.rootAstNode.nodes[0];\n    this.#inventory = opts.inventory;\n    this.#initialItems = opts.initialItems;\n    this.#targetNode = opts.targetNode;\n    this.currentResults = this.#initialItems; // reset by rootAstNode walker\n\n    this.currentAstNode = opts.rootAstNode;\n  }\n\n  get currentResults() {\n    return this.#results.get(this.#currentAstSelector);\n  }\n\n  set currentResults(value) {\n    this.#results.set(this.#currentAstSelector, value);\n  } // retrieves the initial items to which start the filtering / matching\n  // for most of the different types of recognized ast nodes, e.g: class (aka\n  // depType), id, *, etc in different contexts we need to start with the\n  // current list of filtered results, for example a query for `.workspace`\n  // actually means the same as `*.workspace` so we want to start with the full\n  // inventory if that's the first ast node we're reading but if it appears in\n  // the middle of a query it should respect the previous filtered results,\n  // combinators are a special case in which we always want to have the\n  // complete inventory list in order to use the left-hand side ast node as a\n  // filter combined with the element on its right-hand side\n\n\n  get initialItems() {\n    const firstParsed = this.currentAstNode.parent.nodes[0] === this.currentAstNode && this.currentAstNode.parent.parent.type === 'root';\n\n    if (firstParsed) {\n      return this.#initialItems;\n    }\n\n    if (this.currentAstNode.prev().type === 'combinator') {\n      return this.#inventory;\n    }\n\n    return this.currentResults;\n  } // combinators need information about previously filtered items along\n  // with info of the items parsed / retrieved from the selector right\n  // past the combinator, for this reason combinators are stored and\n  // only ran as the last part of each selector logic\n\n\n  processPendingCombinator(nextResults) {\n    if (this.#pendingCombinator) {\n      const res = this.#pendingCombinator(this.currentResults, nextResults);\n      this.#pendingCombinator = null;\n      this.currentResults = res;\n    } else {\n      this.currentResults = nextResults;\n    }\n  } // when collecting results to a root astNode, we traverse the list of child\n  // selector nodes and collect all of their resulting arborist nodes into a\n  // single/flat Set of items, this ensures we also deduplicate items\n\n\n  collect(rootAstNode) {\n    return new Set(rootAstNode.nodes.flatMap(n => this.#results.get(n)));\n  } // selector types map to the '.type' property of the ast nodes via `${astNode.type}Type`\n  //\n  // attribute selector [name=value], etc\n\n\n  attributeType() {\n    const nextResults = this.initialItems.filter(node => attributeMatch(this.currentAstNode, node.package));\n    this.processPendingCombinator(nextResults);\n  } // dependency type selector (i.e. .prod, .dev, etc)\n  // css calls this class, we interpret is as dependency type\n\n\n  classType() {\n    const depTypeFn = depTypes[String(this.currentAstNode)];\n\n    if (!depTypeFn) {\n      throw Object.assign(new Error(`\\`${String(this.currentAstNode)}\\` is not a supported dependency type.`), {\n        code: 'EQUERYNODEPTYPE'\n      });\n    }\n\n    const nextResults = depTypeFn(this.initialItems);\n    this.processPendingCombinator(nextResults);\n  } // combinators (i.e. '>', ' ', '~')\n\n\n  combinatorType() {\n    this.#pendingCombinator = combinators[String(this.currentAstNode)];\n  } // name selectors (i.e. #foo, #foo@1.0.0)\n  // css calls this id, we interpret it as name\n\n\n  idType() {\n    const spec = npa(this.currentAstNode.value);\n    const nextResults = this.initialItems.filter(node => (node.name === spec.name || node.package.name === spec.name) && (semver.satisfies(node.version, spec.fetchSpec) || !spec.rawSpec));\n    this.processPendingCombinator(nextResults);\n  } // pseudo selectors (prefixed with :)\n\n\n  pseudoType() {\n    const pseudoFn = `${this.currentAstNode.value.slice(1)}Pseudo`;\n\n    if (!this[pseudoFn]) {\n      throw Object.assign(new Error(`\\`${this.currentAstNode.value}\\` is not a supported pseudo selector.`), {\n        code: 'EQUERYNOPSEUDO'\n      });\n    }\n\n    const nextResults = this[pseudoFn]();\n    this.processPendingCombinator(nextResults);\n  }\n\n  selectorType() {\n    this.#currentAstSelector = this.currentAstNode; // starts a new array in which resulting items\n    // can be stored for each given ast selector\n\n    if (!this.currentResults) {\n      this.currentResults = [];\n    }\n  }\n\n  universalType() {\n    this.processPendingCombinator(this.initialItems);\n  } // pseudo selectors map to the 'value' property of the pseudo selectors in the ast nodes\n  // via selectors via `${value.slice(1)}Pseudo`\n\n\n  attrPseudo() {\n    const {\n      lookupProperties,\n      attributeMatcher\n    } = this.currentAstNode;\n    return this.initialItems.filter(node => {\n      let objs = [node.package];\n\n      for (const prop of lookupProperties) {\n        // if an isArray symbol is found that means we'll need to iterate\n        // over the previous found array to basically make sure we traverse\n        // all its indexes testing for possible objects that may eventually\n        // hold more keys specified in a selector\n        if (prop === arrayDelimiter) {\n          objs = objs.flat();\n          continue;\n        } // otherwise just maps all currently found objs\n        // to the next prop from the lookup properties list,\n        // filters out any empty key lookup\n\n\n        objs = objs.flatMap(obj => obj[prop] || []); // in case there's no property found in the lookup\n        // just filters that item out\n\n        const noAttr = objs.every(obj => !obj);\n\n        if (noAttr) {\n          return false;\n        }\n      } // if any of the potential object matches\n      // that item should be in the final result\n\n\n      return objs.some(obj => attributeMatch(attributeMatcher, obj));\n    });\n  }\n\n  emptyPseudo() {\n    return this.initialItems.filter(node => node.edgesOut.size === 0);\n  }\n\n  extraneousPseudo() {\n    return this.initialItems.filter(node => node.extraneous);\n  }\n\n  hasPseudo() {\n    const found = [];\n\n    for (const item of this.initialItems) {\n      const res = retrieveNodesFromParsedAst({\n        // This is the one time initialItems differs from inventory\n        initialItems: [item],\n        inventory: this.#inventory,\n        rootAstNode: this.currentAstNode.nestedNode,\n        targetNode: item\n      });\n\n      if (res.size > 0) {\n        found.push(item);\n      }\n    }\n\n    return found;\n  }\n\n  invalidPseudo() {\n    const found = [];\n\n    for (const node of this.initialItems) {\n      for (const edge of node.edgesIn) {\n        if (edge.invalid) {\n          found.push(node);\n          break;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  isPseudo() {\n    const res = retrieveNodesFromParsedAst({\n      initialItems: this.initialItems,\n      inventory: this.#inventory,\n      rootAstNode: this.currentAstNode.nestedNode,\n      targetNode: this.currentAstNode\n    });\n    return [...res];\n  }\n\n  linkPseudo() {\n    return this.initialItems.filter(node => node.isLink || node.isTop && !node.isRoot);\n  }\n\n  missingPseudo() {\n    return this.#inventory.reduce((res, node) => {\n      for (const edge of node.edgesOut.values()) {\n        if (edge.missing) {\n          const pkg = {\n            name: edge.name,\n            version: edge.spec\n          };\n          res.push(new this.#targetNode.constructor({\n            pkg\n          }));\n        }\n      }\n\n      return res;\n    }, []);\n  }\n\n  notPseudo() {\n    const res = retrieveNodesFromParsedAst({\n      initialItems: this.initialItems,\n      inventory: this.#inventory,\n      rootAstNode: this.currentAstNode.nestedNode,\n      targetNode: this.currentAstNode\n    });\n    const internalSelector = new Set(res);\n    return this.initialItems.filter(node => !internalSelector.has(node));\n  }\n\n  pathPseudo() {\n    return this.initialItems.filter(node => {\n      if (!this.currentAstNode.pathValue) {\n        return true;\n      }\n\n      return minimatch(node.realpath.replace(/\\\\+/g, '/'), resolve(node.root.realpath, this.currentAstNode.pathValue).replace(/\\\\+/g, '/'));\n    });\n  }\n\n  privatePseudo() {\n    return this.initialItems.filter(node => node.package.private);\n  }\n\n  rootPseudo() {\n    return this.initialItems.filter(node => node === this.#targetNode.root);\n  }\n\n  scopePseudo() {\n    return this.initialItems.filter(node => node === this.#targetNode);\n  }\n\n  semverPseudo() {\n    if (!this.currentAstNode.semverValue) {\n      return this.initialItems;\n    }\n\n    return this.initialItems.filter(node => semver.satisfies(node.version, this.currentAstNode.semverValue));\n  }\n\n  typePseudo() {\n    if (!this.currentAstNode.typeValue) {\n      return this.initialItems;\n    }\n\n    return this.initialItems.flatMap(node => {\n      const found = [];\n\n      for (const edge of node.edgesIn) {\n        if (npa(`${edge.name}@${edge.spec}`).type === this.currentAstNode.typeValue) {\n          found.push(edge.to);\n        }\n      }\n\n      return found;\n    });\n  }\n\n  dedupedPseudo() {\n    return this.initialItems.filter(node => node.target.edgesIn.size > 1);\n  }\n\n} // operators for attribute selectors\n\n\nconst attributeOperators = {\n  // attribute value is equivalent\n  '='(_ref) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref;\n    return attr === value;\n  },\n\n  // attribute value contains word\n  '~='(_ref2) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref2;\n    return (attr.match(/\\w+/g) || []).includes(value);\n  },\n\n  // attribute value contains string\n  '*='(_ref3) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref3;\n    return attr.includes(value);\n  },\n\n  // attribute value is equal or starts with\n  '|='(_ref4) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref4;\n    return attr.startsWith(`${value}-`);\n  },\n\n  // attribute value starts with\n  '^='(_ref5) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref5;\n    return attr.startsWith(value);\n  },\n\n  // attribute value ends with\n  '$='(_ref6) {\n    let {\n      attr,\n      value,\n      insensitive\n    } = _ref6;\n    return attr.endsWith(value);\n  }\n\n};\n\nconst attributeOperator = _ref7 => {\n  let {\n    attr,\n    value,\n    insensitive,\n    operator\n  } = _ref7;\n\n  if (typeof attr === 'number') {\n    attr = String(attr);\n  }\n\n  if (typeof attr !== 'string') {\n    // It's an object or an array, bail\n    return false;\n  }\n\n  if (insensitive) {\n    attr = attr.toLowerCase();\n  }\n\n  return attributeOperators[operator]({\n    attr,\n    insensitive,\n    value\n  });\n};\n\nconst attributeMatch = (matcher, obj) => {\n  const insensitive = !!matcher.insensitive;\n  const operator = matcher.operator || '';\n  const attribute = matcher.qualifiedAttribute;\n  let value = matcher.value || ''; // return early if checking existence\n\n  if (operator === '') {\n    return Boolean(obj[attribute]);\n  }\n\n  if (insensitive) {\n    value = value.toLowerCase();\n  } // in case the current object is an array\n  // then we try to match every item in the array\n\n\n  if (Array.isArray(obj[attribute])) {\n    return obj[attribute].find((i, index) => {\n      const attr = obj[attribute][index] || '';\n      return attributeOperator({\n        attr,\n        value,\n        insensitive,\n        operator\n      });\n    });\n  } else {\n    const attr = obj[attribute] || '';\n    return attributeOperator({\n      attr,\n      value,\n      insensitive,\n      operator\n    });\n  }\n};\n\nconst edgeIsType = function (node, type) {\n  let seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n\n  for (const edgeIn of node.edgesIn) {\n    // TODO Need a test with an infinite loop\n    if (seen.has(edgeIn)) {\n      continue;\n    }\n\n    seen.add(edgeIn);\n\n    if (edgeIn.type === type || edgeIn.from[type] || edgeIsType(edgeIn.from, type, seen)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst filterByType = (nodes, type) => {\n  const found = [];\n\n  for (const node of nodes) {\n    if (node[type] || edgeIsType(node, type)) {\n      found.push(node);\n    }\n  }\n\n  return found;\n};\n\nconst depTypes = {\n  // dependency\n  '.prod'(prevResults) {\n    const found = [];\n\n    for (const node of prevResults) {\n      if (!node.dev) {\n        found.push(node);\n      }\n    }\n\n    return found;\n  },\n\n  // devDependency\n  '.dev'(prevResults) {\n    return filterByType(prevResults, 'dev');\n  },\n\n  // optionalDependency\n  '.optional'(prevResults) {\n    return filterByType(prevResults, 'optional');\n  },\n\n  // peerDependency\n  '.peer'(prevResults) {\n    return filterByType(prevResults, 'peer');\n  },\n\n  // workspace\n  '.workspace'(prevResults) {\n    return prevResults.filter(node => node.isWorkspace);\n  },\n\n  // bundledDependency\n  '.bundled'(prevResults) {\n    return prevResults.filter(node => node.inBundle);\n  }\n\n}; // checks if a given node has a direct parent in any of the nodes provided in\n// the compare nodes array\n\nconst hasParent = (node, compareNodes) => {\n  // All it takes is one so we loop and return on the first hit\n  for (const compareNode of compareNodes) {\n    // follows logical parent for link anscestors\n    if (node.isTop && node.resolveParent === compareNode) {\n      return true;\n    } // follows edges-in to check if they match a possible parent\n\n\n    for (const edge of node.edgesIn) {\n      if (edge && edge.from === compareNode) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // checks if a given node is a descendant of any of the nodes provided in the\n// compareNodes array\n\n\nconst hasAscendant = function (node, compareNodes) {\n  let seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n\n  // TODO (future) loop over ancestry property\n  if (hasParent(node, compareNodes)) {\n    return true;\n  }\n\n  if (node.isTop && node.resolveParent) {\n    return hasAscendant(node.resolveParent, compareNodes);\n  }\n\n  for (const edge of node.edgesIn) {\n    // TODO Need a test with an infinite loop\n    if (seen.has(edge)) {\n      continue;\n    }\n\n    seen.add(edge);\n\n    if (edge && edge.from && hasAscendant(edge.from, compareNodes, seen)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst combinators = {\n  // direct descendant\n  '>'(prevResults, nextResults) {\n    return nextResults.filter(node => hasParent(node, prevResults));\n  },\n\n  // any descendant\n  ' '(prevResults, nextResults) {\n    return nextResults.filter(node => hasAscendant(node, prevResults));\n  },\n\n  // sibling\n  '~'(prevResults, nextResults) {\n    // Return any node in nextResults that is a sibling of (aka shares a\n    // parent with) a node in prevResults\n    const parentNodes = new Set(); // Parents of everything in prevResults\n\n    for (const node of prevResults) {\n      for (const edge of node.edgesIn) {\n        // edge.from always exists cause it's from another node's edgesIn\n        parentNodes.add(edge.from);\n      }\n    }\n\n    return nextResults.filter(node => !prevResults.includes(node) && hasParent(node, [...parentNodes]));\n  }\n\n};\n\nconst retrieveNodesFromParsedAst = opts => {\n  // when we first call this it's the parsed query.  all other times it's\n  // results.currentNode.nestedNode\n  const rootAstNode = opts.rootAstNode;\n\n  if (!rootAstNode.nodes) {\n    return new Set();\n  }\n\n  const results = new Results(opts);\n  rootAstNode.walk(nextAstNode => {\n    // This is the only place we reset currentAstNode\n    results.currentAstNode = nextAstNode;\n    const updateFn = `${results.currentAstNode.type}Type`;\n\n    if (typeof results[updateFn] !== 'function') {\n      throw Object.assign(new Error(`\\`${results.currentAstNode.type}\\` is not a supported selector.`), {\n        code: 'EQUERYNOSELECTOR'\n      });\n    }\n\n    results[updateFn]();\n  });\n  return results.collect(rootAstNode);\n}; // We are keeping this async in the event that we do add async operators, we\n// won't have to have a breaking change on this function signature.\n\n\nconst querySelectorAll = async (targetNode, query) => {\n  // This never changes ever we just pass it around. But we can't scope it to\n  // this whole file if we ever want to support concurrent calls to this\n  // function.\n  const inventory = [...targetNode.root.inventory.values()]; // res is a Set of items returned for each parsed css ast selector\n\n  const res = retrieveNodesFromParsedAst({\n    initialItems: inventory,\n    inventory,\n    rootAstNode: parser(query),\n    targetNode\n  }); // returns nodes ordered by realpath\n\n  return [...res].sort((a, b) => localeCompare(a.location, b.location));\n};\n\nmodule.exports = querySelectorAll;","map":{"version":3,"names":["resolve","require","parser","arrayDelimiter","localeCompare","npa","minimatch","semver","Results","currentAstSelector","initialItems","inventory","pendingCombinator","results","Map","targetNode","constructor","opts","rootAstNode","nodes","currentResults","currentAstNode","get","value","set","firstParsed","parent","type","prev","processPendingCombinator","nextResults","res","collect","Set","flatMap","n","attributeType","filter","node","attributeMatch","package","classType","depTypeFn","depTypes","String","Object","assign","Error","code","combinatorType","combinators","idType","spec","name","satisfies","version","fetchSpec","rawSpec","pseudoType","pseudoFn","slice","selectorType","universalType","attrPseudo","lookupProperties","attributeMatcher","objs","prop","flat","obj","noAttr","every","some","emptyPseudo","edgesOut","size","extraneousPseudo","extraneous","hasPseudo","found","item","retrieveNodesFromParsedAst","nestedNode","push","invalidPseudo","edge","edgesIn","invalid","isPseudo","linkPseudo","isLink","isTop","isRoot","missingPseudo","reduce","values","missing","pkg","notPseudo","internalSelector","has","pathPseudo","pathValue","realpath","replace","root","privatePseudo","private","rootPseudo","scopePseudo","semverPseudo","semverValue","typePseudo","typeValue","to","dedupedPseudo","target","attributeOperators","attr","insensitive","match","includes","startsWith","endsWith","attributeOperator","operator","toLowerCase","matcher","attribute","qualifiedAttribute","Boolean","Array","isArray","find","i","index","edgeIsType","seen","edgeIn","add","from","filterByType","prevResults","dev","isWorkspace","inBundle","hasParent","compareNodes","compareNode","resolveParent","hasAscendant","parentNodes","walk","nextAstNode","updateFn","querySelectorAll","query","sort","a","b","location","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/query-selector-all.js"],"sourcesContent":["'use strict'\n\nconst { resolve } = require('path')\nconst { parser, arrayDelimiter } = require('@npmcli/query')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst minimatch = require('minimatch')\nconst semver = require('semver')\n\n// handle results for parsed query asts, results are stored in a map that has a\n// key that points to each ast selector node and stores the resulting array of\n// arborist nodes as its value, that is essential to how we handle multiple\n// query selectors, e.g: `#a, #b, #c` <- 3 diff ast selector nodes\nclass Results {\n  #currentAstSelector\n  #initialItems\n  #inventory\n  #pendingCombinator\n  #results = new Map()\n  #targetNode\n\n  constructor (opts) {\n    this.#currentAstSelector = opts.rootAstNode.nodes[0]\n    this.#inventory = opts.inventory\n    this.#initialItems = opts.initialItems\n    this.#targetNode = opts.targetNode\n\n    this.currentResults = this.#initialItems\n\n    // reset by rootAstNode walker\n    this.currentAstNode = opts.rootAstNode\n  }\n\n  get currentResults () {\n    return this.#results.get(this.#currentAstSelector)\n  }\n\n  set currentResults (value) {\n    this.#results.set(this.#currentAstSelector, value)\n  }\n\n  // retrieves the initial items to which start the filtering / matching\n  // for most of the different types of recognized ast nodes, e.g: class (aka\n  // depType), id, *, etc in different contexts we need to start with the\n  // current list of filtered results, for example a query for `.workspace`\n  // actually means the same as `*.workspace` so we want to start with the full\n  // inventory if that's the first ast node we're reading but if it appears in\n  // the middle of a query it should respect the previous filtered results,\n  // combinators are a special case in which we always want to have the\n  // complete inventory list in order to use the left-hand side ast node as a\n  // filter combined with the element on its right-hand side\n  get initialItems () {\n    const firstParsed =\n      (this.currentAstNode.parent.nodes[0] === this.currentAstNode) &&\n      (this.currentAstNode.parent.parent.type === 'root')\n\n    if (firstParsed) {\n      return this.#initialItems\n    }\n    if (this.currentAstNode.prev().type === 'combinator') {\n      return this.#inventory\n    }\n    return this.currentResults\n  }\n\n  // combinators need information about previously filtered items along\n  // with info of the items parsed / retrieved from the selector right\n  // past the combinator, for this reason combinators are stored and\n  // only ran as the last part of each selector logic\n  processPendingCombinator (nextResults) {\n    if (this.#pendingCombinator) {\n      const res = this.#pendingCombinator(this.currentResults, nextResults)\n      this.#pendingCombinator = null\n      this.currentResults = res\n    } else {\n      this.currentResults = nextResults\n    }\n  }\n\n  // when collecting results to a root astNode, we traverse the list of child\n  // selector nodes and collect all of their resulting arborist nodes into a\n  // single/flat Set of items, this ensures we also deduplicate items\n  collect (rootAstNode) {\n    return new Set(rootAstNode.nodes.flatMap(n => this.#results.get(n)))\n  }\n\n  // selector types map to the '.type' property of the ast nodes via `${astNode.type}Type`\n  //\n  // attribute selector [name=value], etc\n  attributeType () {\n    const nextResults = this.initialItems.filter(node =>\n      attributeMatch(this.currentAstNode, node.package)\n    )\n    this.processPendingCombinator(nextResults)\n  }\n\n  // dependency type selector (i.e. .prod, .dev, etc)\n  // css calls this class, we interpret is as dependency type\n  classType () {\n    const depTypeFn = depTypes[String(this.currentAstNode)]\n    if (!depTypeFn) {\n      throw Object.assign(\n        new Error(`\\`${String(this.currentAstNode)}\\` is not a supported dependency type.`),\n        { code: 'EQUERYNODEPTYPE' }\n      )\n    }\n    const nextResults = depTypeFn(this.initialItems)\n    this.processPendingCombinator(nextResults)\n  }\n\n  // combinators (i.e. '>', ' ', '~')\n  combinatorType () {\n    this.#pendingCombinator = combinators[String(this.currentAstNode)]\n  }\n\n  // name selectors (i.e. #foo, #foo@1.0.0)\n  // css calls this id, we interpret it as name\n  idType () {\n    const spec = npa(this.currentAstNode.value)\n    const nextResults = this.initialItems.filter(node =>\n      (node.name === spec.name || node.package.name === spec.name) &&\n      (semver.satisfies(node.version, spec.fetchSpec) || !spec.rawSpec))\n    this.processPendingCombinator(nextResults)\n  }\n\n  // pseudo selectors (prefixed with :)\n  pseudoType () {\n    const pseudoFn = `${this.currentAstNode.value.slice(1)}Pseudo`\n    if (!this[pseudoFn]) {\n      throw Object.assign(\n        new Error(`\\`${this.currentAstNode.value\n        }\\` is not a supported pseudo selector.`),\n        { code: 'EQUERYNOPSEUDO' }\n      )\n    }\n    const nextResults = this[pseudoFn]()\n    this.processPendingCombinator(nextResults)\n  }\n\n  selectorType () {\n    this.#currentAstSelector = this.currentAstNode\n    // starts a new array in which resulting items\n    // can be stored for each given ast selector\n    if (!this.currentResults) {\n      this.currentResults = []\n    }\n  }\n\n  universalType () {\n    this.processPendingCombinator(this.initialItems)\n  }\n\n  // pseudo selectors map to the 'value' property of the pseudo selectors in the ast nodes\n  // via selectors via `${value.slice(1)}Pseudo`\n  attrPseudo () {\n    const { lookupProperties, attributeMatcher } = this.currentAstNode\n\n    return this.initialItems.filter(node => {\n      let objs = [node.package]\n      for (const prop of lookupProperties) {\n        // if an isArray symbol is found that means we'll need to iterate\n        // over the previous found array to basically make sure we traverse\n        // all its indexes testing for possible objects that may eventually\n        // hold more keys specified in a selector\n        if (prop === arrayDelimiter) {\n          objs = objs.flat()\n          continue\n        }\n\n        // otherwise just maps all currently found objs\n        // to the next prop from the lookup properties list,\n        // filters out any empty key lookup\n        objs = objs.flatMap(obj => obj[prop] || [])\n\n        // in case there's no property found in the lookup\n        // just filters that item out\n        const noAttr = objs.every(obj => !obj)\n        if (noAttr) {\n          return false\n        }\n      }\n\n      // if any of the potential object matches\n      // that item should be in the final result\n      return objs.some(obj => attributeMatch(attributeMatcher, obj))\n    })\n  }\n\n  emptyPseudo () {\n    return this.initialItems.filter(node => node.edgesOut.size === 0)\n  }\n\n  extraneousPseudo () {\n    return this.initialItems.filter(node => node.extraneous)\n  }\n\n  hasPseudo () {\n    const found = []\n    for (const item of this.initialItems) {\n      const res = retrieveNodesFromParsedAst({\n        // This is the one time initialItems differs from inventory\n        initialItems: [item],\n        inventory: this.#inventory,\n        rootAstNode: this.currentAstNode.nestedNode,\n        targetNode: item,\n      })\n      if (res.size > 0) {\n        found.push(item)\n      }\n    }\n    return found\n  }\n\n  invalidPseudo () {\n    const found = []\n    for (const node of this.initialItems) {\n      for (const edge of node.edgesIn) {\n        if (edge.invalid) {\n          found.push(node)\n          break\n        }\n      }\n    }\n    return found\n  }\n\n  isPseudo () {\n    const res = retrieveNodesFromParsedAst({\n      initialItems: this.initialItems,\n      inventory: this.#inventory,\n      rootAstNode: this.currentAstNode.nestedNode,\n      targetNode: this.currentAstNode,\n    })\n    return [...res]\n  }\n\n  linkPseudo () {\n    return this.initialItems.filter(node => node.isLink || (node.isTop && !node.isRoot))\n  }\n\n  missingPseudo () {\n    return this.#inventory.reduce((res, node) => {\n      for (const edge of node.edgesOut.values()) {\n        if (edge.missing) {\n          const pkg = { name: edge.name, version: edge.spec }\n          res.push(new this.#targetNode.constructor({ pkg }))\n        }\n      }\n      return res\n    }, [])\n  }\n\n  notPseudo () {\n    const res = retrieveNodesFromParsedAst({\n      initialItems: this.initialItems,\n      inventory: this.#inventory,\n      rootAstNode: this.currentAstNode.nestedNode,\n      targetNode: this.currentAstNode,\n    })\n    const internalSelector = new Set(res)\n    return this.initialItems.filter(node =>\n      !internalSelector.has(node))\n  }\n\n  pathPseudo () {\n    return this.initialItems.filter(node => {\n      if (!this.currentAstNode.pathValue) {\n        return true\n      }\n      return minimatch(\n        node.realpath.replace(/\\\\+/g, '/'),\n        resolve(node.root.realpath, this.currentAstNode.pathValue).replace(/\\\\+/g, '/')\n      )\n    })\n  }\n\n  privatePseudo () {\n    return this.initialItems.filter(node => node.package.private)\n  }\n\n  rootPseudo () {\n    return this.initialItems.filter(node => node === this.#targetNode.root)\n  }\n\n  scopePseudo () {\n    return this.initialItems.filter(node => node === this.#targetNode)\n  }\n\n  semverPseudo () {\n    if (!this.currentAstNode.semverValue) {\n      return this.initialItems\n    }\n    return this.initialItems.filter(node =>\n      semver.satisfies(node.version, this.currentAstNode.semverValue))\n  }\n\n  typePseudo () {\n    if (!this.currentAstNode.typeValue) {\n      return this.initialItems\n    }\n    return this.initialItems\n      .flatMap(node => {\n        const found = []\n        for (const edge of node.edgesIn) {\n          if (npa(`${edge.name}@${edge.spec}`).type === this.currentAstNode.typeValue) {\n            found.push(edge.to)\n          }\n        }\n        return found\n      })\n  }\n\n  dedupedPseudo () {\n    return this.initialItems.filter(node => node.target.edgesIn.size > 1)\n  }\n}\n\n// operators for attribute selectors\nconst attributeOperators = {\n  // attribute value is equivalent\n  '=' ({ attr, value, insensitive }) {\n    return attr === value\n  },\n  // attribute value contains word\n  '~=' ({ attr, value, insensitive }) {\n    return (attr.match(/\\w+/g) || []).includes(value)\n  },\n  // attribute value contains string\n  '*=' ({ attr, value, insensitive }) {\n    return attr.includes(value)\n  },\n  // attribute value is equal or starts with\n  '|=' ({ attr, value, insensitive }) {\n    return attr.startsWith(`${value}-`)\n  },\n  // attribute value starts with\n  '^=' ({ attr, value, insensitive }) {\n    return attr.startsWith(value)\n  },\n  // attribute value ends with\n  '$=' ({ attr, value, insensitive }) {\n    return attr.endsWith(value)\n  },\n}\n\nconst attributeOperator = ({ attr, value, insensitive, operator }) => {\n  if (typeof attr === 'number') {\n    attr = String(attr)\n  }\n  if (typeof attr !== 'string') {\n    // It's an object or an array, bail\n    return false\n  }\n  if (insensitive) {\n    attr = attr.toLowerCase()\n  }\n  return attributeOperators[operator]({\n    attr,\n    insensitive,\n    value,\n  })\n}\n\nconst attributeMatch = (matcher, obj) => {\n  const insensitive = !!matcher.insensitive\n  const operator = matcher.operator || ''\n  const attribute = matcher.qualifiedAttribute\n  let value = matcher.value || ''\n  // return early if checking existence\n  if (operator === '') {\n    return Boolean(obj[attribute])\n  }\n  if (insensitive) {\n    value = value.toLowerCase()\n  }\n  // in case the current object is an array\n  // then we try to match every item in the array\n  if (Array.isArray(obj[attribute])) {\n    return obj[attribute].find((i, index) => {\n      const attr = obj[attribute][index] || ''\n      return attributeOperator({ attr, value, insensitive, operator })\n    })\n  } else {\n    const attr = obj[attribute] || ''\n    return attributeOperator({ attr, value, insensitive, operator })\n  }\n}\n\nconst edgeIsType = (node, type, seen = new Set()) => {\n  for (const edgeIn of node.edgesIn) {\n    // TODO Need a test with an infinite loop\n    if (seen.has(edgeIn)) {\n      continue\n    }\n    seen.add(edgeIn)\n    if (edgeIn.type === type || edgeIn.from[type] || edgeIsType(edgeIn.from, type, seen)) {\n      return true\n    }\n  }\n  return false\n}\n\nconst filterByType = (nodes, type) => {\n  const found = []\n  for (const node of nodes) {\n    if (node[type] || edgeIsType(node, type)) {\n      found.push(node)\n    }\n  }\n  return found\n}\n\nconst depTypes = {\n  // dependency\n  '.prod' (prevResults) {\n    const found = []\n    for (const node of prevResults) {\n      if (!node.dev) {\n        found.push(node)\n      }\n    }\n    return found\n  },\n  // devDependency\n  '.dev' (prevResults) {\n    return filterByType(prevResults, 'dev')\n  },\n  // optionalDependency\n  '.optional' (prevResults) {\n    return filterByType(prevResults, 'optional')\n  },\n  // peerDependency\n  '.peer' (prevResults) {\n    return filterByType(prevResults, 'peer')\n  },\n  // workspace\n  '.workspace' (prevResults) {\n    return prevResults.filter(node => node.isWorkspace)\n  },\n  // bundledDependency\n  '.bundled' (prevResults) {\n    return prevResults.filter(node => node.inBundle)\n  },\n}\n\n// checks if a given node has a direct parent in any of the nodes provided in\n// the compare nodes array\nconst hasParent = (node, compareNodes) => {\n  // All it takes is one so we loop and return on the first hit\n  for (const compareNode of compareNodes) {\n    // follows logical parent for link anscestors\n    if (node.isTop && (node.resolveParent === compareNode)) {\n      return true\n    }\n    // follows edges-in to check if they match a possible parent\n    for (const edge of node.edgesIn) {\n      if (edge && edge.from === compareNode) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// checks if a given node is a descendant of any of the nodes provided in the\n// compareNodes array\nconst hasAscendant = (node, compareNodes, seen = new Set()) => {\n  // TODO (future) loop over ancestry property\n  if (hasParent(node, compareNodes)) {\n    return true\n  }\n\n  if (node.isTop && node.resolveParent) {\n    return hasAscendant(node.resolveParent, compareNodes)\n  }\n  for (const edge of node.edgesIn) {\n    // TODO Need a test with an infinite loop\n    if (seen.has(edge)) {\n      continue\n    }\n    seen.add(edge)\n    if (edge && edge.from && hasAscendant(edge.from, compareNodes, seen)) {\n      return true\n    }\n  }\n  return false\n}\n\nconst combinators = {\n  // direct descendant\n  '>' (prevResults, nextResults) {\n    return nextResults.filter(node => hasParent(node, prevResults))\n  },\n  // any descendant\n  ' ' (prevResults, nextResults) {\n    return nextResults.filter(node => hasAscendant(node, prevResults))\n  },\n  // sibling\n  '~' (prevResults, nextResults) {\n    // Return any node in nextResults that is a sibling of (aka shares a\n    // parent with) a node in prevResults\n    const parentNodes = new Set() // Parents of everything in prevResults\n    for (const node of prevResults) {\n      for (const edge of node.edgesIn) {\n        // edge.from always exists cause it's from another node's edgesIn\n        parentNodes.add(edge.from)\n      }\n    }\n    return nextResults.filter(node =>\n      !prevResults.includes(node) && hasParent(node, [...parentNodes])\n    )\n  },\n}\n\nconst retrieveNodesFromParsedAst = (opts) => {\n  // when we first call this it's the parsed query.  all other times it's\n  // results.currentNode.nestedNode\n  const rootAstNode = opts.rootAstNode\n\n  if (!rootAstNode.nodes) {\n    return new Set()\n  }\n\n  const results = new Results(opts)\n\n  rootAstNode.walk((nextAstNode) => {\n    // This is the only place we reset currentAstNode\n    results.currentAstNode = nextAstNode\n    const updateFn = `${results.currentAstNode.type}Type`\n    if (typeof results[updateFn] !== 'function') {\n      throw Object.assign(\n        new Error(`\\`${results.currentAstNode.type}\\` is not a supported selector.`),\n        { code: 'EQUERYNOSELECTOR' }\n      )\n    }\n    results[updateFn]()\n  })\n\n  return results.collect(rootAstNode)\n}\n\n// We are keeping this async in the event that we do add async operators, we\n// won't have to have a breaking change on this function signature.\nconst querySelectorAll = async (targetNode, query) => {\n  // This never changes ever we just pass it around. But we can't scope it to\n  // this whole file if we ever want to support concurrent calls to this\n  // function.\n  const inventory = [...targetNode.root.inventory.values()]\n  // res is a Set of items returned for each parsed css ast selector\n  const res = retrieveNodesFromParsedAst({\n    initialItems: inventory,\n    inventory,\n    rootAstNode: parser(query),\n    targetNode,\n  })\n\n  // returns nodes ordered by realpath\n  return [...res].sort((a, b) => localeCompare(a.location, b.location))\n}\n\nmodule.exports = querySelectorAll\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}