{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst fs = require('fs');\n\nconst lstat = promisify(fs.lstat);\n\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') {\n    throw er;\n  }\n};\n\nconst cmdShim = require('cmd-shim');\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst fixBin = require('./fix-bin.js'); // even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\n\n\nconst seen = new Set();\n\nconst failEEXIST = _ref => {\n  let {\n    path,\n    to,\n    from\n  } = _ref;\n  return Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: to,\n    dest: from,\n    code: 'EEXIST'\n  }));\n};\n\nconst handleReadCmdShimError = _ref2 => {\n  let {\n    er,\n    from,\n    to\n  } = _ref2;\n  return er.code === 'ENOENT' ? null : er.code === 'ENOTASHIM' ? failEEXIST({\n    from,\n    to\n  }) : Promise.reject(er);\n};\n\nconst SKIP = Symbol('skip - missing or already installed');\n\nconst shimBin = _ref3 => {\n  let {\n    path,\n    to,\n    from,\n    absFrom,\n    force\n  } = _ref3;\n  const shims = [to, to + '.cmd', to + '.ps1'];\n\n  for (const shim of shims) {\n    if (seen.has(shim)) {\n      return true;\n    }\n\n    seen.add(shim);\n  }\n\n  return Promise.all([...shims, absFrom].map(f => lstat(f).catch(throwNonEnoent))).then(stats => {\n    const [,,, stFrom] = stats;\n\n    if (!stFrom) {\n      return SKIP;\n    }\n\n    if (force) {\n      return;\n    }\n\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(_ref4 => {\n      let [s, st] = _ref4;\n\n      if (!st) {\n        return;\n      }\n\n      return readCmdShim(s).then(target => {\n        target = resolve(dirname(to), target);\n\n        if (target.indexOf(resolve(path)) !== 0) {\n          return failEEXIST({\n            from,\n            to,\n            path\n          });\n        }\n      }, er => handleReadCmdShimError({\n        er,\n        from,\n        to\n      }));\n    }));\n  }).then(skip => skip !== SKIP && doShim(absFrom, to));\n};\n\nconst doShim = (absFrom, to) => cmdShim(absFrom, to).then(() => fixBin(absFrom));\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p);\n  }\n};\n\nmodule.exports = Object.assign(shimBin, {\n  resetSeen\n});","map":{"version":3,"names":["promisify","require","resolve","dirname","fs","lstat","throwNonEnoent","er","code","cmdShim","readCmdShim","fixBin","seen","Set","failEEXIST","path","to","from","Promise","reject","Object","assign","Error","dest","handleReadCmdShimError","SKIP","Symbol","shimBin","absFrom","force","shims","shim","has","add","all","map","f","catch","then","stats","stFrom","s","i","st","target","indexOf","skip","doShim","resetSeen","p","delete","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/bin-links/lib/shim-bin.js"],"sourcesContent":["const { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') {\n    throw er\n  }\n}\n\nconst cmdShim = require('cmd-shim')\nconst readCmdShim = require('read-cmd-shim')\n\nconst fixBin = require('./fix-bin.js')\n\n// even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\nconst seen = new Set()\n\nconst failEEXIST = ({ path, to, from }) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: to,\n    dest: from,\n    code: 'EEXIST',\n  }))\n\nconst handleReadCmdShimError = ({ er, from, to }) =>\n  er.code === 'ENOENT' ? null\n  : er.code === 'ENOTASHIM' ? failEEXIST({ from, to })\n  : Promise.reject(er)\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst shimBin = ({ path, to, from, absFrom, force }) => {\n  const shims = [\n    to,\n    to + '.cmd',\n    to + '.ps1',\n  ]\n\n  for (const shim of shims) {\n    if (seen.has(shim)) {\n      return true\n    }\n    seen.add(shim)\n  }\n\n  return Promise.all([\n    ...shims,\n    absFrom,\n  ].map(f => lstat(f).catch(throwNonEnoent))).then((stats) => {\n    const [, , , stFrom] = stats\n    if (!stFrom) {\n      return SKIP\n    }\n\n    if (force) {\n      return\n    }\n\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st) {\n        return\n      }\n      return readCmdShim(s)\n        .then(target => {\n          target = resolve(dirname(to), target)\n          if (target.indexOf(resolve(path)) !== 0) {\n            return failEEXIST({ from, to, path })\n          }\n        }, er => handleReadCmdShimError({ er, from, to }))\n    }))\n  })\n    .then(skip => skip !== SKIP && doShim(absFrom, to))\n}\n\nconst doShim = (absFrom, to) =>\n  cmdShim(absFrom, to).then(() => fixBin(absFrom))\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(shimBin, { resetSeen })\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}