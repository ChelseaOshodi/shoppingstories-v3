{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst path = require('path');\n\nconst getName = require('@npmcli/name-from-folder');\n\nconst minimatch = require('minimatch');\n\nconst rpj = require('read-package-json-fast');\n\nconst glob = require('glob');\n\nconst pGlob = promisify(glob);\n\nfunction appendNegatedPatterns(patterns) {\n  const results = [];\n\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/);\n\n    if (excl) {\n      pattern = pattern.slice(excl[0].length);\n    } // strip off any / from the start of the pattern.  /foo => foo\n\n\n    pattern = pattern.replace(/^\\/+/, ''); // an odd number of ! means a negated pattern.  !!foo ==> foo\n\n    const negate = excl && excl[0].length % 2 === 1;\n    results.push({\n      pattern,\n      negate\n    });\n  }\n\n  return results;\n}\n\nfunction getPatterns(workspaces) {\n  const workspacesDeclaration = Array.isArray(workspaces.packages) ? workspaces.packages : workspaces;\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG'\n    });\n  }\n\n  return appendNegatedPatterns(workspacesDeclaration);\n}\n\nfunction getPackageName(pkg, pathname) {\n  const {\n    name\n  } = pkg;\n  return name || getName(pathname);\n}\n\nfunction pkgPathmame(opts) {\n  return function () {\n    const cwd = opts.cwd ? opts.cwd : process.cwd();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return path.join.apply(null, [cwd, ...args]);\n  };\n} // make sure glob pattern only matches folders\n\n\nfunction getGlobPattern(pattern) {\n  pattern = pattern.replace(/\\\\/g, '/');\n  return pattern.endsWith('/') ? pattern : `${pattern}/`;\n}\n\nfunction getError(_ref) {\n  let {\n    Type = TypeError,\n    message,\n    code\n  } = _ref;\n  return Object.assign(new Type(message), {\n    code\n  });\n}\n\nfunction reverseResultMap(map) {\n  return new Map(Array.from(map, item => item.reverse()));\n}\n\nasync function mapWorkspaces() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG'\n    });\n  }\n\n  const {\n    workspaces = []\n  } = opts.pkg;\n  const patterns = getPatterns(workspaces);\n  const results = new Map();\n  const seen = new Map();\n\n  if (!patterns.length) {\n    return results;\n  }\n\n  const getGlobOpts = () => ({ ...opts,\n    ignore: [...(opts.ignore || []), ...['**/node_modules/**']]\n  });\n\n  const getPackagePathname = pkgPathmame(opts);\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts());\n\n    for (const match of matches) {\n      let pkg;\n      const packageJsonPathname = getPackagePathname(match, 'package.json');\n      const packagePathname = path.dirname(packageJsonPathname);\n\n      try {\n        pkg = await rpj(packageJsonPathname);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname);\n      let seenPackagePathnames = seen.get(name);\n\n      if (!seenPackagePathnames) {\n        seenPackagePathnames = new Set();\n        seen.set(name, seenPackagePathnames);\n      }\n\n      if (item.negate) {\n        seenPackagePathnames.delete(packagePathname);\n      } else {\n        seenPackagePathnames.add(packagePathname);\n      }\n    }\n  }\n\n  const errorMessageArray = ['must not have multiple workspaces with the same name'];\n\n  for (const [packageName, seenPackagePathnames] of seen) {\n    if (seenPackagePathnames.size === 0) {\n      continue;\n    }\n\n    if (seenPackagePathnames.size > 1) {\n      addDuplicateErrorMessages(errorMessageArray, packageName, seenPackagePathnames);\n    } else {\n      results.set(packageName, seenPackagePathnames.values().next().value);\n    }\n  }\n\n  if (errorMessageArray.length > 1) {\n    throw getError({\n      Type: Error,\n      message: errorMessageArray.join('\\n'),\n      code: 'EDUPLICATEWORKSPACE'\n    });\n  }\n\n  return results;\n}\n\nfunction addDuplicateErrorMessages(messageArray, packageName, packagePathnames) {\n  messageArray.push(`package '${packageName}' has conflicts in the following paths:`);\n\n  for (const packagePathname of packagePathnames) {\n    messageArray.push('    ' + packagePathname);\n  }\n}\n\nmapWorkspaces.virtual = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE'\n    });\n  }\n\n  const {\n    packages = {}\n  } = opts.lockfile;\n  const {\n    workspaces = []\n  } = packages[''] || {}; // uses a pathname-keyed map in order to negate the exact items\n\n  const results = new Map();\n  const patterns = getPatterns(workspaces);\n\n  if (!patterns.length) {\n    return results;\n  }\n\n  patterns.push({\n    pattern: '**/node_modules/**',\n    negate: true\n  });\n  const getPackagePathname = pkgPathmame(opts);\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue;\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey);\n        const name = getPackageName(packages[packageKey], packagePathname);\n\n        if (item.negate) {\n          results.delete(packagePathname);\n        } else {\n          results.set(packagePathname, name);\n        }\n      }\n    }\n  } // Invert pathname-keyed to a proper name-to-pathnames Map\n\n\n  return reverseResultMap(results);\n};\n\nmodule.exports = mapWorkspaces;","map":{"version":3,"names":["promisify","require","path","getName","minimatch","rpj","glob","pGlob","appendNegatedPatterns","patterns","results","pattern","excl","match","slice","length","replace","negate","push","getPatterns","workspaces","workspacesDeclaration","Array","isArray","packages","getError","message","code","getPackageName","pkg","pathname","name","pkgPathmame","opts","cwd","process","args","join","apply","getGlobPattern","endsWith","Type","TypeError","Object","assign","reverseResultMap","map","Map","from","item","reverse","mapWorkspaces","seen","getGlobOpts","ignore","getPackagePathname","matches","packageJsonPathname","packagePathname","dirname","err","seenPackagePathnames","get","Set","set","delete","add","errorMessageArray","packageName","size","addDuplicateErrorMessages","values","next","value","Error","messageArray","packagePathnames","virtual","lockfile","packageKey","keys","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/map-workspaces/lib/index.js"],"sourcesContent":["const { promisify } = require('util')\nconst path = require('path')\n\nconst getName = require('@npmcli/name-from-folder')\nconst minimatch = require('minimatch')\nconst rpj = require('read-package-json-fast')\nconst glob = require('glob')\nconst pGlob = promisify(glob)\n\nfunction appendNegatedPatterns (patterns) {\n  const results = []\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/)\n    if (excl) {\n      pattern = pattern.slice(excl[0].length)\n    }\n\n    // strip off any / from the start of the pattern.  /foo => foo\n    pattern = pattern.replace(/^\\/+/, '')\n\n    // an odd number of ! means a negated pattern.  !!foo ==> foo\n    const negate = excl && excl[0].length % 2 === 1\n    results.push({ pattern, negate })\n  }\n\n  return results\n}\n\nfunction getPatterns (workspaces) {\n  const workspacesDeclaration =\n    Array.isArray(workspaces.packages)\n      ? workspaces.packages\n      : workspaces\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG',\n    })\n  }\n\n  return appendNegatedPatterns(workspacesDeclaration)\n}\n\nfunction getPackageName (pkg, pathname) {\n  const { name } = pkg\n  return name || getName(pathname)\n}\n\nfunction pkgPathmame (opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd()\n    return path.join.apply(null, [cwd, ...args])\n  }\n}\n\n// make sure glob pattern only matches folders\nfunction getGlobPattern (pattern) {\n  pattern = pattern.replace(/\\\\/g, '/')\n  return pattern.endsWith('/')\n    ? pattern\n    : `${pattern}/`\n}\n\nfunction getError ({ Type = TypeError, message, code }) {\n  return Object.assign(new Type(message), { code })\n}\n\nfunction reverseResultMap (map) {\n  return new Map(Array.from(map, item => item.reverse()))\n}\n\nasync function mapWorkspaces (opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG',\n    })\n  }\n\n  const { workspaces = [] } = opts.pkg\n  const patterns = getPatterns(workspaces)\n  const results = new Map()\n  const seen = new Map()\n\n  if (!patterns.length) {\n    return results\n  }\n\n  const getGlobOpts = () => ({\n    ...opts,\n    ignore: [\n      ...opts.ignore || [],\n      ...['**/node_modules/**'],\n    ],\n  })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts())\n\n    for (const match of matches) {\n      let pkg\n      const packageJsonPathname = getPackagePathname(match, 'package.json')\n      const packagePathname = path.dirname(packageJsonPathname)\n\n      try {\n        pkg = await rpj(packageJsonPathname)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue\n        } else {\n          throw err\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname)\n\n      let seenPackagePathnames = seen.get(name)\n      if (!seenPackagePathnames) {\n        seenPackagePathnames = new Set()\n        seen.set(name, seenPackagePathnames)\n      }\n      if (item.negate) {\n        seenPackagePathnames.delete(packagePathname)\n      } else {\n        seenPackagePathnames.add(packagePathname)\n      }\n    }\n  }\n\n  const errorMessageArray = ['must not have multiple workspaces with the same name']\n  for (const [packageName, seenPackagePathnames] of seen) {\n    if (seenPackagePathnames.size === 0) {\n      continue\n    }\n    if (seenPackagePathnames.size > 1) {\n      addDuplicateErrorMessages(errorMessageArray, packageName, seenPackagePathnames)\n    } else {\n      results.set(packageName, seenPackagePathnames.values().next().value)\n    }\n  }\n\n  if (errorMessageArray.length > 1) {\n    throw getError({\n      Type: Error,\n      message: errorMessageArray.join('\\n'),\n      code: 'EDUPLICATEWORKSPACE',\n    })\n  }\n\n  return results\n}\n\nfunction addDuplicateErrorMessages (messageArray, packageName, packagePathnames) {\n  messageArray.push(\n    `package '${packageName}' has conflicts in the following paths:`\n  )\n\n  for (const packagePathname of packagePathnames) {\n    messageArray.push(\n      '    ' + packagePathname\n    )\n  }\n}\n\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE',\n    })\n  }\n\n  const { packages = {} } = opts.lockfile\n  const { workspaces = [] } = packages[''] || {}\n  // uses a pathname-keyed map in order to negate the exact items\n  const results = new Map()\n  const patterns = getPatterns(workspaces)\n  if (!patterns.length) {\n    return results\n  }\n  patterns.push({ pattern: '**/node_modules/**', negate: true })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey)\n        const name = getPackageName(packages[packageKey], packagePathname)\n\n        if (item.negate) {\n          results.delete(packagePathname)\n        } else {\n          results.set(packagePathname, name)\n        }\n      }\n    }\n  }\n\n  // Invert pathname-keyed to a proper name-to-pathnames Map\n  return reverseResultMap(results)\n}\n\nmodule.exports = mapWorkspaces\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}