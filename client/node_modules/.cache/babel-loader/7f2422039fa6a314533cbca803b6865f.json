{"ast":null,"code":"const makeSpawnArgs = require('./make-spawn-args.js');\n\nconst promiseSpawn = require('@npmcli/promise-spawn');\n\nconst packageEnvs = require('./package-envs.js');\n\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\n\nconst signalManager = require('./signal-manager.js');\n\nconst isServerPackage = require('./is-server-package.js'); // you wouldn't like me when I'm angry...\n\n\nconst bruce = (id, event, cmd, args) => {\n  let banner = id ? `\\n> ${id} ${event}\\n` : `\\n> ${event}\\n`;\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`;\n\n  if (args.length) {\n    banner += ` ${args.join(' ')}`;\n  }\n\n  banner += '\\n';\n  return banner;\n};\n\nconst runScriptPkg = async options => {\n  const {\n    event,\n    path,\n    scriptShell,\n    binPaths = false,\n    env = {},\n    stdio = 'pipe',\n    pkg,\n    args = [],\n    stdioString = false,\n    // note: only used when stdio:inherit\n    banner = true,\n    // how long to wait for a process.kill signal\n    // only exposed here so that we can make the test go a bit faster.\n    signalTimeout = 500\n  } = options;\n  const {\n    scripts = {},\n    gypfile\n  } = pkg;\n  let cmd = null;\n\n  if (options.cmd) {\n    cmd = options.cmd;\n  } else if (pkg.scripts && pkg.scripts[event]) {\n    cmd = pkg.scripts[event];\n  } else if ( // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n  event === 'install' && !scripts.install && !scripts.preinstall && gypfile !== false && (await isNodeGypPackage(path))) {\n    cmd = defaultGypInstallScript;\n  } else if (event === 'start' && (await isServerPackage(path))) {\n    cmd = 'node server.js';\n  }\n\n  if (!cmd) {\n    return {\n      code: 0,\n      signal: null\n    };\n  }\n\n  if (stdio === 'inherit' && banner !== false) {\n    // we're dumping to the parent's stdout, so print the banner\n    console.log(bruce(pkg._id, event, cmd, args));\n  }\n\n  const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n    event,\n    path,\n    scriptShell,\n    binPaths,\n    env: packageEnvs(env, pkg),\n    stdio,\n    cmd,\n    args,\n    stdioString\n  });\n  const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n    event,\n    script: cmd,\n    pkgid: pkg._id,\n    path\n  });\n\n  if (stdio === 'inherit') {\n    signalManager.add(p.process);\n  }\n\n  if (p.stdin) {\n    p.stdin.end();\n  }\n\n  return p.catch(er => {\n    const {\n      signal\n    } = er;\n\n    if (stdio === 'inherit' && signal) {\n      process.kill(process.pid, signal); // just in case we don't die, reject after 500ms\n      // this also keeps the node process open long enough to actually\n      // get the signal, rather than terminating gracefully.\n\n      return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout));\n    } else {\n      throw er;\n    }\n  });\n};\n\nmodule.exports = runScriptPkg;","map":{"version":3,"names":["makeSpawnArgs","require","promiseSpawn","packageEnvs","isNodeGypPackage","defaultGypInstallScript","signalManager","isServerPackage","bruce","id","event","cmd","args","banner","trim","replace","length","join","runScriptPkg","options","path","scriptShell","binPaths","env","stdio","pkg","stdioString","signalTimeout","scripts","gypfile","install","preinstall","code","signal","console","log","_id","spawnShell","spawnArgs","spawnOpts","p","script","pkgid","add","process","stdin","end","catch","er","kill","pid","Promise","res","rej","setTimeout","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/run-script/lib/run-script-pkg.js"],"sourcesContent":["const makeSpawnArgs = require('./make-spawn-args.js')\nconst promiseSpawn = require('@npmcli/promise-spawn')\nconst packageEnvs = require('./package-envs.js')\nconst { isNodeGypPackage, defaultGypInstallScript } = require('@npmcli/node-gyp')\nconst signalManager = require('./signal-manager.js')\nconst isServerPackage = require('./is-server-package.js')\n\n// you wouldn't like me when I'm angry...\nconst bruce = (id, event, cmd, args) => {\n  let banner = id\n    ? `\\n> ${id} ${event}\\n`\n    : `\\n> ${event}\\n`\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`\n  if (args.length) {\n    banner += ` ${args.join(' ')}`\n  }\n  banner += '\\n'\n  return banner\n}\n\nconst runScriptPkg = async options => {\n  const {\n    event,\n    path,\n    scriptShell,\n    binPaths = false,\n    env = {},\n    stdio = 'pipe',\n    pkg,\n    args = [],\n    stdioString = false,\n    // note: only used when stdio:inherit\n    banner = true,\n    // how long to wait for a process.kill signal\n    // only exposed here so that we can make the test go a bit faster.\n    signalTimeout = 500,\n  } = options\n\n  const { scripts = {}, gypfile } = pkg\n  let cmd = null\n  if (options.cmd) {\n    cmd = options.cmd\n  } else if (pkg.scripts && pkg.scripts[event]) {\n    cmd = pkg.scripts[event]\n  } else if (\n    // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' &&\n    !scripts.install &&\n    !scripts.preinstall &&\n    gypfile !== false &&\n    await isNodeGypPackage(path)\n  ) {\n    cmd = defaultGypInstallScript\n  } else if (event === 'start' && await isServerPackage(path)) {\n    cmd = 'node server.js'\n  }\n\n  if (!cmd) {\n    return { code: 0, signal: null }\n  }\n\n  if (stdio === 'inherit' && banner !== false) {\n    // we're dumping to the parent's stdout, so print the banner\n    console.log(bruce(pkg._id, event, cmd, args))\n  }\n\n  const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n    event,\n    path,\n    scriptShell,\n    binPaths,\n    env: packageEnvs(env, pkg),\n    stdio,\n    cmd,\n    args,\n    stdioString,\n  })\n\n  const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n    event,\n    script: cmd,\n    pkgid: pkg._id,\n    path,\n  })\n\n  if (stdio === 'inherit') {\n    signalManager.add(p.process)\n  }\n\n  if (p.stdin) {\n    p.stdin.end()\n  }\n\n  return p.catch(er => {\n    const { signal } = er\n    if (stdio === 'inherit' && signal) {\n      process.kill(process.pid, signal)\n      // just in case we don't die, reject after 500ms\n      // this also keeps the node process open long enough to actually\n      // get the signal, rather than terminating gracefully.\n      return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout))\n    } else {\n      throw er\n    }\n  })\n}\n\nmodule.exports = runScriptPkg\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}