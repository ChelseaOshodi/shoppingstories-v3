{"ast":null,"code":"// mixin implementing the reify method\nconst onExit = require('../signal-handling.js');\n\nconst pacote = require('pacote');\n\nconst AuditReport = require('../audit-report.js');\n\nconst {\n  subset,\n  intersects\n} = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst semver = require('semver');\n\nconst debug = require('../debug.js');\n\nconst walkUp = require('walk-up-path');\n\nconst log = require('proc-log');\n\nconst {\n  dirname,\n  resolve,\n  relative\n} = require('path');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst fs = require('fs');\n\nconst {\n  promisify\n} = require('util');\n\nconst lstat = promisify(fs.lstat);\nconst symlink = promisify(fs.symlink);\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst justMkdirp = require('mkdirp');\n\nconst moveFile = require('@npmcli/move-file');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst PackageJson = require('@npmcli/package-json');\n\nconst packageContents = require('@npmcli/installed-package-contents');\n\nconst runScript = require('@npmcli/run-script');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst _force = Symbol.for('force');\n\nconst treeCheck = require('../tree-check.js');\n\nconst relpath = require('../relpath.js');\n\nconst Diff = require('../diff.js');\n\nconst retirePath = require('../retire-path.js');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst optionalSet = require('../optional-set.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst {\n  saveTypeMap,\n  hasSubKey\n} = require('../add-rm-pkg-deps.js');\n\nconst _retiredPaths = Symbol('retiredPaths');\n\nconst _retiredUnchanged = Symbol('retiredUnchanged');\n\nconst _sparseTreeDirs = Symbol('sparseTreeDirs');\n\nconst _sparseTreeRoots = Symbol('sparseTreeRoots');\n\nconst _savePrefix = Symbol('savePrefix');\n\nconst _retireShallowNodes = Symbol.for('retireShallowNodes');\n\nconst _getBundlesByDepth = Symbol('getBundlesByDepth');\n\nconst _registryResolved = Symbol('registryResolved');\n\nconst _addNodeToTrashList = Symbol.for('addNodeToTrashList');\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _workspacesEnabled = Symbol.for('workspacesEnabled'); // shared by rebuild mixin\n\n\nconst _trashList = Symbol.for('trashList');\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _loadTrees = Symbol.for('loadTrees'); // shared symbols for swapping out when testing\n\n\nconst _diffTrees = Symbol.for('diffTrees');\n\nconst _createSparseTree = Symbol.for('createSparseTree');\n\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees');\n\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated');\n\nconst _bundleUnpacked = Symbol('bundleUnpacked');\n\nconst _bundleMissing = Symbol('bundleMissing');\n\nconst _reifyNode = Symbol.for('reifyNode');\n\nconst _extractOrLink = Symbol('extractOrLink');\n\nconst _updateAll = Symbol.for('updateAll');\n\nconst _updateNames = Symbol.for('updateNames'); // defined by rebuild mixin\n\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _symlink = Symbol('symlink');\n\nconst _warnDeprecated = Symbol('warnDeprecated');\n\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees');\n\nconst _submitQuickAudit = Symbol('submitQuickAudit');\n\nconst _awaitQuickAudit = Symbol('awaitQuickAudit');\n\nconst _unpackNewModules = Symbol.for('unpackNewModules');\n\nconst _moveContents = Symbol.for('moveContents');\n\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged');\n\nconst _build = Symbol.for('build');\n\nconst _removeTrash = Symbol.for('removeTrash');\n\nconst _renamePath = Symbol.for('renamePath');\n\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes');\n\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree');\n\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged');\n\nconst _saveIdealTree = Symbol.for('saveIdealTree');\n\nconst _saveLockFile = Symbol('saveLockFile');\n\nconst _copyIdealToActual = Symbol('copyIdealToActual');\n\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList');\n\nconst _packageLockOnly = Symbol('packageLockOnly');\n\nconst _dryRun = Symbol('dryRun');\n\nconst _validateNodeModules = Symbol('validateNodeModules');\n\nconst _nmValidated = Symbol('nmValidated');\n\nconst _validatePath = Symbol('validatePath');\n\nconst _reifyPackages = Symbol.for('reifyPackages');\n\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot');\n\nconst _omitDev = Symbol('omitDev');\n\nconst _omitOptional = Symbol('omitOptional');\n\nconst _omitPeer = Symbol('omitPeer');\n\nconst _global = Symbol.for('global');\n\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps'); // defined by Ideal mixin\n\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _formatPackageLock = Symbol.for('formatPackageLock');\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true\n    } = options;\n    this[_dryRun] = !!dryRun;\n    this[_packageLockOnly] = !!packageLockOnly;\n    this[_savePrefix] = savePrefix;\n    this[_formatPackageLock] = !!formatPackageLock;\n    this.diff = null;\n    this[_retiredPaths] = {};\n    this[_shrinkwrapInflated] = new Set();\n    this[_retiredUnchanged] = {};\n    this[_sparseTreeDirs] = new Set();\n    this[_sparseTreeRoots] = new Set();\n    this[_trashList] = new Set(); // the nodes we unpack to read their bundles\n\n    this[_bundleUnpacked] = new Set(); // child nodes we'd EXPECT to be included in a bundle, but aren't\n\n    this[_bundleMissing] = new Set();\n    this[_nmValidated] = new Set();\n  } // public method\n\n\n  async reify() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages');\n      er.code = 'ESHRINKWRAPGLOBAL';\n      throw er;\n    }\n\n    const omit = new Set(options.omit || []);\n    this[_omitDev] = omit.has('dev');\n    this[_omitOptional] = omit.has('optional');\n    this[_omitPeer] = omit.has('peer'); // start tracker block\n\n    this.addTracker('reify');\n    process.emit('time', 'reify');\n    await this[_validatePath]();\n    await this[_loadTrees](options);\n    await this[_diffTrees]();\n    await this[_reifyPackages]();\n    await this[_saveIdealTree](options);\n    await this[_copyIdealToActual]();\n    await this[_awaitQuickAudit]();\n    this.finishTracker('reify');\n    process.emit('timeEnd', 'reify');\n    return treeCheck(this.actualTree);\n  }\n\n  async [_validatePath]() {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return;\n    } // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n\n\n    await justMkdirp(resolve(this.path)); // do not allow the top-level node_modules to be a symlink\n\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'));\n  }\n\n  async [_reifyPackages]() {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return;\n    }\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]();\n    } // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n\n\n    let reifyTerminated = null;\n    const removeHandler = onExit(_ref => {\n      let {\n        signal\n      } = _ref;\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler();\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal\n      });\n      return false;\n    }); // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n\n    const steps = [[_rollbackRetireShallowNodes, [_retireShallowNodes]], [_rollbackCreateSparseTree, [_createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules]], [_rollbackMoveBackRetiredUnchanged, [_moveBackRetiredUnchanged, _build]]];\n\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]();\n\n          if (reifyTerminated) {\n            throw reifyTerminated;\n          }\n        } catch (er) {\n          await this[rollback](er);\n          /* istanbul ignore next - rollback throws, should never hit this */\n\n          throw er;\n        }\n      }\n    } // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n\n\n    await this[_removeTrash]();\n\n    if (reifyTerminated) {\n      throw reifyTerminated;\n    } // done modifying the file system, no need to keep listening for sigs\n\n\n    removeHandler();\n  } // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n\n\n  [_loadTrees](options) {\n    process.emit('time', 'reify:loadTrees');\n    const bitOpt = { ...options,\n      complete: this[_packageLockOnly] || this[_dryRun]\n    }; // if we're only writing a package lock, then it doesn't matter what's here\n\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true;\n        } // if we added it as an edgeOut, then we want it\n\n\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true;\n        } // if it's an explicit request, then we want it\n\n\n        const hasExplicit = [...this.explicitRequests].some(edge => edge.name === kid);\n\n        if (hasExplicit) {\n          return true;\n        } // ignore the rest of the global install folder\n\n\n        return false;\n      }\n    } : {\n      ignoreMissing: true\n    };\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)]).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    } // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n\n\n    return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n  }\n\n  [_diffTrees]() {\n    if (this[_packageLockOnly]) {\n      return;\n    }\n\n    process.emit('time', 'reify:diffTrees'); // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const includeWorkspaces = this[_workspacesEnabled];\n    const includeRootDeps = !this[_workspacesEnabled] || this[_includeWorkspaceRoot] && this[_workspaces].length > 0;\n    const filterNodes = [];\n\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target;\n      const actualTree = this.actualTree.target; // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n\n      for (const {\n        name\n      } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name);\n\n        if (ideal) {\n          filterNodes.push(ideal);\n        }\n\n        const actual = actualTree.children.get(name);\n\n        if (actual) {\n          filterNodes.push(actual);\n        }\n      }\n    } else {\n      if (includeWorkspaces) {\n        // add all ws nodes to filterNodes\n        for (const ws of this[_workspaces]) {\n          const ideal = this.idealTree.children.get(ws);\n\n          if (ideal) {\n            filterNodes.push(ideal);\n          }\n\n          const actual = this.actualTree.children.get(ws);\n\n          if (actual) {\n            filterNodes.push(actual);\n          }\n        }\n      }\n\n      if (includeRootDeps) {\n        // add all non-workspace nodes to filterNodes\n        for (const tree of [this.idealTree, this.actualTree]) {\n          for (const {\n            type,\n            to\n          } of tree.edgesOut.values()) {\n            if (type !== 'workspace' && to) {\n              filterNodes.push(to);\n            }\n          }\n        }\n      }\n    } // find all the nodes that need to change between the actual\n    // and ideal trees.\n\n\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree\n    }); // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees');\n  } // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n\n\n  [_addNodeToTrashList](node) {\n    let retire = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const paths = [node.path, ...node.binPaths];\n    const moves = this[_retiredPaths];\n    log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths);\n\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path);\n        moves[path] = retired;\n\n        this[_trashList].add(retired);\n      } else {\n        this[_trashList].add(path);\n      }\n    }\n  } // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n\n\n  [_retireShallowNodes]() {\n    process.emit('time', 'reify:retireShallow');\n    const moves = this[_retiredPaths] = {};\n\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true);\n      }\n    }\n\n    log.silly('reify', 'moves', moves);\n    const movePromises = Object.entries(moves).map(_ref2 => {\n      let [from, to] = _ref2;\n      return this[_renamePath](from, to);\n    });\n    return promiseAllRejectLate(movePromises).then(() => process.emit('timeEnd', 'reify:retireShallow'));\n  }\n\n  [_renamePath](from, to) {\n    let didMkdirp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return moveFile(from, to).catch(er => {\n      // Occasionally an expected bin file might not exist in the package,\n      // or a shim/symlink might have been moved aside.  If we've already\n      // handled the most common cause of ENOENT (dir doesn't exist yet),\n      // then just ignore any ENOENT.\n      if (er.code === 'ENOENT') {\n        return didMkdirp ? null : mkdirp(dirname(to)).then(() => this[_renamePath](from, to, true));\n      } else if (er.code === 'EEXIST') {\n        return rimraf(to).then(() => moveFile(from, to));\n      } else {\n        throw er;\n      }\n    });\n  }\n\n  [_rollbackRetireShallowNodes](er) {\n    process.emit('time', 'reify:rollback:retireShallow');\n    const moves = this[_retiredPaths];\n    const movePromises = Object.entries(moves).map(_ref3 => {\n      let [from, to] = _ref3;\n      return this[_renamePath](to, from);\n    });\n    return promiseAllRejectLate(movePromises) // ignore subsequent rollback errors\n    .catch(er => {}).then(() => process.emit('timeEnd', 'reify:rollback:retireShallow')).then(() => {\n      throw er;\n    });\n  } // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n\n\n  [_addOmitsToTrashList]() {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return;\n    }\n\n    process.emit('time', 'reify:trashOmits');\n\n    const filter = node => node.top.isProjectRoot && (node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev]);\n\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node);\n    }\n\n    process.emit('timeEnd', 'reify:trashOmits');\n  }\n\n  [_createSparseTree]() {\n    process.emit('time', 'reify:createSparse'); // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n\n    const leaves = this.diff.leaves.filter(diff => {\n      return (diff.action === 'ADD' || diff.action === 'CHANGE') && !this[_sparseTreeDirs].has(diff.ideal.path) && !diff.ideal.isLink;\n    }).map(diff => diff.ideal); // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n\n    const dirsChecked = new Set();\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break;\n        }\n\n        if (dirsChecked.has(d)) {\n          continue;\n        }\n\n        dirsChecked.add(d);\n        const st = await lstat(d).catch(er => null); // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n\n        /* istanbul ignore next - defense in depth */\n\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d);\n          this[_retiredPaths][d] = retired;\n\n          this[_trashList].add(retired);\n\n          await this[_renamePath](d, retired);\n        }\n      }\n\n      const made = await mkdirp(node.path);\n\n      this[_sparseTreeDirs].add(node.path);\n\n      this[_sparseTreeRoots].add(made);\n    })).then(() => process.emit('timeEnd', 'reify:createSparse'));\n  }\n\n  [_rollbackCreateSparseTree](er) {\n    process.emit('time', 'reify:rollback:createSparse'); // cut the roots of the sparse tree that were created, not the leaves\n\n    const roots = this[_sparseTreeRoots]; // also delete the moves that we retired, so that we can move them back\n\n    const failures = [];\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])];\n    const unlinks = targets.map(path => rimraf(path).catch(er => failures.push([path, er])));\n    return promiseAllRejectLate(unlinks).then(() => {\n      if (failures.length) {\n        log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:rollback:createSparse')).then(() => this[_rollbackRetireShallowNodes](er));\n  } // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n\n\n  [_loadShrinkwrapsAndUpdateTrees]() {\n    const seen = this[_shrinkwrapInflated];\n    const shrinkwraps = this.diff.leaves.filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));\n\n    if (!shrinkwraps.length) {\n      return;\n    }\n\n    process.emit('time', 'reify:loadShrinkwraps');\n    const Arborist = this.constructor;\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal;\n      seen.add(node);\n      return diff.action ? this[_reifyNode](node) : node;\n    })).then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({ ...this.options,\n      path: node.path\n    }).loadVirtual({\n      root: node\n    })))) // reload the diff and sparse tree because the ideal tree changed\n    .then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'));\n  } // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n\n\n  [_reifyNode](node) {\n    if (this[_trashList].has(node.path)) {\n      return node;\n    }\n\n    const timer = `reifyNode:${node.location}`;\n    process.emit('time', timer);\n    this.addTracker('reify', node.name, node.location);\n    const {\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const p = Promise.resolve().then(async () => {\n      // when we reify an optional node, check the engine and platform\n      // first. be sure to ignore the --force and --engine-strict flags,\n      // since we always want to skip any optional packages we can't install.\n      // these checks throwing will result in a rollback and removal\n      // of the mismatches\n      if (node.optional) {\n        checkEngine(node.package, npmVersion, nodeVersion, false);\n        checkPlatform(node.package, false);\n      }\n\n      await this[_checkBins](node);\n      await this[_extractOrLink](node);\n      await this[_warnDeprecated](node);\n    });\n    return this[_handleOptionalFailure](node, p).then(() => {\n      this.finishTracker('reify', node.name, node.location);\n      process.emit('timeEnd', timer);\n      return node;\n    });\n  } // do not allow node_modules to be a symlink\n\n\n  async [_validateNodeModules](nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return;\n    }\n\n    const st = await lstat(nm).catch(() => null);\n\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm);\n\n      return;\n    }\n\n    log.warn('reify', 'Removing non-directory', nm);\n    await rimraf(nm);\n  }\n\n  async [_extractOrLink](node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}` : node.packageName && node.version ? `${node.packageName}@${node.version}` : null; // no idea what this thing is.  remove it from the tree.\n\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' + 'please re-try this operation once it completes\\n' + 'so that the damage can be corrected, or perform\\n' + 'a fresh install with no lockfile if the problem persists.';\n      log.warn('reify', warning);\n      log.verbose('reify', 'unrecognized node in tree', node.path);\n      node.parent = null;\n      node.fsParent = null;\n\n      this[_addNodeToTrashList](node);\n\n      return;\n    }\n\n    const nm = resolve(node.parent.path, 'node_modules');\n    await this[_validateNodeModules](nm);\n\n    if (node.isLink) {\n      await rimraf(node.path);\n      await this[_symlink](node);\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null);\n\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node);\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path\n          });\n        }\n      });\n      await pacote.extract(res, node.path, { ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity\n      });\n    }\n  }\n\n  async [_symlink](node) {\n    const dir = dirname(node.path);\n    const target = node.realpath;\n    const rel = relative(dir, target);\n    await mkdirp(dir);\n    return symlink(rel, node.path, 'junction');\n  }\n\n  [_warnDeprecated](node) {\n    const {\n      _id,\n      deprecated\n    } = node.package;\n\n    if (deprecated) {\n      log.warn('deprecated', `${_id}: ${deprecated}`);\n    }\n  } // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n\n\n  [_handleOptionalFailure](node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node);\n\n      for (node of set) {\n        log.verbose('reify', 'failed optional dependency', node.path);\n\n        this[_addNodeToTrashList](node);\n      }\n    }) : p).then(() => node);\n  }\n\n  [_registryResolved](resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    // `resolved` must never be falsey.\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    const resolvedURL = new URL(resolved);\n\n    if (this.options.replaceRegistryHost === resolvedURL.hostname || this.options.replaceRegistryHost === 'always') {\n      // this.registry always has a trailing slash\n      resolved = `${this.registry.slice(0, -1)}${resolvedURL.pathname}${resolvedURL.searchParams}`;\n    }\n\n    return resolved;\n  } // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n\n\n  [_loadBundlesAndUpdateTrees]() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let bundlesByDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[_getBundlesByDepth]();\n\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles');\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth');\n\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth);\n\n        this[_diffTrees]();\n      }\n\n      process.emit('timeEnd', 'reify:loadBundles');\n      return;\n    } // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n\n\n    const set = (bundlesByDepth.get(depth) || []).filter(node => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path));\n\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth);\n    } // extract all the nodes with bundles\n\n\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node);\n\n      return this[_reifyNode](node);\n    })) // then load their unpacked children and move into the ideal tree\n    .then(nodes => promiseAllRejectLate(nodes.map(async node => {\n      const arb = new this.constructor({ ...this.options,\n        path: node.path\n      });\n      const notTransplanted = new Set(node.children.keys());\n      await arb.loadActual({\n        root: node,\n        // don't transplant any sparse folders we created\n        // loadActual will set node.package to {} for empty directories\n        // if by chance there are some empty folders in the node_modules\n        // tree for some other reason, then ok, ignore those too.\n        transplantFilter: node => {\n          if (node.package._id) {\n            // it's actually in the bundle if it gets transplanted\n            notTransplanted.delete(node.name);\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n\n      for (const name of notTransplanted) {\n        this[_bundleMissing].add(node.children.get(name));\n      }\n    }))) // move onto the next level of bundled items\n    .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));\n  }\n\n  [_getBundlesByDepth]() {\n    const bundlesByDepth = new Map();\n    let maxBundleDepth = -1;\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal;\n\n        if (!node) {\n          return;\n        }\n\n        if (node.isProjectRoot) {\n          return;\n        }\n\n        const {\n          bundleDependencies\n        } = node.package;\n\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth);\n\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node]);\n          } else {\n            bundlesByDepth.get(node.depth).push(node);\n          }\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth);\n    return bundlesByDepth;\n  } // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n\n\n  [_pruneBundledMetadeps](bundlesByDepth) {\n    const bundleShadowed = new Set(); // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n    // create the list of nodes shadowed by children of bundlers\n\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue;\n      }\n\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name);\n\n          if (!shadow) {\n            continue;\n          }\n\n          bundleShadowed.add(shadow);\n          shadow.extraneous = true;\n        }\n      }\n    } // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n\n\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to);\n          shadDep.to.extraneous = true;\n        }\n      }\n    }\n\n    let changed;\n\n    do {\n      changed = false;\n\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false;\n            bundleShadowed.delete(shadow);\n            changed = true;\n            break;\n          }\n        }\n      }\n    } while (changed);\n\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow);\n\n      shadow.root = null;\n    }\n  }\n\n  [_submitQuickAudit]() {\n    if (this.options.audit === false) {\n      return this.auditReport = null;\n    } // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n\n\n    process.emit('time', 'reify:audit');\n    const options = { ...this.options\n    };\n    const tree = this.idealTree; // if we're operating on a workspace, only audit the workspace deps\n\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces], this[_includeWorkspaceRoot]);\n    }\n\n    this.auditReport = AuditReport.load(tree, options).then(res => {\n      process.emit('timeEnd', 'reify:audit');\n      this.auditReport = res;\n    });\n  } // return the promise if we're waiting for it, or the replaced result\n\n\n  [_awaitQuickAudit]() {\n    return this.auditReport;\n  } // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n\n\n  [_unpackNewModules]() {\n    process.emit('time', 'reify:unpack');\n    const unpacks = [];\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return;\n        }\n\n        const node = diff.ideal;\n\n        const bd = this[_bundleUnpacked].has(node);\n\n        const sw = this[_shrinkwrapInflated].has(node);\n\n        const bundleMissing = this[_bundleMissing].has(node); // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n\n\n        const doUnpack = node && // can't unpack if removed!\n        // root node already exists\n        !node.isRoot && // already unpacked to read bundle\n        !bd && // already unpacked to read sw\n        !sw && ( // already unpacked by another dep's bundle\n        bundleMissing || !node.inDepBundle);\n\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node));\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    return promiseAllRejectLate(unpacks).then(() => process.emit('timeEnd', 'reify:unpack'));\n  } // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n\n\n  [_moveBackRetiredUnchanged]() {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire');\n    const moves = this[_retiredPaths];\n    this[_retiredUnchanged] = {};\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return;\n      }\n\n      const {\n        path: realFolder\n      } = diff.actual;\n      const retireFolder = moves[realFolder];\n      /* istanbul ignore next - should be impossible */\n\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired');\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action\n          });\n        }\n      });\n      this[_retiredUnchanged][retireFolder] = [];\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node));\n        } // will have been moved/unpacked along with bundler\n\n\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return;\n        }\n\n        this[_retiredUnchanged][retireFolder].push(node);\n\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel); // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n\n        const bd = node.package.bundleDependencies;\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path;\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath));\n      }));\n    })).then(() => process.emit('timeEnd', 'reify:unretire'));\n  } // move the contents from the fromPath to the node.path\n\n\n  [_moveContents](node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]])\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path);\n      const to = resolve(node.path, rel);\n      return this[_renamePath](path, to);\n    })));\n  }\n\n  [_rollbackMoveBackRetiredUnchanged](er) {\n    const moves = this[_retiredPaths]; // flip the mapping around to go back\n\n    const realFolders = new Map(Object.entries(moves).map(_ref4 => {\n      let [k, v] = _ref4;\n      return [v, k];\n    }));\n    const promises = Object.entries(this[_retiredUnchanged]).map(_ref5 => {\n      let [retireFolder, nodes] = _ref5;\n      return promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder);\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel);\n        return this[_moveContents]({ ...node,\n          path: fromPath\n        }, node.path);\n      }));\n    });\n    return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));\n  }\n\n  [_build]() {\n    process.emit('time', 'reify:build'); // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n\n    const nodes = [];\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal);\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE'\n    }); // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target; // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n\n      const linkedFromRoot = node.parent === tree || node.target.fsTop === tree;\n\n      if (node.isLink && linkedFromRoot) {\n        nodes.push(node);\n      }\n    }\n\n    return this.rebuild({\n      nodes,\n      handleOptionalFailure: true\n    }).then(() => process.emit('timeEnd', 'reify:build'));\n  } // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n\n\n  [_removeTrash]() {\n    process.emit('time', 'reify:trash');\n    const promises = [];\n    const failures = [];\n\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]));\n\n    for (const path of this[_trashList]) {\n      promises.push(rm(path));\n    }\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:trash'));\n  } // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n\n\n  async [_saveIdealTree](options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n    const save = !(options.save === false); // we check for updates in order to make sure we run save ideal tree\n    // even though save=false since we want `npm update` to be able to\n    // write to package-lock files by default\n\n    const hasUpdates = this[_updateAll] || this[_updateNames].length; // we're going to completely skip save ideal tree in case of a global or\n    // dry-run install and also if the save option is set to false, EXCEPT for\n    // update since the expected behavior for npm7+ is for update to\n    // NOT save to package.json, we make that exception since we still want\n    // saveIdealTree to be able to write the lockfile by default.\n\n    const saveIdealTree = !(!save && !hasUpdates || this[_global] || this[_dryRun]);\n\n    if (!saveIdealTree) {\n      return false;\n    }\n\n    process.emit('time', 'reify:save');\n    const updatedTrees = new Set();\n\n    const updateNodes = nodes => {\n      for (const {\n        name,\n        tree: addTree\n      } of nodes) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name);\n        const pkg = addTree.package;\n        const req = npa.resolve(name, edge.spec, addTree.realpath);\n        const {\n          rawSpec,\n          subSpec\n        } = req;\n        const spec = subSpec ? subSpec.rawSpec : rawSpec;\n        const child = edge.to; // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n\n        if (!child || !addTree.isTop) {\n          continue;\n        }\n\n        let newSpec; // True if the dependency is getting installed from a local file path\n        // In this case it is not possible to do the normal version comparisons\n        // as the new version will be a file path\n\n        const isLocalDep = req.type === 'directory' || req.type === 'file';\n\n        if (req.registry) {\n          const version = child.version;\n          const prefixRange = version ? this[_savePrefix] + version : '*'; // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n\n          const isRange = (subSpec || req).type === 'range';\n          let range = spec;\n\n          if (!isRange || spec === '*' || subset(prefixRange, spec, {\n            loose: true\n          })) {\n            range = prefixRange;\n          }\n\n          const pname = child.packageName;\n          const alias = name !== pname;\n          newSpec = alias ? `npm:${pname}@${range}` : range;\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted;\n          const opt = {\n            noCommittish: false\n          };\n\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`;\n          } else {\n            newSpec = h.shortcut(opt);\n          }\n        } else if (isLocalDep) {\n          // when finding workspace nodes, make sure that\n          // we save them using their version instead of\n          // using their relative path\n          if (edge.type === 'workspace') {\n            const {\n              version\n            } = edge.to.target;\n            const prefixRange = version ? this[_savePrefix] + version : '*';\n            newSpec = prefixRange;\n          } else {\n            // save the relative path in package.json\n            // Normally saveSpec is updated with the proper relative\n            // path already, but it's possible to specify a full absolute\n            // path initially, in which case we can end up with the wrong\n            // thing, so just get the ultimate fetchSpec and relativize it.\n            const p = req.fetchSpec.replace(/^file:/, '');\n            const rel = relpath(addTree.realpath, p).replace(/#/g, '%23');\n            newSpec = `file:${rel}`;\n          }\n        } else {\n          newSpec = req.saveSpec;\n        }\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType);\n          pkg[depType][name] = newSpec; // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name];\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec;\n          }\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec; // don't update peer or optional if we don't have to\n\n            if (hasSubKey(pkg, 'peerDependencies', name) && (isLocalDep || !intersects(newSpec, pkg.peerDependencies[name]))) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && (isLocalDep || !intersects(newSpec, pkg.optionalDependencies[name]))) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          }\n        }\n\n        updatedTrees.add(addTree);\n      }\n    }; // Returns true if any of the edges from this node has a semver\n    // range definition that is an exact match to the version installed\n    // e.g: should return true if for a given an installed version 1.0.0,\n    // range is either =1.0.0 or 1.0.0\n\n\n    const exactVersion = node => {\n      for (const edge of node.edgesIn) {\n        try {\n          if (semver.subset(edge.spec, node.version)) {\n            return false;\n          }\n        } catch {}\n      }\n\n      return true;\n    }; // helper that retrieves an array of nodes that were\n    // potentially updated during the reify process, in order\n    // to limit the number of nodes to check and update, only\n    // select nodes from the inventory that are direct deps\n    // of a given package.json (project root or a workspace)\n    // and in ase of using a list of `names`, restrict nodes\n    // to only names that are found in this list\n\n\n    const retrieveUpdatedNodes = names => {\n      const filterDirectDependencies = node => !node.isRoot && node.resolveParent && node.resolveParent.isRoot && (!names || names.includes(node.name)) && exactVersion(node); // skip update for exact ranges\n\n\n      const directDeps = this.idealTree.inventory.filter(filterDirectDependencies); // traverses the list of direct dependencies and collect all nodes\n      // to be updated, since any of them might have changed during reify\n\n      const nodes = [];\n\n      for (const node of directDeps) {\n        for (const edgeIn of node.edgesIn) {\n          nodes.push({\n            name: node.name,\n            tree: edgeIn.from.target\n          });\n        }\n      }\n\n      return nodes;\n    };\n\n    if (save) {\n      // when using update all alongside with save, we'll make\n      // sure to refresh every dependency of the root idealTree\n      if (this[_updateAll]) {\n        const nodes = retrieveUpdatedNodes();\n        updateNodes(nodes);\n      } else {\n        // resolvedAdd is the list of user add requests, but with names added\n        // to things like git repos and tarball file/urls.  However, if the\n        // user requested 'foo@', and we have a foo@file:../foo, then we should\n        // end up saving the spec we actually used, not whatever they gave us.\n        if (this[_resolvedAdd].length) {\n          updateNodes(this[_resolvedAdd]);\n        } // if updating given dependencies by name, restrict the list of\n        // nodes to check to only those currently in _updateNames\n\n\n        if (this[_updateNames].length) {\n          const nodes = retrieveUpdatedNodes(this[_updateNames]);\n          updateNodes(nodes);\n        } // grab any from explicitRequests that had deps removed\n\n\n        for (const {\n          from: tree\n        } of this.explicitRequests) {\n          updatedTrees.add(tree);\n        }\n      }\n    } // preserve indentation, if possible\n\n\n    const {\n      [Symbol.for('indent')]: indent\n    } = this.idealTree.package;\n    const format = indent === undefined ? '  ' : indent;\n    const saveOpt = {\n      format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]\n    };\n    const promises = [this[_saveLockFile](saveOpt)];\n\n    const updatePackageJson = async tree => {\n      const pkgJson = await PackageJson.load(tree.path).catch(() => new PackageJson(tree.path));\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {},\n        // bundleDependencies is not required by PackageJson like the other fields here\n        // PackageJson also doesn't omit an empty array for this field so defaulting this\n        // to an empty array would add that field to every package.json file.\n        bundleDependencies\n      } = tree.package;\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies,\n        bundleDependencies\n      });\n      await pkgJson.save();\n    };\n\n    if (save) {\n      for (const tree of updatedTrees) {\n        // refresh the edges so they have the correct specs\n        tree.package = tree.package;\n        promises.push(updatePackageJson(tree));\n      }\n    }\n\n    await Promise.all(promises);\n    process.emit('timeEnd', 'reify:save');\n    return true;\n  }\n\n  async [_saveLockFile](saveOpt) {\n    if (!this[_usePackageLock]) {\n      return;\n    }\n\n    const {\n      meta\n    } = this.idealTree;\n    return meta.save(saveOpt);\n  }\n\n  async [_copyIdealToActual]() {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path);\n      const node = this.idealTree.inventory.get(loc);\n\n      if (node && node.root === this.idealTree) {\n        node.parent = null;\n      }\n    } // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n\n\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set();\n      const {\n        filterSet\n      } = this.diff;\n      const seen = new Set();\n\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc); // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n\n        if (filterSet.has(ideal)) {\n          continue;\n        } // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n\n\n        const actual = this.actualTree.inventory.get(loc);\n\n        if (!actual) {\n          ideal.root = null;\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location);\n            continue;\n          }\n\n          const {\n            realpath,\n            isLink\n          } = actual;\n\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue;\n          } else {\n            reroot.add(actual);\n          }\n        }\n      } // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n\n\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue;\n        }\n\n        seen.add(loc); // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n\n        if (filterSet.has(actual)) {\n          continue;\n        }\n\n        reroot.add(actual);\n      } // go through the rerooted actual nodes, and move them over.\n\n\n      for (const actual of reroot) {\n        actual.root = this.idealTree;\n      } // prune out any tops that lack a linkIn, they are no longer relevant.\n\n\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null;\n        }\n      } // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n\n\n      calcDepFlags(this.idealTree);\n    } // save the ideal's meta as a hidden lockfile after we actualize it\n\n\n    this.idealTree.meta.filename = this.idealTree.realpath + '/node_modules/.package-lock.json';\n    this.idealTree.meta.hiddenLockfile = true;\n    this.actualTree = this.idealTree;\n    this.idealTree = null;\n\n    if (!this[_global]) {\n      await this.actualTree.meta.save();\n      const ignoreScripts = !!this.options.ignoreScripts; // if we aren't doing a dry run or ignoring scripts and we actually made changes to the dep\n      // tree, then run the dependencies scripts\n\n      if (!this[_dryRun] && !ignoreScripts && this.diff && this.diff.children.length) {\n        const {\n          path,\n          package: pkg\n        } = this.actualTree.target;\n        const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe';\n        const {\n          scripts = {}\n        } = pkg;\n\n        for (const event of ['predependencies', 'dependencies', 'postdependencies']) {\n          if (Object.prototype.hasOwnProperty.call(scripts, event)) {\n            const timer = `reify:run:${event}`;\n            process.emit('time', timer);\n            log.info('run', pkg._id, event, scripts[event]);\n            await runScript({\n              event,\n              path,\n              pkg,\n              stdioString: true,\n              stdio,\n              scriptShell: this.options.scriptShell\n            });\n            process.emit('timeEnd', timer);\n          }\n        }\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["onExit","require","pacote","AuditReport","subset","intersects","npa","semver","debug","walkUp","log","dirname","resolve","relative","depth","dfwalk","fs","promisify","lstat","symlink","mkdirp","justMkdirp","moveFile","rimraf","PackageJson","packageContents","runScript","checkEngine","checkPlatform","_force","Symbol","for","treeCheck","relpath","Diff","retirePath","promiseAllRejectLate","optionalSet","calcDepFlags","saveTypeMap","hasSubKey","_retiredPaths","_retiredUnchanged","_sparseTreeDirs","_sparseTreeRoots","_savePrefix","_retireShallowNodes","_getBundlesByDepth","_registryResolved","_addNodeToTrashList","_workspaces","_workspacesEnabled","_trashList","_handleOptionalFailure","_loadTrees","_diffTrees","_createSparseTree","_loadShrinkwrapsAndUpdateTrees","_shrinkwrapInflated","_bundleUnpacked","_bundleMissing","_reifyNode","_extractOrLink","_updateAll","_updateNames","_checkBins","_symlink","_warnDeprecated","_loadBundlesAndUpdateTrees","_submitQuickAudit","_awaitQuickAudit","_unpackNewModules","_moveContents","_moveBackRetiredUnchanged","_build","_removeTrash","_renamePath","_rollbackRetireShallowNodes","_rollbackCreateSparseTree","_rollbackMoveBackRetiredUnchanged","_saveIdealTree","_saveLockFile","_copyIdealToActual","_addOmitsToTrashList","_packageLockOnly","_dryRun","_validateNodeModules","_nmValidated","_validatePath","_reifyPackages","_includeWorkspaceRoot","_omitDev","_omitOptional","_omitPeer","_global","_pruneBundledMetadeps","_resolvedAdd","_usePackageLock","_formatPackageLock","module","exports","cls","Reifier","constructor","options","savePrefix","packageLockOnly","dryRun","formatPackageLock","diff","Set","reify","er","Error","code","omit","has","addTracker","process","emit","finishTracker","actualTree","path","reifyTerminated","removeHandler","signal","Object","assign","steps","rollback","actions","action","bitOpt","complete","buildIdealTree","then","actualOpt","ignoreMissing","global","filter","node","kid","explicitRequests","size","isProjectRoot","idealTree","edgesOut","hasExplicit","some","edge","name","Promise","all","loadActual","includeWorkspaces","includeRootDeps","length","filterNodes","target","ideal","children","get","push","actual","ws","tree","type","to","values","calculate","shrinkwrapInflated","retire","paths","binPaths","moves","silly","retired","add","movePromises","entries","map","from","didMkdirp","catch","top","peer","dev","optional","devOptional","inventory","leaves","isLink","dirsChecked","d","st","isDirectory","made","roots","failures","targets","keys","unlinks","warn","seen","shrinkwraps","hasShrinkwrap","Arborist","nodes","loadVirtual","root","timer","location","npmVersion","nodeVersion","p","package","nm","res","resolved","packageName","version","warning","verbose","parent","fsParent","e","extract","integrity","dir","realpath","rel","_id","deprecated","set","resolvedURL","URL","replaceRegistryHost","hostname","registry","slice","pathname","searchParams","bundlesByDepth","maxBundleDepth","arb","notTransplanted","transplantFilter","delete","Map","visit","bundleDependencies","Math","max","getChildren","bundleShadowed","bundles","Array","isArray","shadow","extraneous","shadDep","changed","edgesIn","audit","auditReport","filterSet","workspaceDependencySet","load","unpacks","bd","sw","bundleMissing","doUnpack","isRoot","inDepBundle","realFolder","retireFolder","unchanged","fromPath","packageJsonCache","realFolders","k","v","promises","leave","linkedFromRoot","fsTop","rebuild","handleOptionalFailure","rm","save","hasUpdates","saveIdealTree","updatedTrees","updateNodes","addTree","pkg","req","spec","rawSpec","subSpec","child","isTop","newSpec","isLocalDep","prefixRange","isRange","range","loose","pname","alias","hosted","h","opt","noCommittish","https","auth","shortcut","fetchSpec","replace","saveSpec","saveType","depType","optionalDependencies","dependencies","devDependencies","peerDependencies","exactVersion","retrieveUpdatedNodes","names","filterDirectDependencies","resolveParent","includes","directDeps","edgeIn","indent","format","undefined","saveOpt","updatePackageJson","pkgJson","update","meta","loc","reroot","linksIn","link","tops","filename","hiddenLockfile","ignoreScripts","stdio","foregroundScripts","scripts","event","prototype","hasOwnProperty","call","info","stdioString","scriptShell"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js"],"sourcesContent":["// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js')\nconst pacote = require('pacote')\nconst AuditReport = require('../audit-report.js')\nconst { subset, intersects } = require('semver')\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst debug = require('../debug.js')\nconst walkUp = require('walk-up-path')\nconst log = require('proc-log')\n\nconst { dirname, resolve, relative } = require('path')\nconst { depth: dfwalk } = require('treeverse')\nconst fs = require('fs')\nconst { promisify } = require('util')\nconst lstat = promisify(fs.lstat)\nconst symlink = promisify(fs.symlink)\nconst mkdirp = require('mkdirp-infer-owner')\nconst justMkdirp = require('mkdirp')\nconst moveFile = require('@npmcli/move-file')\nconst rimraf = promisify(require('rimraf'))\nconst PackageJson = require('@npmcli/package-json')\nconst packageContents = require('@npmcli/installed-package-contents')\nconst runScript = require('@npmcli/run-script')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\nconst _force = Symbol.for('force')\n\nconst treeCheck = require('../tree-check.js')\nconst relpath = require('../relpath.js')\nconst Diff = require('../diff.js')\nconst retirePath = require('../retire-path.js')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst optionalSet = require('../optional-set.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst { saveTypeMap, hasSubKey } = require('../add-rm-pkg-deps.js')\n\nconst _retiredPaths = Symbol('retiredPaths')\nconst _retiredUnchanged = Symbol('retiredUnchanged')\nconst _sparseTreeDirs = Symbol('sparseTreeDirs')\nconst _sparseTreeRoots = Symbol('sparseTreeRoots')\nconst _savePrefix = Symbol('savePrefix')\nconst _retireShallowNodes = Symbol.for('retireShallowNodes')\nconst _getBundlesByDepth = Symbol('getBundlesByDepth')\nconst _registryResolved = Symbol('registryResolved')\nconst _addNodeToTrashList = Symbol.for('addNodeToTrashList')\nconst _workspaces = Symbol.for('workspaces')\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList')\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _loadTrees = Symbol.for('loadTrees')\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees')\nconst _createSparseTree = Symbol.for('createSparseTree')\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees')\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated')\nconst _bundleUnpacked = Symbol('bundleUnpacked')\nconst _bundleMissing = Symbol('bundleMissing')\nconst _reifyNode = Symbol.for('reifyNode')\nconst _extractOrLink = Symbol('extractOrLink')\nconst _updateAll = Symbol.for('updateAll')\nconst _updateNames = Symbol.for('updateNames')\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins')\nconst _symlink = Symbol('symlink')\nconst _warnDeprecated = Symbol('warnDeprecated')\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees')\nconst _submitQuickAudit = Symbol('submitQuickAudit')\nconst _awaitQuickAudit = Symbol('awaitQuickAudit')\nconst _unpackNewModules = Symbol.for('unpackNewModules')\nconst _moveContents = Symbol.for('moveContents')\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged')\nconst _build = Symbol.for('build')\nconst _removeTrash = Symbol.for('removeTrash')\nconst _renamePath = Symbol.for('renamePath')\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes')\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree')\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged')\nconst _saveIdealTree = Symbol.for('saveIdealTree')\nconst _saveLockFile = Symbol('saveLockFile')\nconst _copyIdealToActual = Symbol('copyIdealToActual')\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList')\nconst _packageLockOnly = Symbol('packageLockOnly')\nconst _dryRun = Symbol('dryRun')\nconst _validateNodeModules = Symbol('validateNodeModules')\nconst _nmValidated = Symbol('nmValidated')\nconst _validatePath = Symbol('validatePath')\nconst _reifyPackages = Symbol.for('reifyPackages')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\n\nconst _omitDev = Symbol('omitDev')\nconst _omitOptional = Symbol('omitOptional')\nconst _omitPeer = Symbol('omitPeer')\n\nconst _global = Symbol.for('global')\n\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps')\n\n// defined by Ideal mixin\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _formatPackageLock = Symbol.for('formatPackageLock')\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true,\n    } = options\n\n    this[_dryRun] = !!dryRun\n    this[_packageLockOnly] = !!packageLockOnly\n    this[_savePrefix] = savePrefix\n    this[_formatPackageLock] = !!formatPackageLock\n\n    this.diff = null\n    this[_retiredPaths] = {}\n    this[_shrinkwrapInflated] = new Set()\n    this[_retiredUnchanged] = {}\n    this[_sparseTreeDirs] = new Set()\n    this[_sparseTreeRoots] = new Set()\n    this[_trashList] = new Set()\n    // the nodes we unpack to read their bundles\n    this[_bundleUnpacked] = new Set()\n    // child nodes we'd EXPECT to be included in a bundle, but aren't\n    this[_bundleMissing] = new Set()\n    this[_nmValidated] = new Set()\n  }\n\n  // public method\n  async reify (options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages')\n      er.code = 'ESHRINKWRAPGLOBAL'\n      throw er\n    }\n\n    const omit = new Set(options.omit || [])\n    this[_omitDev] = omit.has('dev')\n    this[_omitOptional] = omit.has('optional')\n    this[_omitPeer] = omit.has('peer')\n\n    // start tracker block\n    this.addTracker('reify')\n    process.emit('time', 'reify')\n    await this[_validatePath]()\n    await this[_loadTrees](options)\n    await this[_diffTrees]()\n    await this[_reifyPackages]()\n    await this[_saveIdealTree](options)\n    await this[_copyIdealToActual]()\n    await this[_awaitQuickAudit]()\n\n    this.finishTracker('reify')\n    process.emit('timeEnd', 'reify')\n    return treeCheck(this.actualTree)\n  }\n\n  async [_validatePath] () {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return\n    }\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path))\n\n    // do not allow the top-level node_modules to be a symlink\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'))\n  }\n\n  async [_reifyPackages] () {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return\n    }\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]()\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null\n    const removeHandler = onExit(({ signal }) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler()\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal,\n      })\n      return false\n    })\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [\n      [_rollbackRetireShallowNodes, [\n        _retireShallowNodes,\n      ]],\n      [_rollbackCreateSparseTree, [\n        _createSparseTree,\n        _addOmitsToTrashList,\n        _loadShrinkwrapsAndUpdateTrees,\n        _loadBundlesAndUpdateTrees,\n        _submitQuickAudit,\n        _unpackNewModules,\n      ]],\n      [_rollbackMoveBackRetiredUnchanged, [\n        _moveBackRetiredUnchanged,\n        _build,\n      ]],\n    ]\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]()\n          if (reifyTerminated) {\n            throw reifyTerminated\n          }\n        } catch (er) {\n          await this[rollback](er)\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]()\n    if (reifyTerminated) {\n      throw reifyTerminated\n    }\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler()\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees] (options) {\n    process.emit('time', 'reify:loadTrees')\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun],\n    }\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt)\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true\n        }\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true\n        }\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests]\n          .some(edge => edge.name === kid)\n        if (hasExplicit) {\n          return true\n        }\n\n        // ignore the rest of the global install folder\n        return false\n      },\n    } : { ignoreMissing: true }\n\n    if (!this[_global]) {\n      return Promise.all([\n        this.loadActual(actualOpt),\n        this.buildIdealTree(bitOpt),\n      ]).then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt)\n      .then(() => this.loadActual(actualOpt))\n      .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n  }\n\n  [_diffTrees] () {\n    if (this[_packageLockOnly]) {\n      return\n    }\n\n    process.emit('time', 'reify:diffTrees')\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const includeWorkspaces = this[_workspacesEnabled]\n    const includeRootDeps = !this[_workspacesEnabled]\n      || this[_includeWorkspaceRoot] && this[_workspaces].length > 0\n\n    const filterNodes = []\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target\n      const actualTree = this.actualTree.target\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const { name } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name)\n        if (ideal) {\n          filterNodes.push(ideal)\n        }\n        const actual = actualTree.children.get(name)\n        if (actual) {\n          filterNodes.push(actual)\n        }\n      }\n    } else {\n      if (includeWorkspaces) {\n        // add all ws nodes to filterNodes\n        for (const ws of this[_workspaces]) {\n          const ideal = this.idealTree.children.get(ws)\n          if (ideal) {\n            filterNodes.push(ideal)\n          }\n          const actual = this.actualTree.children.get(ws)\n          if (actual) {\n            filterNodes.push(actual)\n          }\n        }\n      }\n      if (includeRootDeps) {\n        // add all non-workspace nodes to filterNodes\n        for (const tree of [this.idealTree, this.actualTree]) {\n          for (const { type, to } of tree.edgesOut.values()) {\n            if (type !== 'workspace' && to) {\n              filterNodes.push(to)\n            }\n          }\n        }\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree,\n    })\n\n    // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees')\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList] (node, retire = false) {\n    const paths = [node.path, ...node.binPaths]\n    const moves = this[_retiredPaths]\n    log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths)\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path)\n        moves[path] = retired\n        this[_trashList].add(retired)\n      } else {\n        this[_trashList].add(path)\n      }\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes] () {\n    process.emit('time', 'reify:retireShallow')\n    const moves = this[_retiredPaths] = {}\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true)\n      }\n    }\n    log.silly('reify', 'moves', moves)\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](from, to))\n    return promiseAllRejectLate(movePromises)\n      .then(() => process.emit('timeEnd', 'reify:retireShallow'))\n  }\n\n  [_renamePath] (from, to, didMkdirp = false) {\n    return moveFile(from, to)\n      .catch(er => {\n        // Occasionally an expected bin file might not exist in the package,\n        // or a shim/symlink might have been moved aside.  If we've already\n        // handled the most common cause of ENOENT (dir doesn't exist yet),\n        // then just ignore any ENOENT.\n        if (er.code === 'ENOENT') {\n          return didMkdirp ? null : mkdirp(dirname(to)).then(() =>\n            this[_renamePath](from, to, true))\n        } else if (er.code === 'EEXIST') {\n          return rimraf(to).then(() => moveFile(from, to))\n        } else {\n          throw er\n        }\n      })\n  }\n\n  [_rollbackRetireShallowNodes] (er) {\n    process.emit('time', 'reify:rollback:retireShallow')\n    const moves = this[_retiredPaths]\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](to, from))\n    return promiseAllRejectLate(movePromises)\n      // ignore subsequent rollback errors\n      .catch(er => {})\n      .then(() => process.emit('timeEnd', 'reify:rollback:retireShallow'))\n      .then(() => {\n        throw er\n      })\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList] () {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return\n    }\n\n    process.emit('time', 'reify:trashOmits')\n\n    const filter = node =>\n      node.top.isProjectRoot &&\n        (\n          node.peer && this[_omitPeer] ||\n          node.dev && this[_omitDev] ||\n          node.optional && this[_omitOptional] ||\n          node.devOptional && this[_omitOptional] && this[_omitDev]\n        )\n\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node)\n    }\n\n    process.emit('timeEnd', 'reify:trashOmits')\n  }\n\n  [_createSparseTree] () {\n    process.emit('time', 'reify:createSparse')\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const leaves = this.diff.leaves\n      .filter(diff => {\n        return (diff.action === 'ADD' || diff.action === 'CHANGE') &&\n          !this[_sparseTreeDirs].has(diff.ideal.path) &&\n          !diff.ideal.isLink\n      })\n      .map(diff => diff.ideal)\n\n    // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n    const dirsChecked = new Set()\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break\n        }\n        if (dirsChecked.has(d)) {\n          continue\n        }\n        dirsChecked.add(d)\n        const st = await lstat(d).catch(er => null)\n        // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n        /* istanbul ignore next - defense in depth */\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d)\n          this[_retiredPaths][d] = retired\n          this[_trashList].add(retired)\n          await this[_renamePath](d, retired)\n        }\n      }\n      const made = await mkdirp(node.path)\n      this[_sparseTreeDirs].add(node.path)\n      this[_sparseTreeRoots].add(made)\n    }))\n      .then(() => process.emit('timeEnd', 'reify:createSparse'))\n  }\n\n  [_rollbackCreateSparseTree] (er) {\n    process.emit('time', 'reify:rollback:createSparse')\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots]\n    // also delete the moves that we retired, so that we can move them back\n    const failures = []\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])]\n    const unlinks = targets\n      .map(path => rimraf(path).catch(er => failures.push([path, er])))\n    return promiseAllRejectLate(unlinks)\n      .then(() => {\n        if (failures.length) {\n          log.warn('cleanup', 'Failed to remove some directories', failures)\n        }\n      })\n      .then(() => process.emit('timeEnd', 'reify:rollback:createSparse'))\n      .then(() => this[_rollbackRetireShallowNodes](er))\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees] () {\n    const seen = this[_shrinkwrapInflated]\n    const shrinkwraps = this.diff.leaves\n      .filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) &&\n        d.ideal.hasShrinkwrap && !seen.has(d.ideal) &&\n        !this[_trashList].has(d.ideal.path))\n\n    if (!shrinkwraps.length) {\n      return\n    }\n\n    process.emit('time', 'reify:loadShrinkwraps')\n\n    const Arborist = this.constructor\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal\n      seen.add(node)\n      return diff.action ? this[_reifyNode](node) : node\n    }))\n      .then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n        ...this.options,\n        path: node.path,\n      }).loadVirtual({ root: node }))))\n      // reload the diff and sparse tree because the ideal tree changed\n      .then(() => this[_diffTrees]())\n      .then(() => this[_createSparseTree]())\n      .then(() => this[_addOmitsToTrashList]())\n      .then(() => this[_loadShrinkwrapsAndUpdateTrees]())\n      .then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'))\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode] (node) {\n    if (this[_trashList].has(node.path)) {\n      return node\n    }\n\n    const timer = `reifyNode:${node.location}`\n    process.emit('time', timer)\n    this.addTracker('reify', node.name, node.location)\n\n    const { npmVersion, nodeVersion } = this.options\n    const p = Promise.resolve()\n      .then(async () => {\n        // when we reify an optional node, check the engine and platform\n        // first. be sure to ignore the --force and --engine-strict flags,\n        // since we always want to skip any optional packages we can't install.\n        // these checks throwing will result in a rollback and removal\n        // of the mismatches\n        if (node.optional) {\n          checkEngine(node.package, npmVersion, nodeVersion, false)\n          checkPlatform(node.package, false)\n        }\n        await this[_checkBins](node)\n        await this[_extractOrLink](node)\n        await this[_warnDeprecated](node)\n      })\n\n    return this[_handleOptionalFailure](node, p)\n      .then(() => {\n        this.finishTracker('reify', node.name, node.location)\n        process.emit('timeEnd', timer)\n        return node\n      })\n  }\n\n  // do not allow node_modules to be a symlink\n  async [_validateNodeModules] (nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return\n    }\n    const st = await lstat(nm).catch(() => null)\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm)\n      return\n    }\n    log.warn('reify', 'Removing non-directory', nm)\n    await rimraf(nm)\n  }\n\n  async [_extractOrLink] (node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}`\n      : node.packageName && node.version\n        ? `${node.packageName}@${node.version}`\n        : null\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' +\n        'please re-try this operation once it completes\\n' +\n        'so that the damage can be corrected, or perform\\n' +\n        'a fresh install with no lockfile if the problem persists.'\n      log.warn('reify', warning)\n      log.verbose('reify', 'unrecognized node in tree', node.path)\n      node.parent = null\n      node.fsParent = null\n      this[_addNodeToTrashList](node)\n      return\n    }\n\n    const nm = resolve(node.parent.path, 'node_modules')\n    await this[_validateNodeModules](nm)\n\n    if (node.isLink) {\n      await rimraf(node.path)\n      await this[_symlink](node)\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null)\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node)\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path,\n          })\n        }\n      })\n      await pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity,\n      })\n    }\n  }\n\n  async [_symlink] (node) {\n    const dir = dirname(node.path)\n    const target = node.realpath\n    const rel = relative(dir, target)\n    await mkdirp(dir)\n    return symlink(rel, node.path, 'junction')\n  }\n\n  [_warnDeprecated] (node) {\n    const { _id, deprecated } = node.package\n    if (deprecated) {\n      log.warn('deprecated', `${_id}: ${deprecated}`)\n    }\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure] (node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node)\n      for (node of set) {\n        log.verbose('reify', 'failed optional dependency', node.path)\n        this[_addNodeToTrashList](node)\n      }\n    }) : p).then(() => node)\n  }\n\n  [_registryResolved] (resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    // `resolved` must never be falsey.\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    const resolvedURL = new URL(resolved)\n    if ((this.options.replaceRegistryHost === resolvedURL.hostname)\n      || this.options.replaceRegistryHost === 'always') {\n      // this.registry always has a trailing slash\n      resolved = `${this.registry.slice(0, -1)}${resolvedURL.pathname}${resolvedURL.searchParams}`\n    }\n    return resolved\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees] (\n    depth = 0, bundlesByDepth = this[_getBundlesByDepth]()\n  ) {\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles')\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth')\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth)\n        this[_diffTrees]()\n      }\n      process.emit('timeEnd', 'reify:loadBundles')\n      return\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || [])\n      .filter(node => node.root === this.idealTree &&\n        node.target !== node.root &&\n        !this[_trashList].has(node.path))\n\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth)\n    }\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node)\n      return this[_reifyNode](node)\n    }))\n    // then load their unpacked children and move into the ideal tree\n      .then(nodes =>\n        promiseAllRejectLate(nodes.map(async node => {\n          const arb = new this.constructor({\n            ...this.options,\n            path: node.path,\n          })\n          const notTransplanted = new Set(node.children.keys())\n          await arb.loadActual({\n            root: node,\n            // don't transplant any sparse folders we created\n            // loadActual will set node.package to {} for empty directories\n            // if by chance there are some empty folders in the node_modules\n            // tree for some other reason, then ok, ignore those too.\n            transplantFilter: node => {\n              if (node.package._id) {\n                // it's actually in the bundle if it gets transplanted\n                notTransplanted.delete(node.name)\n                return true\n              } else {\n                return false\n              }\n            },\n          })\n          for (const name of notTransplanted) {\n            this[_bundleMissing].add(node.children.get(name))\n          }\n        })))\n    // move onto the next level of bundled items\n      .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))\n  }\n\n  [_getBundlesByDepth] () {\n    const bundlesByDepth = new Map()\n    let maxBundleDepth = -1\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal\n        if (!node) {\n          return\n        }\n        if (node.isProjectRoot) {\n          return\n        }\n\n        const { bundleDependencies } = node.package\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth)\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node])\n          } else {\n            bundlesByDepth.get(node.depth).push(node)\n          }\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth)\n    return bundlesByDepth\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps] (bundlesByDepth) {\n    const bundleShadowed = new Set()\n\n    // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue\n      }\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name)\n          if (!shadow) {\n            continue\n          }\n          bundleShadowed.add(shadow)\n          shadow.extraneous = true\n        }\n      }\n    }\n\n    // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to)\n          shadDep.to.extraneous = true\n        }\n      }\n    }\n\n    let changed\n    do {\n      changed = false\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false\n            bundleShadowed.delete(shadow)\n            changed = true\n            break\n          }\n        }\n      }\n    } while (changed)\n\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow)\n      shadow.root = null\n    }\n  }\n\n  [_submitQuickAudit] () {\n    if (this.options.audit === false) {\n      return this.auditReport = null\n    }\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit')\n    const options = { ...this.options }\n    const tree = this.idealTree\n\n    // if we're operating on a workspace, only audit the workspace deps\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(\n        tree,\n        this[_workspaces],\n        this[_includeWorkspaceRoot]\n      )\n    }\n\n    this.auditReport = AuditReport.load(tree, options)\n      .then(res => {\n        process.emit('timeEnd', 'reify:audit')\n        this.auditReport = res\n      })\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit] () {\n    return this.auditReport\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules] () {\n    process.emit('time', 'reify:unpack')\n    const unpacks = []\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return\n        }\n\n        const node = diff.ideal\n        const bd = this[_bundleUnpacked].has(node)\n        const sw = this[_shrinkwrapInflated].has(node)\n        const bundleMissing = this[_bundleMissing].has(node)\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node && // can't unpack if removed!\n          // root node already exists\n          !node.isRoot &&\n          // already unpacked to read bundle\n          !bd &&\n          // already unpacked to read sw\n          !sw &&\n          // already unpacked by another dep's bundle\n          (bundleMissing || !node.inDepBundle)\n\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node))\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n    return promiseAllRejectLate(unpacks)\n      .then(() => process.emit('timeEnd', 'reify:unpack'))\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged] () {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire')\n    const moves = this[_retiredPaths]\n    this[_retiredUnchanged] = {}\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return\n      }\n\n      const { path: realFolder } = diff.actual\n      const retireFolder = moves[realFolder]\n      /* istanbul ignore next - should be impossible */\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired')\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action,\n          })\n        }\n      })\n\n      this[_retiredUnchanged][retireFolder] = []\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node))\n        }\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return\n        }\n\n        this[_retiredUnchanged][retireFolder].push(node)\n\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath))\n      }))\n    }))\n      .then(() => process.emit('timeEnd', 'reify:unretire'))\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents] (node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]]),\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path)\n      const to = resolve(node.path, rel)\n      return this[_renamePath](path, to)\n    })))\n  }\n\n  [_rollbackMoveBackRetiredUnchanged] (er) {\n    const moves = this[_retiredPaths]\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]))\n    const promises = Object.entries(this[_retiredUnchanged])\n      .map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder)\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        return this[_moveContents]({ ...node, path: fromPath }, node.path)\n      })))\n    return promiseAllRejectLate(promises)\n      .then(() => this[_rollbackCreateSparseTree](er))\n  }\n\n  [_build] () {\n    process.emit('time', 'reify:build')\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = []\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal)\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE',\n    })\n\n    // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target\n\n      // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n      const linkedFromRoot = node.parent === tree || node.target.fsTop === tree\n      if (node.isLink && linkedFromRoot) {\n        nodes.push(node)\n      }\n    }\n\n    return this.rebuild({ nodes, handleOptionalFailure: true })\n      .then(() => process.emit('timeEnd', 'reify:build'))\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash] () {\n    process.emit('time', 'reify:trash')\n    const promises = []\n    const failures = []\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]))\n\n    for (const path of this[_trashList]) {\n      promises.push(rm(path))\n    }\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        log.warn('cleanup', 'Failed to remove some directories', failures)\n      }\n    })\n      .then(() => process.emit('timeEnd', 'reify:trash'))\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  async [_saveIdealTree] (options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    const save = !(options.save === false)\n\n    // we check for updates in order to make sure we run save ideal tree\n    // even though save=false since we want `npm update` to be able to\n    // write to package-lock files by default\n    const hasUpdates = this[_updateAll] || this[_updateNames].length\n\n    // we're going to completely skip save ideal tree in case of a global or\n    // dry-run install and also if the save option is set to false, EXCEPT for\n    // update since the expected behavior for npm7+ is for update to\n    // NOT save to package.json, we make that exception since we still want\n    // saveIdealTree to be able to write the lockfile by default.\n    const saveIdealTree = !(\n      (!save && !hasUpdates)\n      || this[_global]\n      || this[_dryRun]\n    )\n\n    if (!saveIdealTree) {\n      return false\n    }\n\n    process.emit('time', 'reify:save')\n\n    const updatedTrees = new Set()\n    const updateNodes = nodes => {\n      for (const { name, tree: addTree } of nodes) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name)\n        const pkg = addTree.package\n        const req = npa.resolve(name, edge.spec, addTree.realpath)\n        const { rawSpec, subSpec } = req\n\n        const spec = subSpec ? subSpec.rawSpec : rawSpec\n        const child = edge.to\n\n        // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n        if (!child || !addTree.isTop) {\n          continue\n        }\n\n        let newSpec\n        // True if the dependency is getting installed from a local file path\n        // In this case it is not possible to do the normal version comparisons\n        // as the new version will be a file path\n        const isLocalDep = req.type === 'directory' || req.type === 'file'\n        if (req.registry) {\n          const version = child.version\n          const prefixRange = version ? this[_savePrefix] + version : '*'\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range'\n\n          let range = spec\n          if (\n            !isRange ||\n            spec === '*' ||\n            subset(prefixRange, spec, { loose: true })\n          ) {\n            range = prefixRange\n          }\n\n          const pname = child.packageName\n          const alias = name !== pname\n          newSpec = alias ? `npm:${pname}@${range}` : range\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted\n          const opt = { noCommittish: false }\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`\n          } else {\n            newSpec = h.shortcut(opt)\n          }\n        } else if (isLocalDep) {\n          // when finding workspace nodes, make sure that\n          // we save them using their version instead of\n          // using their relative path\n          if (edge.type === 'workspace') {\n            const { version } = edge.to.target\n            const prefixRange = version ? this[_savePrefix] + version : '*'\n            newSpec = prefixRange\n          } else {\n            // save the relative path in package.json\n            // Normally saveSpec is updated with the proper relative\n            // path already, but it's possible to specify a full absolute\n            // path initially, in which case we can end up with the wrong\n            // thing, so just get the ultimate fetchSpec and relativize it.\n            const p = req.fetchSpec.replace(/^file:/, '')\n            const rel = relpath(addTree.realpath, p).replace(/#/g, '%23')\n            newSpec = `file:${rel}`\n          }\n        } else {\n          newSpec = req.saveSpec\n        }\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType)\n          pkg[depType][name] = newSpec\n          // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name]\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec\n          }\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec\n            // don't update peer or optional if we don't have to\n            if (hasSubKey(pkg, 'peerDependencies', name) && (isLocalDep || !intersects(newSpec, pkg.peerDependencies[name]))) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && (isLocalDep || !intersects(newSpec, pkg.optionalDependencies[name]))) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          }\n        }\n\n        updatedTrees.add(addTree)\n      }\n    }\n\n    // Returns true if any of the edges from this node has a semver\n    // range definition that is an exact match to the version installed\n    // e.g: should return true if for a given an installed version 1.0.0,\n    // range is either =1.0.0 or 1.0.0\n    const exactVersion = node => {\n      for (const edge of node.edgesIn) {\n        try {\n          if (semver.subset(edge.spec, node.version)) {\n            return false\n          }\n        } catch {}\n      }\n      return true\n    }\n\n    // helper that retrieves an array of nodes that were\n    // potentially updated during the reify process, in order\n    // to limit the number of nodes to check and update, only\n    // select nodes from the inventory that are direct deps\n    // of a given package.json (project root or a workspace)\n    // and in ase of using a list of `names`, restrict nodes\n    // to only names that are found in this list\n    const retrieveUpdatedNodes = names => {\n      const filterDirectDependencies = node =>\n        !node.isRoot && node.resolveParent && node.resolveParent.isRoot\n        && (!names || names.includes(node.name))\n        && exactVersion(node) // skip update for exact ranges\n\n      const directDeps = this.idealTree.inventory\n        .filter(filterDirectDependencies)\n\n      // traverses the list of direct dependencies and collect all nodes\n      // to be updated, since any of them might have changed during reify\n      const nodes = []\n      for (const node of directDeps) {\n        for (const edgeIn of node.edgesIn) {\n          nodes.push({\n            name: node.name,\n            tree: edgeIn.from.target,\n          })\n        }\n      }\n      return nodes\n    }\n\n    if (save) {\n      // when using update all alongside with save, we'll make\n      // sure to refresh every dependency of the root idealTree\n      if (this[_updateAll]) {\n        const nodes = retrieveUpdatedNodes()\n        updateNodes(nodes)\n      } else {\n        // resolvedAdd is the list of user add requests, but with names added\n        // to things like git repos and tarball file/urls.  However, if the\n        // user requested 'foo@', and we have a foo@file:../foo, then we should\n        // end up saving the spec we actually used, not whatever they gave us.\n        if (this[_resolvedAdd].length) {\n          updateNodes(this[_resolvedAdd])\n        }\n\n        // if updating given dependencies by name, restrict the list of\n        // nodes to check to only those currently in _updateNames\n        if (this[_updateNames].length) {\n          const nodes = retrieveUpdatedNodes(this[_updateNames])\n          updateNodes(nodes)\n        }\n\n        // grab any from explicitRequests that had deps removed\n        for (const { from: tree } of this.explicitRequests) {\n          updatedTrees.add(tree)\n        }\n      }\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent,\n    } = this.idealTree.package\n    const format = indent === undefined ? '  ' : indent\n\n    const saveOpt = {\n      format: (this[_formatPackageLock] && format) ? format\n      : this[_formatPackageLock],\n    }\n\n    const promises = [this[_saveLockFile](saveOpt)]\n\n    const updatePackageJson = async (tree) => {\n      const pkgJson = await PackageJson.load(tree.path)\n        .catch(() => new PackageJson(tree.path))\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {},\n        // bundleDependencies is not required by PackageJson like the other fields here\n        // PackageJson also doesn't omit an empty array for this field so defaulting this\n        // to an empty array would add that field to every package.json file.\n        bundleDependencies,\n      } = tree.package\n\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies,\n        bundleDependencies,\n      })\n      await pkgJson.save()\n    }\n\n    if (save) {\n      for (const tree of updatedTrees) {\n        // refresh the edges so they have the correct specs\n        tree.package = tree.package\n        promises.push(updatePackageJson(tree))\n      }\n    }\n\n    await Promise.all(promises)\n    process.emit('timeEnd', 'reify:save')\n    return true\n  }\n\n  async [_saveLockFile] (saveOpt) {\n    if (!this[_usePackageLock]) {\n      return\n    }\n\n    const { meta } = this.idealTree\n\n    return meta.save(saveOpt)\n  }\n\n  async [_copyIdealToActual] () {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path)\n      const node = this.idealTree.inventory.get(loc)\n      if (node && node.root === this.idealTree) {\n        node.parent = null\n      }\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set()\n\n      const { filterSet } = this.diff\n      const seen = new Set()\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc)\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal)) {\n          continue\n        }\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc)\n        if (!actual) {\n          ideal.root = null\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location)\n            continue\n          }\n          const { realpath, isLink } = actual\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue\n          } else {\n            reroot.add(actual)\n          }\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue\n        }\n        seen.add(loc)\n\n        // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n        if (filterSet.has(actual)) {\n          continue\n        }\n\n        reroot.add(actual)\n      }\n\n      // go through the rerooted actual nodes, and move them over.\n      for (const actual of reroot) {\n        actual.root = this.idealTree\n      }\n\n      // prune out any tops that lack a linkIn, they are no longer relevant.\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null\n        }\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree)\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename =\n      this.idealTree.realpath + '/node_modules/.package-lock.json'\n    this.idealTree.meta.hiddenLockfile = true\n\n    this.actualTree = this.idealTree\n    this.idealTree = null\n\n    if (!this[_global]) {\n      await this.actualTree.meta.save()\n      const ignoreScripts = !!this.options.ignoreScripts\n      // if we aren't doing a dry run or ignoring scripts and we actually made changes to the dep\n      // tree, then run the dependencies scripts\n      if (!this[_dryRun] && !ignoreScripts && this.diff && this.diff.children.length) {\n        const { path, package: pkg } = this.actualTree.target\n        const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n        const { scripts = {} } = pkg\n        for (const event of ['predependencies', 'dependencies', 'postdependencies']) {\n          if (Object.prototype.hasOwnProperty.call(scripts, event)) {\n            const timer = `reify:run:${event}`\n            process.emit('time', timer)\n            log.info('run', pkg._id, event, scripts[event])\n            await runScript({\n              event,\n              path,\n              pkg,\n              stdioString: true,\n              stdio,\n              scriptShell: this.options.scriptShell,\n            })\n            process.emit('timeEnd', timer)\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}