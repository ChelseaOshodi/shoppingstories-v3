{"ast":null,"code":"const {\n  resolve,\n  relative,\n  sep\n} = require('path');\n\nconst relativePrefix = `.${sep}`;\n\nconst {\n  EOL\n} = require('os');\n\nconst archy = require('archy');\n\nconst chalk = require('chalk');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst {\n  breadth\n} = require('treeverse');\n\nconst npa = require('npm-package-arg');\n\nconst completion = require('../utils/completion/installed-deep.js');\n\nconst _depth = Symbol('depth');\n\nconst _dedupe = Symbol('dedupe');\n\nconst _filteredBy = Symbol('filteredBy');\n\nconst _include = Symbol('include');\n\nconst _invalid = Symbol('invalid');\n\nconst _name = Symbol('name');\n\nconst _missing = Symbol('missing');\n\nconst _parent = Symbol('parent');\n\nconst _problems = Symbol('problems');\n\nconst _required = Symbol('required');\n\nconst _type = Symbol('type');\n\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nclass LS extends ArboristWorkspaceCmd {\n  static description = 'List installed packages';\n  static name = 'ls';\n  static usage = ['<package-spec>'];\n  static params = ['all', 'json', 'long', 'parseable', 'global', 'depth', 'omit', 'link', 'package-lock-only', 'unicode', ...super.params]; // TODO\n\n  /* istanbul ignore next */\n\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n\n  async exec(args) {\n    const all = this.npm.config.get('all');\n    const color = this.npm.color;\n    const depth = this.npm.config.get('depth');\n    const global = this.npm.global;\n    const json = this.npm.config.get('json');\n    const link = this.npm.config.get('link');\n    const long = this.npm.config.get('long');\n    const omit = this.npm.flatOptions.omit;\n    const parseable = this.npm.config.get('parseable');\n    const unicode = this.npm.config.get('unicode');\n    const packageLockOnly = this.npm.config.get('package-lock-only');\n    const workspacesEnabled = this.npm.flatOptions.workspacesEnabled;\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix;\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path\n    });\n    const tree = await this.initTree({\n      arb,\n      args,\n      packageLockOnly\n    }); // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n\n    let wsNodes;\n\n    if (this.workspaceNames && this.workspaceNames.length) {\n      wsNodes = arb.workspaceNodes(tree, this.workspaceNames);\n    }\n\n    const filterBySelectedWorkspaces = edge => {\n      if (!workspacesEnabled && edge.from.isProjectRoot && edge.to.isWorkspace) {\n        return false;\n      }\n\n      if (!wsNodes || !wsNodes.length) {\n        return true;\n      }\n\n      if (this.npm.flatOptions.includeWorkspaceRoot && edge.to && !edge.to.isWorkspace) {\n        return true;\n      }\n\n      if (edge.from.isProjectRoot) {\n        return edge.to && edge.to.isWorkspace && wsNodes.includes(edge.to.target);\n      }\n\n      return true;\n    };\n\n    const seenItems = new Set();\n    const seenNodes = new Map();\n    const problems = new Set(); // defines special handling of printed depth when filtering with args\n\n    const filterDefaultDepth = depth === null ? Infinity : depth;\n    const depthToPrint = all || args.length ? filterDefaultDepth : depth || 0; // add root node of tree to list of seenNodes\n\n    seenNodes.set(tree.path, tree); // tree traversal happens here, using treeverse.breadth\n\n    const result = await breadth({\n      tree,\n\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren(node, nodeResult) {\n        const seenPaths = new Set();\n        const workspace = node.isWorkspace;\n        const currentDepth = workspace ? 0 : node[_depth];\n        const shouldSkipChildren = !(node instanceof Arborist.Node) || currentDepth > depthToPrint;\n        return shouldSkipChildren ? [] : [...node.target.edgesOut.values()].filter(filterBySelectedWorkspaces).filter(currentDepth === 0 ? filterByEdgesTypes({\n          link,\n          omit\n        }) : () => true).map(mapEdgesToNodes({\n          seenPaths\n        })).concat(appendExtraneousChildren({\n          node,\n          seenPaths\n        })).sort(sortAlphabetically).map(augmentNodesWithMetadata({\n          args,\n          currentDepth,\n          nodeResult,\n          seenNodes\n        }));\n      },\n\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit(node) {\n        node[_problems] = getProblems(node, {\n          global\n        });\n        const item = json ? getJsonOutputItem(node, {\n          global,\n          long\n        }) : parseable ? null : getHumanOutputItem(node, {\n          args,\n          color,\n          global,\n          long\n        }); // loop through list of node problems to add them to global list\n\n        if (node[_include]) {\n          for (const problem of node[_problems]) {\n            problems.add(problem);\n          }\n        }\n\n        seenItems.add(item); // return a promise so we don't blow the stack\n\n        return Promise.resolve(item);\n      }\n\n    }); // handle the special case of a broken package.json in the root folder\n\n    const [rootError] = tree.errors.filter(e => e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'));\n    this.npm.output(json ? jsonOutput({\n      path,\n      problems,\n      result,\n      rootError,\n      seenItems\n    }) : parseable ? parseableOutput({\n      seenNodes,\n      global,\n      long\n    }) : humanOutput({\n      color,\n      result,\n      seenItems,\n      unicode\n    })); // if filtering items, should exit with error code on no results\n\n    if (result && !result[_include] && args.length) {\n      process.exitCode = 1;\n    }\n\n    if (rootError) {\n      throw Object.assign(new Error('Failed to parse root package.json'), {\n        code: 'EJSONPARSE'\n      });\n    }\n\n    const shouldThrow = problems.size && ![...problems].every(problem => problem.startsWith('extraneous:'));\n\n    if (shouldThrow) {\n      throw Object.assign(new Error([...problems].join(EOL)), {\n        code: 'ELSPROBLEMS'\n      });\n    }\n  }\n\n  async initTree(_ref) {\n    let {\n      arb,\n      args,\n      packageLockOnly\n    } = _ref;\n    const tree = await (packageLockOnly ? arb.loadVirtual() : arb.loadActual());\n    tree[_include] = args.length === 0;\n    tree[_depth] = 0;\n    return tree;\n  }\n\n}\n\nmodule.exports = LS;\n\nconst isGitNode = node => {\n  if (!node.resolved) {\n    return;\n  }\n\n  try {\n    const {\n      type\n    } = npa(node.resolved);\n    return type === 'git' || type === 'hosted';\n  } catch (err) {\n    return false;\n  }\n};\n\nconst isOptional = node => node[_type] === 'optional' || node[_type] === 'peerOptional';\n\nconst isExtraneous = (node, _ref2) => {\n  let {\n    global\n  } = _ref2;\n  return node.extraneous && !global;\n};\n\nconst getProblems = (node, _ref3) => {\n  let {\n    global\n  } = _ref3;\n  const problems = new Set();\n\n  if (node[_missing] && !isOptional(node)) {\n    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`);\n  }\n\n  if (node[_invalid]) {\n    problems.add(`invalid: ${node.pkgid} ${node.path}`);\n  }\n\n  if (isExtraneous(node, {\n    global\n  })) {\n    problems.add(`extraneous: ${node.pkgid} ${node.path}`);\n  }\n\n  return problems;\n}; // annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\n\n\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent];\n  item[_include] = node[_include]; // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent];\n\n    while (p) {\n      p[_include] = true;\n      p = p[_parent];\n    }\n  }\n\n  return item;\n};\n\nconst getHumanOutputItem = (node, _ref4) => {\n  let {\n    args,\n    color,\n    global,\n    long\n  } = _ref4;\n  const {\n    pkgid,\n    path\n  } = node;\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid;\n  let printable = node.isWorkspace ? workspacePkgId : pkgid; // special formatting for top-level package name\n\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length;\n\n    if (hasNoPackageJson || global) {\n      printable = path;\n    } else {\n      printable += `${long ? EOL : ' '}${path}`;\n    }\n  }\n\n  const highlightDepName = color && args.length && node[_filteredBy];\n  const missingColor = isOptional(node) ? chalk.yellow.bgBlack : chalk.red.bgBlack;\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`;\n  const targetLocation = node.root ? relative(node.root.realpath, node.realpath) : node.targetLocation;\n  const invalid = node[_invalid] ? `invalid: ${node[_invalid]}` : '';\n  const label = (node[_missing] ? (color ? missingColor(missingMsg) : missingMsg) + ' ' : '') + `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` + (node[_dedupe] ? ' ' + (color ? chalk.gray('deduped') : 'deduped') : '') + (invalid ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid) : '') + (isExtraneous(node, {\n    global\n  }) ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous') : '') + (isGitNode(node) ? ` (${node.resolved})` : '') + (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') + (long ? `${EOL}${node.package.description || ''}` : '');\n  return augmentItemWithIncludeMetadata(node, {\n    label,\n    nodes: []\n  });\n};\n\nconst getJsonOutputItem = (node, _ref5) => {\n  let {\n    global,\n    long\n  } = _ref5;\n  const item = {};\n\n  if (node.version) {\n    item.version = node.version;\n  }\n\n  if (node.resolved) {\n    item.resolved = node.resolved;\n  }\n\n  item[_name] = node.name; // special formatting for top-level package name\n\n  const hasPackageJson = node && node.package && Object.keys(node.package).length;\n\n  if (node.isRoot && hasPackageJson) {\n    item.name = node.package.name || node.name;\n  }\n\n  if (long && !node[_missing]) {\n    item.name = item[_name];\n    const {\n      dependencies,\n      ...packageInfo\n    } = node.package;\n    Object.assign(item, packageInfo);\n    item.extraneous = false;\n    item.path = node.path;\n    item._dependencies = { ...node.package.dependencies,\n      ...node.package.optionalDependencies\n    };\n    item.devDependencies = node.package.devDependencies || {};\n    item.peerDependencies = node.package.peerDependencies || {};\n  } // augment json output items with extra metadata\n\n\n  if (isExtraneous(node, {\n    global\n  })) {\n    item.extraneous = true;\n  }\n\n  if (node[_invalid]) {\n    item.invalid = node[_invalid];\n  }\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required];\n    item.missing = true;\n  }\n\n  if (node[_include] && node[_problems] && node[_problems].size) {\n    item.problems = [...node[_problems]];\n  }\n\n  return augmentItemWithIncludeMetadata(node, item);\n};\n\nconst filterByEdgesTypes = _ref6 => {\n  let {\n    link,\n    omit = []\n  } = _ref6;\n  return edge => {\n    for (const omitType of omit) {\n      if (edge[omitType]) {\n        return false;\n      }\n    }\n\n    return link ? edge.to && edge.to.isLink : true;\n  };\n};\n\nconst appendExtraneousChildren = _ref7 => {\n  let {\n    node,\n    seenPaths\n  } = _ref7;\n  return (// extraneous children are not represented\n    // in edges out, so here we add them to the list:\n    [...node.children.values()].filter(i => !seenPaths.has(i.path) && i.extraneous)\n  );\n};\n\nconst mapEdgesToNodes = _ref8 => {\n  let {\n    seenPaths\n  } = _ref8;\n  return edge => {\n    let node = edge.to; // if the edge is linking to a missing node, we go ahead\n    // and create a new obj that will represent the missing node\n\n    if (edge.missing || edge.optional && !node) {\n      const {\n        name,\n        spec\n      } = edge;\n      const pkgid = `${name}@${spec}`;\n      node = {\n        name,\n        pkgid,\n        [_missing]: edge.from.pkgid\n      };\n    } // keeps track of a set of seen paths to avoid the edge case in which a tree\n    // item would appear twice given that it's a children of an extraneous item,\n    // so it's marked extraneous but it will ALSO show up in edgesOuts of\n    // its parent so it ends up as two diff nodes if we don't track it\n\n\n    if (node.path) {\n      seenPaths.add(node.path);\n    }\n\n    node[_required] = edge.spec || '*';\n    node[_type] = edge.type;\n\n    if (edge.invalid) {\n      const spec = JSON.stringify(node[_required]);\n      const from = edge.from.location || 'the root project';\n      node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') + `${spec} from ${from}`;\n    }\n\n    return node;\n  };\n};\n\nconst filterByPositionalArgs = (args, _ref9) => {\n  let {\n    node\n  } = _ref9;\n  return args.length > 0 ? args.some(spec => node.satisfies && node.satisfies(spec)) : true;\n};\n\nconst augmentNodesWithMetadata = _ref10 => {\n  let {\n    args,\n    currentDepth,\n    nodeResult,\n    seenNodes\n  } = _ref10;\n  return node => {\n    // if the original edge was a deduped dep, treeverse will fail to\n    // revisit that node in tree traversal logic, so we make it so that\n    // we have a diff obj for deduped nodes:\n    if (seenNodes.has(node.path)) {\n      const {\n        realpath,\n        root\n      } = node;\n      const targetLocation = root ? relative(root.realpath, realpath) : node.targetLocation;\n      node = {\n        name: node.name,\n        version: node.version,\n        pkgid: node.pkgid,\n        package: node.package,\n        path: node.path,\n        isLink: node.isLink,\n        realpath: node.realpath,\n        targetLocation,\n        [_type]: node[_type],\n        [_invalid]: node[_invalid],\n        [_missing]: node[_missing],\n        // if it's missing, it's not deduped, it's just missing\n        [_dedupe]: !node[_missing]\n      };\n    } else {\n      // keeps track of already seen nodes in order to check for dedupes\n      seenNodes.set(node.path, node);\n    } // _parent is going to be a ref to a treeverse-visited node (returned from\n    // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n    // shortcut to place new nodes in their right place during tree traversal\n\n\n    node[_parent] = nodeResult; // _include is the property that allow us to filter based on position args\n    // e.g: `npm ls foo`, `npm ls simple-output@2`\n    // _filteredBy is used to apply extra color info to the item that\n    // was used in args in order to filter\n\n    node[_filteredBy] = node[_include] = filterByPositionalArgs(args, {\n      node: seenNodes.get(node.path)\n    }); // _depth keeps track of how many levels deep tree traversal currently is\n    // so that we can `npm ls --depth=1`\n\n    node[_depth] = currentDepth + 1;\n    return node;\n  };\n};\n\nconst sortAlphabetically = (_ref11, _ref12) => {\n  let {\n    pkgid: a\n  } = _ref11;\n  let {\n    pkgid: b\n  } = _ref12;\n  return localeCompare(a, b);\n};\n\nconst humanOutput = _ref13 => {\n  let {\n    color,\n    result,\n    seenItems,\n    unicode\n  } = _ref13;\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent]) {\n      item[_parent].nodes.push(item);\n    }\n  }\n\n  if (!result.nodes.length) {\n    result.nodes = ['(empty)'];\n  }\n\n  const archyOutput = archy(result, '', {\n    unicode\n  });\n  return color ? chalk.reset(archyOutput) : archyOutput;\n};\n\nconst jsonOutput = _ref14 => {\n  let {\n    path,\n    problems,\n    result,\n    rootError,\n    seenItems\n  } = _ref14;\n\n  if (problems.size) {\n    result.problems = [...problems];\n  }\n\n  if (rootError) {\n    result.problems = [...(result.problems || []), ...[`error in ${path}: Failed to parse root package.json`]];\n    result.invalid = true;\n  } // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n\n\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies) {\n        item[_parent].dependencies = {};\n      }\n\n      item[_parent].dependencies[item[_name]] = item;\n    }\n  }\n\n  return JSON.stringify(result, null, 2);\n};\n\nconst parseableOutput = _ref15 => {\n  let {\n    global,\n    long,\n    seenNodes\n  } = _ref15;\n  let out = '';\n\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path;\n\n      if (long) {\n        out += `:${node.pkgid}`;\n        out += node.path !== node.realpath ? `:${node.realpath}` : '';\n        out += isExtraneous(node, {\n          global\n        }) ? ':EXTRANEOUS' : '';\n        out += node[_invalid] ? ':INVALID' : '';\n      }\n\n      out += EOL;\n    }\n  }\n\n  return out.trim();\n};","map":{"version":3,"names":["resolve","relative","sep","require","relativePrefix","EOL","archy","chalk","Arborist","breadth","npa","completion","_depth","Symbol","_dedupe","_filteredBy","_include","_invalid","_name","_missing","_parent","_problems","_required","_type","ArboristWorkspaceCmd","localeCompare","LS","description","name","usage","params","opts","npm","exec","args","all","config","get","color","depth","global","json","link","long","omit","flatOptions","parseable","unicode","packageLockOnly","workspacesEnabled","path","globalDir","prefix","arb","legacyPeerDeps","tree","initTree","wsNodes","workspaceNames","length","workspaceNodes","filterBySelectedWorkspaces","edge","from","isProjectRoot","to","isWorkspace","includeWorkspaceRoot","includes","target","seenItems","Set","seenNodes","Map","problems","filterDefaultDepth","Infinity","depthToPrint","set","result","getChildren","node","nodeResult","seenPaths","workspace","currentDepth","shouldSkipChildren","Node","edgesOut","values","filter","filterByEdgesTypes","map","mapEdgesToNodes","concat","appendExtraneousChildren","sort","sortAlphabetically","augmentNodesWithMetadata","visit","getProblems","item","getJsonOutputItem","getHumanOutputItem","problem","add","Promise","rootError","errors","e","code","output","jsonOutput","parseableOutput","humanOutput","process","exitCode","Object","assign","Error","shouldThrow","size","every","startsWith","join","loadVirtual","loadActual","module","exports","isGitNode","resolved","type","err","isOptional","isExtraneous","extraneous","pkgid","augmentItemWithIncludeMetadata","p","workspacePkgId","green","printable","isRoot","hasNoPackageJson","keys","package","highlightDepName","missingColor","yellow","bgBlack","red","missingMsg","targetLocation","root","realpath","invalid","label","gray","isLink","nodes","version","hasPackageJson","dependencies","packageInfo","_dependencies","optionalDependencies","devDependencies","peerDependencies","required","missing","omitType","children","i","has","optional","spec","JSON","stringify","location","filterByPositionalArgs","some","satisfies","a","b","push","archyOutput","reset","out","trim"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/ls.js"],"sourcesContent":["const { resolve, relative, sep } = require('path')\nconst relativePrefix = `.${sep}`\nconst { EOL } = require('os')\n\nconst archy = require('archy')\nconst chalk = require('chalk')\nconst Arborist = require('@npmcli/arborist')\nconst { breadth } = require('treeverse')\nconst npa = require('npm-package-arg')\n\nconst completion = require('../utils/completion/installed-deep.js')\n\nconst _depth = Symbol('depth')\nconst _dedupe = Symbol('dedupe')\nconst _filteredBy = Symbol('filteredBy')\nconst _include = Symbol('include')\nconst _invalid = Symbol('invalid')\nconst _name = Symbol('name')\nconst _missing = Symbol('missing')\nconst _parent = Symbol('parent')\nconst _problems = Symbol('problems')\nconst _required = Symbol('required')\nconst _type = Symbol('type')\nconst ArboristWorkspaceCmd = require('../arborist-cmd.js')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nclass LS extends ArboristWorkspaceCmd {\n  static description = 'List installed packages'\n  static name = 'ls'\n  static usage = ['<package-spec>']\n  static params = [\n    'all',\n    'json',\n    'long',\n    'parseable',\n    'global',\n    'depth',\n    'omit',\n    'link',\n    'package-lock-only',\n    'unicode',\n    ...super.params,\n  ]\n\n  // TODO\n  /* istanbul ignore next */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  async exec (args) {\n    const all = this.npm.config.get('all')\n    const color = this.npm.color\n    const depth = this.npm.config.get('depth')\n    const global = this.npm.global\n    const json = this.npm.config.get('json')\n    const link = this.npm.config.get('link')\n    const long = this.npm.config.get('long')\n    const omit = this.npm.flatOptions.omit\n    const parseable = this.npm.config.get('parseable')\n    const unicode = this.npm.config.get('unicode')\n    const packageLockOnly = this.npm.config.get('package-lock-only')\n    const workspacesEnabled = this.npm.flatOptions.workspacesEnabled\n\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix\n\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path,\n    })\n    const tree = await this.initTree({ arb, args, packageLockOnly })\n\n    // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n    let wsNodes\n    if (this.workspaceNames && this.workspaceNames.length) {\n      wsNodes = arb.workspaceNodes(tree, this.workspaceNames)\n    }\n    const filterBySelectedWorkspaces = edge => {\n      if (!workspacesEnabled\n        && edge.from.isProjectRoot\n        && edge.to.isWorkspace\n      ) {\n        return false\n      }\n\n      if (!wsNodes || !wsNodes.length) {\n        return true\n      }\n\n      if (this.npm.flatOptions.includeWorkspaceRoot\n          && edge.to && !edge.to.isWorkspace) {\n        return true\n      }\n\n      if (edge.from.isProjectRoot) {\n        return (edge.to\n          && edge.to.isWorkspace\n          && wsNodes.includes(edge.to.target))\n      }\n\n      return true\n    }\n\n    const seenItems = new Set()\n    const seenNodes = new Map()\n    const problems = new Set()\n\n    // defines special handling of printed depth when filtering with args\n    const filterDefaultDepth = depth === null ? Infinity : depth\n    const depthToPrint = (all || args.length)\n      ? filterDefaultDepth\n      : (depth || 0)\n\n    // add root node of tree to list of seenNodes\n    seenNodes.set(tree.path, tree)\n\n    // tree traversal happens here, using treeverse.breadth\n    const result = await breadth({\n      tree,\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren (node, nodeResult) {\n        const seenPaths = new Set()\n        const workspace = node.isWorkspace\n        const currentDepth = workspace ? 0 : node[_depth]\n        const shouldSkipChildren =\n          !(node instanceof Arborist.Node) || (currentDepth > depthToPrint)\n        return (shouldSkipChildren)\n          ? []\n          : [...(node.target).edgesOut.values()]\n            .filter(filterBySelectedWorkspaces)\n            .filter(currentDepth === 0 ? filterByEdgesTypes({\n              link,\n              omit,\n            }) : () => true)\n            .map(mapEdgesToNodes({ seenPaths }))\n            .concat(appendExtraneousChildren({ node, seenPaths }))\n            .sort(sortAlphabetically)\n            .map(augmentNodesWithMetadata({\n              args,\n              currentDepth,\n              nodeResult,\n              seenNodes,\n            }))\n      },\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit (node) {\n        node[_problems] = getProblems(node, { global })\n\n        const item = json\n          ? getJsonOutputItem(node, { global, long })\n          : parseable\n            ? null\n            : getHumanOutputItem(node, { args, color, global, long })\n\n        // loop through list of node problems to add them to global list\n        if (node[_include]) {\n          for (const problem of node[_problems]) {\n            problems.add(problem)\n          }\n        }\n\n        seenItems.add(item)\n\n        // return a promise so we don't blow the stack\n        return Promise.resolve(item)\n      },\n    })\n\n    // handle the special case of a broken package.json in the root folder\n    const [rootError] = tree.errors.filter(e =>\n      e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'))\n\n    this.npm.output(\n      json\n        ? jsonOutput({ path, problems, result, rootError, seenItems })\n        : parseable\n          ? parseableOutput({ seenNodes, global, long })\n          : humanOutput({ color, result, seenItems, unicode })\n    )\n\n    // if filtering items, should exit with error code on no results\n    if (result && !result[_include] && args.length) {\n      process.exitCode = 1\n    }\n\n    if (rootError) {\n      throw Object.assign(\n        new Error('Failed to parse root package.json'),\n        { code: 'EJSONPARSE' }\n      )\n    }\n\n    const shouldThrow = problems.size &&\n      ![...problems].every(problem => problem.startsWith('extraneous:'))\n\n    if (shouldThrow) {\n      throw Object.assign(\n        new Error([...problems].join(EOL)),\n        { code: 'ELSPROBLEMS' }\n      )\n    }\n  }\n\n  async initTree ({ arb, args, packageLockOnly }) {\n    const tree = await (\n      packageLockOnly\n        ? arb.loadVirtual()\n        : arb.loadActual()\n    )\n\n    tree[_include] = args.length === 0\n    tree[_depth] = 0\n\n    return tree\n  }\n}\nmodule.exports = LS\n\nconst isGitNode = (node) => {\n  if (!node.resolved) {\n    return\n  }\n\n  try {\n    const { type } = npa(node.resolved)\n    return type === 'git' || type === 'hosted'\n  } catch (err) {\n    return false\n  }\n}\n\nconst isOptional = (node) =>\n  node[_type] === 'optional' || node[_type] === 'peerOptional'\n\nconst isExtraneous = (node, { global }) =>\n  node.extraneous && !global\n\nconst getProblems = (node, { global }) => {\n  const problems = new Set()\n\n  if (node[_missing] && !isOptional(node)) {\n    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`)\n  }\n\n  if (node[_invalid]) {\n    problems.add(`invalid: ${node.pkgid} ${node.path}`)\n  }\n\n  if (isExtraneous(node, { global })) {\n    problems.add(`extraneous: ${node.pkgid} ${node.path}`)\n  }\n\n  return problems\n}\n\n// annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent]\n  item[_include] = node[_include]\n\n  // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent]\n    while (p) {\n      p[_include] = true\n      p = p[_parent]\n    }\n  }\n\n  return item\n}\n\nconst getHumanOutputItem = (node, { args, color, global, long }) => {\n  const { pkgid, path } = node\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid\n  let printable = node.isWorkspace ? workspacePkgId : pkgid\n\n  // special formatting for top-level package name\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length\n    if (hasNoPackageJson || global) {\n      printable = path\n    } else {\n      printable += `${long ? EOL : ' '}${path}`\n    }\n  }\n\n  const highlightDepName =\n    color && args.length && node[_filteredBy]\n  const missingColor = isOptional(node)\n    ? chalk.yellow.bgBlack\n    : chalk.red.bgBlack\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`\n  const targetLocation = node.root\n    ? relative(node.root.realpath, node.realpath)\n    : node.targetLocation\n  const invalid = node[_invalid]\n    ? `invalid: ${node[_invalid]}`\n    : ''\n  const label =\n    (\n      node[_missing]\n        ? (color ? missingColor(missingMsg) : missingMsg) + ' '\n        : ''\n    ) +\n    `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` +\n    (\n      node[_dedupe]\n        ? ' ' + (color ? chalk.gray('deduped') : 'deduped')\n        : ''\n    ) +\n    (\n      invalid\n        ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid)\n        : ''\n    ) +\n    (\n      isExtraneous(node, { global })\n        ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous')\n        : ''\n    ) +\n    (isGitNode(node) ? ` (${node.resolved})` : '') +\n    (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') +\n    (long ? `${EOL}${node.package.description || ''}` : '')\n\n  return augmentItemWithIncludeMetadata(node, { label, nodes: [] })\n}\n\nconst getJsonOutputItem = (node, { global, long }) => {\n  const item = {}\n\n  if (node.version) {\n    item.version = node.version\n  }\n\n  if (node.resolved) {\n    item.resolved = node.resolved\n  }\n\n  item[_name] = node.name\n\n  // special formatting for top-level package name\n  const hasPackageJson =\n    node && node.package && Object.keys(node.package).length\n  if (node.isRoot && hasPackageJson) {\n    item.name = node.package.name || node.name\n  }\n\n  if (long && !node[_missing]) {\n    item.name = item[_name]\n    const { dependencies, ...packageInfo } = node.package\n    Object.assign(item, packageInfo)\n    item.extraneous = false\n    item.path = node.path\n    item._dependencies = {\n      ...node.package.dependencies,\n      ...node.package.optionalDependencies,\n    }\n    item.devDependencies = node.package.devDependencies || {}\n    item.peerDependencies = node.package.peerDependencies || {}\n  }\n\n  // augment json output items with extra metadata\n  if (isExtraneous(node, { global })) {\n    item.extraneous = true\n  }\n\n  if (node[_invalid]) {\n    item.invalid = node[_invalid]\n  }\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required]\n    item.missing = true\n  }\n  if (node[_include] && node[_problems] && node[_problems].size) {\n    item.problems = [...node[_problems]]\n  }\n\n  return augmentItemWithIncludeMetadata(node, item)\n}\n\nconst filterByEdgesTypes = ({ link, omit = [] }) => (edge) => {\n  for (const omitType of omit) {\n    if (edge[omitType]) {\n      return false\n    }\n  }\n  return link ? edge.to && edge.to.isLink : true\n}\n\nconst appendExtraneousChildren = ({ node, seenPaths }) =>\n  // extraneous children are not represented\n  // in edges out, so here we add them to the list:\n  [...node.children.values()]\n    .filter(i => !seenPaths.has(i.path) && i.extraneous)\n\nconst mapEdgesToNodes = ({ seenPaths }) => (edge) => {\n  let node = edge.to\n\n  // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n  if (edge.missing || (edge.optional && !node)) {\n    const { name, spec } = edge\n    const pkgid = `${name}@${spec}`\n    node = { name, pkgid, [_missing]: edge.from.pkgid }\n  }\n\n  // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n  if (node.path) {\n    seenPaths.add(node.path)\n  }\n\n  node[_required] = edge.spec || '*'\n  node[_type] = edge.type\n\n  if (edge.invalid) {\n    const spec = JSON.stringify(node[_required])\n    const from = edge.from.location || 'the root project'\n    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') +\n      (`${spec} from ${from}`)\n  }\n\n  return node\n}\n\nconst filterByPositionalArgs = (args, { node }) =>\n  args.length > 0 ? args.some(\n    (spec) => (node.satisfies && node.satisfies(spec))\n  ) : true\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes,\n}) => (node) => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    const { realpath, root } = node\n    const targetLocation = root ? relative(root.realpath, realpath)\n      : node.targetLocation\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      targetLocation,\n      [_type]: node[_type],\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      // if it's missing, it's not deduped, it's just missing\n      [_dedupe]: !node[_missing],\n    }\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node)\n  }\n\n  // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n  node[_parent] = nodeResult\n  // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n  node[_filteredBy] = node[_include] =\n    filterByPositionalArgs(args, { node: seenNodes.get(node.path) })\n  // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n  node[_depth] = currentDepth + 1\n\n  return node\n}\n\nconst sortAlphabetically = ({ pkgid: a }, { pkgid: b }) => localeCompare(a, b)\n\nconst humanOutput = ({ color, result, seenItems, unicode }) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent]) {\n      item[_parent].nodes.push(item)\n    }\n  }\n\n  if (!result.nodes.length) {\n    result.nodes = ['(empty)']\n  }\n\n  const archyOutput = archy(result, '', { unicode })\n  return color ? chalk.reset(archyOutput) : archyOutput\n}\n\nconst jsonOutput = ({ path, problems, result, rootError, seenItems }) => {\n  if (problems.size) {\n    result.problems = [...problems]\n  }\n\n  if (rootError) {\n    result.problems = [\n      ...(result.problems || []),\n      ...[`error in ${path}: Failed to parse root package.json`],\n    ]\n    result.invalid = true\n  }\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies) {\n        item[_parent].dependencies = {}\n      }\n\n      item[_parent].dependencies[item[_name]] = item\n    }\n  }\n\n  return JSON.stringify(result, null, 2)\n}\n\nconst parseableOutput = ({ global, long, seenNodes }) => {\n  let out = ''\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path\n      if (long) {\n        out += `:${node.pkgid}`\n        out += node.path !== node.realpath ? `:${node.realpath}` : ''\n        out += isExtraneous(node, { global }) ? ':EXTRANEOUS' : ''\n        out += node[_invalid] ? ':INVALID' : ''\n      }\n      out += EOL\n    }\n  }\n  return out.trim()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}