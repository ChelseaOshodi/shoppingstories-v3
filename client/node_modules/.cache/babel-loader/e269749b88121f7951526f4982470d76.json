{"ast":null,"code":"// add and remove dependency specs to/from pkg manifest\nconst log = require('proc-log');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst add = _ref => {\n  let {\n    pkg,\n    add,\n    saveBundle,\n    saveType\n  } = _ref;\n\n  for (const spec of add) {\n    addSingle({\n      pkg,\n      spec,\n      saveBundle,\n      saveType\n    });\n  }\n\n  return pkg;\n}; // Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\n\n\nconst saveTypeMap = new Map([['dev', 'devDependencies'], ['optional', 'optionalDependencies'], ['prod', 'dependencies'], ['peerOptional', 'peerDependencies'], ['peer', 'peerDependencies']]);\n\nconst addSingle = _ref2 => {\n  let {\n    pkg,\n    spec,\n    saveBundle,\n    saveType\n  } = _ref2;\n  const {\n    name,\n    rawSpec\n  } = spec; // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name);\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies');\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies');\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies');\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies');\n  } else {\n    // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies');\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies');\n  }\n\n  const depType = saveTypeMap.get(saveType);\n  pkg[depType] = pkg[depType] || {};\n\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*';\n  }\n\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {};\n    pkg.dependencies[name] = pkg.optionalDependencies[name];\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {};\n\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false;\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {};\n      pdm[name].optional = true;\n      pkg.peerDependenciesMeta = pdm;\n    } // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n\n\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name];\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || []);\n    bd.add(spec.name);\n    pkg.bundleDependencies = [...bd].sort(localeCompare);\n  }\n}; // Finds where the package is already in the spec and infers saveType from that\n\n\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (saveType === 'peerOptional' && (!hasSubKey(pkg, 'peerDependenciesMeta', name) || !pkg.peerDependenciesMeta[name].optional)) {\n        return 'peer';\n      }\n\n      return saveType;\n    }\n  }\n\n  return 'prod';\n};\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\n\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name);\n}; // Removes a subkey and warns about it if it's being replaced\n\n\nconst deleteSubKey = (pkg, depType, name, replacedBy) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`);\n    }\n\n    delete pkg[depType][name]; // clean up peerDepsMeta if we are removing something from peerDependencies\n\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name];\n\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta;\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType];\n    }\n  }\n};\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name);\n    }\n  }\n\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies.filter(name => !rm.includes(name));\n\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies;\n    }\n  }\n\n  return pkg;\n};\n\nmodule.exports = {\n  add,\n  rm,\n  saveTypeMap,\n  hasSubKey\n};","map":{"version":3,"names":["log","require","localeCompare","add","pkg","saveBundle","saveType","spec","addSingle","saveTypeMap","Map","name","rawSpec","inferSaveType","deleteSubKey","depType","get","undefined","dependencies","optionalDependencies","pdm","peerDependenciesMeta","optional","devDependencies","peerDependencies","bd","Set","bundleDependencies","sort","keys","hasSubKey","hasOwnProperty","Object","prototype","call","replacedBy","warn","length","rm","values","filter","includes","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"],"sourcesContent":["// add and remove dependency specs to/from pkg manifest\n\nconst log = require('proc-log')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst add = ({ pkg, add, saveBundle, saveType }) => {\n  for (const spec of add) {\n    addSingle({ pkg, spec, saveBundle, saveType })\n  }\n\n  return pkg\n}\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([\n  ['dev', 'devDependencies'],\n  ['optional', 'optionalDependencies'],\n  ['prod', 'dependencies'],\n  ['peerOptional', 'peerDependencies'],\n  ['peer', 'peerDependencies'],\n])\n\nconst addSingle = ({ pkg, spec, saveBundle, saveType }) => {\n  const { name, rawSpec } = spec\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name)\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies')\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies')\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies')\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies')\n  } else { // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies')\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies')\n  }\n\n  const depType = saveTypeMap.get(saveType)\n\n  pkg[depType] = pkg[depType] || {}\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*'\n  }\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {}\n    pkg.dependencies[name] = pkg.optionalDependencies[name]\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort(localeCompare)\n  }\n}\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (\n        saveType === 'peerOptional' &&\n        (!hasSubKey(pkg, 'peerDependenciesMeta', name) ||\n        !pkg.peerDependenciesMeta[name].optional)\n      ) {\n        return 'peer'\n      }\n      return saveType\n    }\n  }\n  return 'prod'\n}\n\nconst { hasOwnProperty } = Object.prototype\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name)\n}\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`)\n    }\n    delete pkg[depType][name]\n\n    // clean up peerDepsMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name]\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType]\n    }\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name)\n    }\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies\n    }\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm, saveTypeMap, hasSubKey }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}