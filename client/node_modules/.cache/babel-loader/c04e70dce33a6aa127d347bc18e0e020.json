{"ast":null,"code":"// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst rpj = require('read-package-json-fast');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst cacache = require('cacache');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst realpath = require('../../lib/realpath.js');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst treeCheck = require('../tree-check.js');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst fs = require('fs');\n\nconst lstat = promisify(fs.lstat);\nconst readlink = promisify(fs.readlink);\n\nconst {\n  depth\n} = require('treeverse');\n\nconst log = require('proc-log');\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT\n} = require('../can-place-dep.js');\n\nconst PlaceDep = require('../place-dep.js');\n\nconst debug = require('../debug.js');\n\nconst fromPath = require('../from-path.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst {\n  defaultLockfileVersion\n} = Shrinkwrap;\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js');\n\nconst optionalSet = require('../optional-set.js');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst relpath = require('../relpath.js'); // note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\n\n\nconst _complete = Symbol('complete');\n\nconst _depsSeen = Symbol('depsSeen');\n\nconst _depsQueue = Symbol('depsQueue');\n\nconst _currentDep = Symbol('currentDep');\n\nconst _updateAll = Symbol.for('updateAll');\n\nconst _mutateTree = Symbol('mutateTree');\n\nconst _flagsSuspect = Symbol.for('flagsSuspect');\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _prune = Symbol('prune');\n\nconst _preferDedupe = Symbol('preferDedupe');\n\nconst _legacyBundling = Symbol('legacyBundling');\n\nconst _parseSettings = Symbol('parseSettings');\n\nconst _initTree = Symbol('initTree');\n\nconst _applyUserRequests = Symbol('applyUserRequests');\n\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode');\n\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile');\n\nconst _buildDeps = Symbol('buildDeps');\n\nconst _buildDepStep = Symbol('buildDepStep');\n\nconst _nodeFromEdge = Symbol('nodeFromEdge');\n\nconst _nodeFromSpec = Symbol('nodeFromSpec');\n\nconst _fetchManifest = Symbol('fetchManifest');\n\nconst _problemEdges = Symbol('problemEdges');\n\nconst _manifests = Symbol('manifests');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _linkFromSpec = Symbol('linkFromSpec');\n\nconst _loadPeerSet = Symbol('loadPeerSet');\n\nconst _updateNames = Symbol.for('updateNames');\n\nconst _fixDepFlags = Symbol('fixDepFlags');\n\nconst _resolveLinks = Symbol('resolveLinks');\n\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage');\n\nconst _add = Symbol('add');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _queueNamedUpdates = Symbol('queueNamedUpdates');\n\nconst _queueVulnDependents = Symbol('queueVulnDependents');\n\nconst _avoidRange = Symbol('avoidRange');\n\nconst _shouldUpdateNode = Symbol('shouldUpdateNode');\n\nconst resetDepFlags = require('../reset-dep-flags.js');\n\nconst _loadFailures = Symbol('loadFailures');\n\nconst _pruneFailedOptional = Symbol('pruneFailedOptional');\n\nconst _linkNodes = Symbol('linkNodes');\n\nconst _follow = Symbol('follow');\n\nconst _globalStyle = Symbol('globalStyle');\n\nconst _globalRootNode = Symbol('globalRootNode');\n\nconst _isVulnerable = Symbol.for('isVulnerable');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _updateFilePath = Symbol('updateFilePath');\n\nconst _followSymlinkPath = Symbol('followSymlinkPath');\n\nconst _getRelpathSpec = Symbol('getRelpathSpec');\n\nconst _retrieveSpecName = Symbol('retrieveSpecName');\n\nconst _strictPeerDeps = Symbol('strictPeerDeps');\n\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform');\n\nconst _checkEngine = Symbol('checkEngine');\n\nconst _checkPlatform = Symbol('checkPlatform');\n\nconst _virtualRoots = Symbol('virtualRoots');\n\nconst _virtualRoot = Symbol('virtualRoot');\n\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot');\n\nconst _failPeerConflict = Symbol('failPeerConflict');\n\nconst _explainPeerConflict = Symbol('explainPeerConflict');\n\nconst _edgesOverridden = Symbol('edgesOverridden'); // exposed symbol for unit testing the placeDep method directly\n\n\nconst _peerSetSource = Symbol.for('peerSetSource'); // used by Reify mixin\n\n\nconst _force = Symbol.for('force');\n\nconst _explicitRequests = Symbol('explicitRequests');\n\nconst _global = Symbol.for('global');\n\nconst _idealTreePrune = Symbol.for('idealTreePrune');\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor(options) {\n    super(options); // normalize trailing slash\n\n    const registry = options.registry || 'https://registry.npmjs.org';\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/';\n    const {\n      follow = false,\n      force = false,\n      global = false,\n      globalStyle = false,\n      idealTree = null,\n      includeWorkspaceRoot = false,\n      installLinks = false,\n      legacyPeerDeps = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = []\n    } = options;\n    this[_workspaces] = workspaces || [];\n    this[_force] = !!force;\n    this[_strictPeerDeps] = !!strictPeerDeps;\n    this.idealTree = idealTree;\n    this.installLinks = installLinks;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this[_usePackageLock] = packageLock;\n    this[_global] = !!global;\n    this[_globalStyle] = this[_global] || globalStyle;\n    this[_follow] = !!follow;\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode');\n    }\n\n    this[_explicitRequests] = new Set();\n    this[_preferDedupe] = false;\n    this[_legacyBundling] = false;\n    this[_depsSeen] = new Set();\n    this[_depsQueue] = [];\n    this[_currentDep] = null;\n    this[_updateNames] = [];\n    this[_updateAll] = false;\n    this[_mutateTree] = false;\n    this[_loadFailures] = new Set();\n    this[_linkNodes] = new Set();\n    this[_manifests] = new Map();\n    this[_edgesOverridden] = new Set();\n    this[_resolvedAdd] = []; // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n\n    this[_peerSetSource] = new WeakMap();\n    this[_virtualRoots] = new Map();\n    this[_includeWorkspaceRoot] = includeWorkspaceRoot;\n  }\n\n  get explicitRequests() {\n    return new Set(this[_explicitRequests]);\n  } // public method\n\n\n  async buildIdealTree() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.idealTree) {\n      return this.idealTree;\n    } // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n\n    options = { ...this.options,\n      ...options\n    }; // an empty array or any falsey value is the same as null\n\n    if (!options.add || options.add.length === 0) {\n      options.add = null;\n    }\n\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null;\n    }\n\n    process.emit('time', 'idealTree');\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      throw new Error('global requires add, rm, or update option');\n    } // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n\n    this[_parseSettings](options); // start tracker block\n\n\n    this.addTracker('idealTree');\n\n    try {\n      await this[_initTree]();\n      await this[_inflateAncientLockfile]();\n      await this[_applyUserRequests](options);\n      await this[_buildDeps]();\n      await this[_fixDepFlags]();\n      await this[_pruneFailedOptional]();\n      await this[_checkEngineAndPlatform]();\n    } finally {\n      process.emit('timeEnd', 'idealTree');\n      this.finishTracker('idealTree');\n    }\n\n    return treeCheck(this.idealTree);\n  }\n\n  async [_checkEngineAndPlatform]() {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node);\n\n        this[_checkPlatform](node);\n      }\n    }\n  }\n\n  [_checkPlatform](node) {\n    checkPlatform(node.package, this[_force]);\n  }\n\n  [_checkEngine](node) {\n    const {\n      engineStrict,\n      npmVersion,\n      nodeVersion\n    } = this.options;\n\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force]);\n\n    if (engineStrict) {\n      c();\n    } else {\n      try {\n        c();\n      } catch (er) {\n        log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current\n        });\n      }\n    }\n  }\n\n  [_parseSettings](options) {\n    const update = options.update === true ? {\n      all: true\n    } : Array.isArray(options.update) ? {\n      names: options.update\n    } : options.update || {};\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = [];\n    }\n\n    this[_complete] = !!options.complete;\n    this[_preferDedupe] = !!options.preferDedupe;\n    this[_legacyBundling] = !!options.legacyBundling; // validates list of update names, they must\n    // be dep names only, no semver ranges are supported\n\n    for (const name of update.names) {\n      const spec = npa(name);\n      const validationError = new TypeError(`Update arguments must not contain package version specifiers\n\nTry using the package name instead, e.g:\n    npm update ${spec.name}`);\n      validationError.code = 'EUPDATEARGS';\n\n      if (spec.fetchSpec !== 'latest') {\n        throw validationError;\n      }\n    }\n\n    this[_updateNames] = update.names;\n    this[_updateAll] = update.all; // we prune by default unless explicitly set to boolean false\n\n    this[_prune] = options.prune !== false; // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n\n    this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);\n  } // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n\n\n  [_initTree]() {\n    process.emit('time', 'idealTree:init');\n    return (this[_global] ? this[_globalRootNode]() : rpj(this.path + '/package.json').then(pkg => this[_rootNodeFromPackage](pkg), er => {\n      if (er.code === 'EJSONPARSE') {\n        throw er;\n      }\n\n      return this[_rootNodeFromPackage]({});\n    })).then(root => this[_loadWorkspaces](root)) // ok to not have a virtual tree.  probably initial install.\n    // When updating all, we load the shrinkwrap, but don't bother\n    // to build out the full virtual tree from it, since we'll be\n    // reconstructing it anyway.\n    .then(root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options\n    }).then(meta => Object.assign(root, {\n      meta\n    })) : this.loadVirtual({\n      root\n    })) // if we don't have a lockfile to go from, then start with the\n    // actual tree, so we only make the minimum required changes.\n    // don't do this for global installs or updates, because in those\n    // cases we don't use a lockfile anyway.\n    // Load on a new Arborist object, so the Nodes aren't the same,\n    // or else it'll get super confusing when we change them!\n    .then(async root => {\n      if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk || this[_global] && this[_updateNames].length) {\n        await new this.constructor(this.options).loadActual({\n          root\n        });\n        const tree = root.target; // even though we didn't load it from a package-lock.json FILE,\n        // we still loaded it \"from disk\", meaning we have to reset\n        // dep flags before assuming that any mutations were reflected.\n\n        if (tree.children.size) {\n          root.meta.loadedFromDisk = true; // set these so that we don't try to ancient lockfile reload it\n\n          root.meta.originalLockfileVersion = defaultLockfileVersion;\n          root.meta.lockfileVersion = defaultLockfileVersion;\n        }\n      }\n\n      root.meta.inferFormattingOptions(root.package);\n      return root;\n    }).then(tree => {\n      // search the virtual tree for invalid edges, if any are found add their source to\n      // the depsQueue so that we'll fix it later\n      depth({\n        tree,\n        getChildren: node => [...node.edgesOut.values()].map(edge => edge.to),\n        filter: node => node,\n        visit: node => {\n          for (const edge of node.edgesOut.values()) {\n            if (!edge.valid) {\n              this[_depsQueue].push(node);\n\n              break; // no need to continue the loop after the first hit\n            }\n          }\n        }\n      }); // null the virtual tree, because we're about to hack away at it\n      // if you want another one, load another copy.\n\n      this.idealTree = tree;\n      this.virtualTree = null;\n      process.emit('timeEnd', 'idealTree:init');\n    });\n  }\n\n  async [_globalRootNode]() {\n    const root = await this[_rootNodeFromPackage]({\n      dependencies: {}\n    }); // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n\n    const meta = new Shrinkwrap({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options\n    });\n    meta.reset();\n    root.meta = meta;\n    return root;\n  }\n\n  async [_rootNodeFromPackage](pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n    const Cls = real === this.path ? Node : Link;\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      loadOverrides: true\n    });\n\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        installLinks: this.installLinks,\n        legacyPeerDeps: this.legacyPeerDeps,\n        root\n      });\n    }\n\n    return root;\n  } // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n\n\n  async [_applyUserRequests](options) {\n    process.emit('time', 'idealTree:userRequests');\n    const tree = this.idealTree.target;\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options);\n    } else {\n      const nodes = this.workspaceNodes(tree, this[_workspaces]);\n\n      if (this[_includeWorkspaceRoot]) {\n        nodes.push(tree);\n      }\n\n      const appliedRequests = nodes.map(node => this[_applyUserRequestsToNode](node, options));\n      await Promise.all(appliedRequests);\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests');\n  }\n\n  async [_applyUserRequestsToNode](tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]();\n    } // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n\n\n    const globalExplicitUpdateNames = [];\n\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules');\n\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {};\n\n        const updateName = this[_updateNames].includes(name);\n\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name);\n          }\n\n          const dir = resolve(nm, name);\n          const st = await lstat(dir).catch(\n          /* istanbul ignore next */\n          er => null);\n\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir);\n            const real = resolve(dirname(dir), target).replace(/#/g, '%23');\n            tree.package.dependencies[name] = `file:${real}`;\n          } else {\n            tree.package.dependencies[name] = '*';\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options);\n    }\n\n    const {\n      add,\n      rm\n    } = options;\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm);\n\n      for (const name of rm) {\n        this[_explicitRequests].add({\n          from: tree,\n          name,\n          action: 'DELETE'\n        });\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options);\n    } // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n\n\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package;\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name));\n      }\n    }\n\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name));\n    }\n\n    this[_depsQueue].push(tree);\n  } // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n\n\n  [_add](tree, _ref) {\n    let {\n      add,\n      saveType = null,\n      saveBundle = false\n    } = _ref;\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec)).then(spec => this[_updateFilePath](spec)).then(spec => this[_followSymlinkPath](spec));\n      spec.tree = tree;\n      return spec;\n    })).then(add => {\n      this[_resolvedAdd].push(...add); // now add is a list of spec objects with names.\n      // find a home for each of them!\n\n\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path\n      });\n    });\n  }\n\n  async [_retrieveSpecName](spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag';\n\n    if (spec.name && !isTag) {\n      return spec;\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options\n    }); // if it's a tag type, then we need to run it down to an actual version\n\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`);\n    }\n\n    spec.name = mani.name;\n    return spec;\n  }\n\n  async [_updateFilePath](spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec);\n    }\n\n    return spec;\n  }\n\n  async [_followSymlinkPath](spec) {\n    if (spec.type === 'directory') {\n      const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]) // TODO: create synthetic test case to simulate realpath failure\n      .catch(\n      /* istanbul ignore next */\n      () => null);\n      return this[_getRelpathSpec](spec, real);\n    }\n\n    return spec;\n  }\n\n  [_getRelpathSpec](spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const {\n        name\n      } = spec;\n      const tree = this.idealTree.target;\n      spec = npa(`file:${relpath(tree.path, filepath).replace(/#/g, '%23')}`, tree.path);\n      spec.name = name;\n    }\n\n    return spec;\n  } // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n\n\n  async [_queueVulnDependents](options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler(); // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n\n        if (bundler) {\n          log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\\nis a bundled dependency of\\n${bundler.name}@${bundler.version} at ${bundler.location}\\n` + 'It cannot be fixed automatically.\\n' + `Check for updates to the ${bundler.name} package.`);\n          continue;\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n          this[_depsQueue].push(edge.from);\n        }\n      }\n    } // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n\n\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || [];\n      options.rm = options.rm || [];\n      const nodesTouched = new Set();\n\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable\n        } = topVuln;\n\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            log.warn('audit', 'Manual fix required in linked project ' + `at ./${node.location} for ${name}@${simpleRange}.\\n` + `'cd ./${node.location}' and run 'npm audit' for details.`);\n            continue;\n          }\n\n          if (!fixAvailable) {\n            log.warn('audit', `No fix available for ${name}@${simpleRange}`);\n            continue;\n          }\n\n          const {\n            isSemVerMajor,\n            version\n          } = fixAvailable;\n          const breakingMessage = isSemVerMajor ? 'a SemVer major change' : 'outside your stated dependency range';\n          log.warn('audit', `Updating ${name} to ${version}, ` + `which is ${breakingMessage}.`);\n          await this[_add](node, {\n            add: [`${name}@${version}`]\n          });\n          nodesTouched.add(node);\n        }\n      }\n\n      for (const node of nodesTouched) {\n        node.package = node.package;\n      }\n    }\n  }\n\n  [_isVulnerable](node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  [_avoidRange](name) {\n    if (!this.auditReport) {\n      return null;\n    }\n\n    const vuln = this.auditReport.get(name);\n\n    if (!vuln) {\n      return null;\n    }\n\n    return vuln.range;\n  }\n\n  [_queueNamedUpdates]() {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory.filter(n => this[_shouldUpdateNode](n)); // XXX add any invalid edgesOut to the queue\n\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n        this[_depsQueue].push(edge.from);\n      }\n    }\n  }\n\n  [_shouldUpdateNode](node) {\n    return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;\n  }\n\n  async [_inflateAncientLockfile]() {\n    const {\n      meta,\n      inventory\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return;\n    } // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n\n\n    process.emit('time', 'idealTree:inflate'); // don't warn if we're not gonna actually write it back anyway.\n\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile';\n\n    if (ancient || !this.options.lockfileVersion || this.options.lockfileVersion >= defaultLockfileVersion) {\n      log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`);\n    }\n\n    this.addTracker('idealTree:inflate');\n    const queue = [];\n\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue;\n      } // if the node's location isn't within node_modules then this is actually\n      // a link target, so skip it. the link node itself will be queued later.\n\n\n      if (!node.location.startsWith('node_modules')) {\n        continue;\n      }\n\n      queue.push(async () => {\n        log.silly('inflate', node.location);\n        const {\n          resolved,\n          version,\n          path,\n          name,\n          location,\n          integrity\n        } = node; // don't try to hit the registry for linked deps\n\n        const useResolved = resolved && (!version || resolved.startsWith('file:'));\n        const id = useResolved ? resolved : version;\n        const spec = npa.resolve(name, id, dirname(path));\n        const t = `idealTree:inflate:${location}`;\n        this.addTracker(t);\n        await pacote.manifest(spec, { ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false\n        }).then(mani => {\n          node.package = { ...mani,\n            _id: `${mani.name}@${mani.version}`\n          };\n        }).catch(er => {\n          const warning = `Could not fetch metadata for ${name}@${id}`;\n          log.warn(heading, warning, er);\n        });\n        this.finishTracker(t);\n      });\n    }\n\n    await promiseCallLimit(queue); // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n\n    calcDepFlags(this.idealTree); // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n\n    meta.originalLockfileVersion = defaultLockfileVersion;\n    this.finishTracker('idealTree:inflate');\n    process.emit('timeEnd', 'idealTree:inflate');\n  } // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n\n\n  [_buildDeps]() {\n    process.emit('time', 'idealTree:buildDeps');\n    const tree = this.idealTree.target;\n    tree.assertRootOverrides();\n\n    this[_depsQueue].push(tree); // XXX also push anything that depends on a node with a name\n    // in the override list\n\n\n    log.silly('idealTree', 'buildDeps');\n    this.addTracker('idealTree', tree.name, '');\n    return this[_buildDepStep]().then(() => process.emit('timeEnd', 'idealTree:buildDeps'));\n  }\n\n  async [_buildDepStep]() {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const {\n        location,\n        name\n      } = this[_currentDep];\n      process.emit('timeEnd', `idealTree:${location || '#root'}`);\n      this.finishTracker('idealTree', name, location);\n      this[_currentDep] = null;\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]();\n    } // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n\n\n    this[_depsQueue].sort((a, b) => a.depth - b.depth || localeCompare(a.path, b.path));\n\n    const node = this[_depsQueue].shift();\n\n    const bd = node.package.bundleDependencies;\n    const hasBundle = bd && Array.isArray(bd) && bd.length;\n    const {\n      hasShrinkwrap\n    } = node; // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n\n    if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]();\n    }\n\n    this[_depsSeen].add(node);\n\n    this[_currentDep] = node;\n    process.emit('time', `idealTree:${node.location || '#root'}`); // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n\n    const crackOpen = this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap);\n\n    if (crackOpen) {\n      const Arborist = this.constructor;\n      const opt = { ...this.options\n      };\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, { ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity\n        });\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadVirtual({\n            root: node\n          });\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadActual({\n            root: node,\n            ignoreMissing: true\n          });\n        }\n      });\n    } // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n\n    const tasks = [];\n    const peerSource = this[_peerSetSource].get(node) || node;\n\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.peerConflicted) {\n        continue;\n      } // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n\n\n      const source = edge.peer ? peerSource : node;\n\n      const virtualRoot = this[_virtualRoot](source, true); // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n\n\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to; // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n\n      const required = new Set([edge.from]);\n      const parent = edge.peer ? virtualRoot : null;\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??');\n        }\n      });\n      tasks.push({\n        edge,\n        dep\n      });\n    }\n\n    const placeDeps = tasks.sort((a, b) => localeCompare(a.edge.name, b.edge.name)).map(_ref2 => {\n      let {\n        edge,\n        dep\n      } = _ref2;\n      return new PlaceDep({\n        edge,\n        dep,\n        explicitRequest: this[_explicitRequests].has(edge),\n        updateNames: this[_updateNames],\n        auditReport: this.auditReport,\n        force: this[_force],\n        preferDedupe: this[_preferDedupe],\n        legacyBundling: this[_legacyBundling],\n        strictPeerDeps: this[_strictPeerDeps],\n        installLinks: this.installLinks,\n        legacyPeerDeps: this.legacyPeerDeps,\n        globalStyle: this[_globalStyle]\n      });\n    });\n    const promises = [];\n\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const {\n            placed,\n            edge,\n            canPlace: cpd\n          } = pd; // if we didn't place anything, nothing to do here\n\n          if (!placed) {\n            return;\n          } // we placed something, that means we changed the tree\n\n\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed);\n          }\n\n          this[_mutateTree] = true;\n\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue;\n              }\n\n              const {\n                from,\n                valid,\n                peerConflicted\n              } = edgeIn;\n\n              if (!peerConflicted && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location);\n\n                this[_depsQueue].push(edgeIn.from);\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue;\n                }\n\n                const {\n                  valid,\n                  peerConflicted\n                } = edgeIn;\n\n                if (!valid && !peerConflicted) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from);\n\n                  this[_depsQueue].push(edgeIn.from);\n                }\n              }\n            }\n          }\n          /* istanbul ignore if - should be impossible */\n\n\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT');\n              throw Object.assign(er, {\n                placeDep: pd\n              });\n            });\n            return;\n          } // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n\n\n          this[_depsQueue].push(placed);\n\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep);\n\n            this[_depsQueue].push(dep);\n          } // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n\n\n          promises.push(...this[_problemEdges](placed).map(e => this[_fetchManifest](npa.resolve(e.name, e.spec, fromPath(placed, e))).catch(er => null)));\n        }\n      });\n    }\n\n    for (const {\n      to\n    } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to);\n      }\n    }\n\n    await Promise.all(promises);\n    return this[_buildDepStep]();\n  } // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n\n\n  async [_nodeFromEdge](edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from);\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path);\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge); // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n\n    const spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path);\n    const second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null; // pick the second one if they're both happy with that, otherwise first\n\n    const node = second && edge.valid ? second : first; // ensure the one we want is the one that's placed\n\n    node.parent = parent;\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' || secondEdge && required.has(secondEdge.from) && secondEdge.type !== 'peerOptional') {\n      required.add(node);\n    } // keep track of the thing that caused this node to be included.\n\n\n    const src = parent.sourceReference;\n\n    this[_peerSetSource].set(node, src); // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n\n\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node;\n    } // otherwise, we have to make sure that our peers can go along with us.\n\n\n    return this[_loadPeerSet](node, required);\n  }\n\n  [_virtualRoot](node) {\n    let reuse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node);\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      overrides: node.overrides\n    }); // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr\n        });\n      }\n    }\n\n    this[_virtualRoots].set(node, vr);\n\n    return vr;\n  }\n\n  [_problemEdges](node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies;\n    const bundled = new Set(bd || []);\n    return [...node.edgesOut.values()].filter(edge => {\n      // If it's included in a bundle, we take whatever is specified.\n      if (bundled.has(edge.name)) {\n        return false;\n      } // If it's already been logged as a load failure, skip it.\n\n\n      if (edge.to && this[_loadFailures].has(edge.to)) {\n        return false;\n      } // If it's shrinkwrapped, we use what the shrinkwap wants.\n\n\n      if (edge.to && edge.to.inShrinkwrap) {\n        return false;\n      } // If the edge has no destination, that's a problem, unless\n      // if it's peerOptional and not explicitly requested.\n\n\n      if (!edge.to) {\n        return edge.type !== 'peerOptional' || this[_explicitRequests].has(edge);\n      } // If the edge has an error, there's a problem.\n\n\n      if (!edge.valid) {\n        return true;\n      } // If the edge is a workspace, and it's valid, leave it alone\n\n\n      if (edge.to.isWorkspace) {\n        return false;\n      } // user explicitly asked to update this package by name, problem\n\n\n      if (this[_updateNames].includes(edge.name)) {\n        return true;\n      } // fixing a security vulnerability with this package, problem\n\n\n      if (this[_isVulnerable](edge.to)) {\n        return true;\n      } // user has explicitly asked to install this package, problem\n\n\n      if (this[_explicitRequests].has(edge)) {\n        return true;\n      } // No problems!\n\n\n      return false;\n    });\n  }\n\n  async [_fetchManifest](spec) {\n    const options = { ...this.options,\n      avoid: this[_avoidRange](spec.name)\n    }; // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n\n    spec = this.idealTree.meta.checkYarnLock(spec, options);\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw);\n    } else {\n      log.silly('fetch manifest', spec.raw);\n      const p = pacote.manifest(spec, options).then(mani => {\n        this[_manifests].set(spec.raw, mani);\n\n        return mani;\n      });\n\n      this[_manifests].set(spec.raw, p);\n\n      return p;\n    }\n  }\n\n  [_nodeFromSpec](name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const {\n      installLinks,\n      legacyPeerDeps\n    } = this;\n    const isWorkspace = this.idealTree.workspaces && this.idealTree.workspaces.has(spec.name); // spec is a directory, link it unless installLinks is set or it's a workspace\n\n    if (spec.type === 'directory' && (isWorkspace || !installLinks)) {\n      return this[_linkFromSpec](name, spec, parent, edge);\n    } // if the spec matches a workspace name, then see if the workspace node will\n    // satisfy the edge. if it does, we return the workspace node to make sure it\n    // takes priority.\n\n\n    if (isWorkspace) {\n      const existingNode = this.idealTree.edgesOut.get(spec.name).to;\n\n      if (existingNode && existingNode.isWorkspace && existingNode.satisfies(edge)) {\n        return edge.to;\n      }\n    } // spec isn't a directory, and either isn't a workspace or the workspace we have\n    // doesn't satisfy the edge. try to fetch a manifest and build a node from that.\n\n\n    return this[_fetchManifest](spec).then(pkg => new Node({\n      name,\n      pkg,\n      parent,\n      installLinks,\n      legacyPeerDeps\n    }), error => {\n      error.requiredBy = edge.from.location || '.'; // failed to load the spec, either because of enotarget or\n      // fetch failure of some other sort.  save it so we can verify\n      // later that it's optional, otherwise the error is fatal.\n\n      const n = new Node({\n        name,\n        parent,\n        error,\n        installLinks,\n        legacyPeerDeps\n      });\n\n      this[_loadFailures].add(n);\n\n      return n;\n    });\n  }\n\n  [_linkFromSpec](name, spec, parent, edge) {\n    const realpath = spec.fetchSpec;\n    const {\n      installLinks,\n      legacyPeerDeps\n    } = this;\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({\n        name,\n        parent,\n        realpath,\n        pkg,\n        installLinks,\n        legacyPeerDeps\n      });\n\n      this[_linkNodes].add(link);\n\n      return link;\n    });\n  } // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n\n\n  async [_loadPeerSet](node, required) {\n    const peerEdges = [...node.edgesOut.values()] // we typically only install non-optional peers, but we have to\n    // factor them into the peerSet so that we can avoid conflicts\n    .filter(e => e.peer && !(e.valid && e.to)).sort((_ref3, _ref4) => {\n      let {\n        name: a\n      } = _ref3;\n      let {\n        name: b\n      } = _ref4;\n      return localeCompare(a, b);\n    });\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue;\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name);\n      const {\n        isProjectRoot,\n        isWorkspace\n      } = node.parent.sourceReference;\n      const isMine = isProjectRoot || isWorkspace;\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required);\n          continue;\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required); // hooray! that worked!\n\n          if (edge.valid) {\n            continue;\n          } // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n\n\n          if (conflictOK || !required.has(dep)) {\n            edge.peerConflicted = true;\n            continue;\n          } // problem\n\n\n          this[_failPeerConflict](edge, parentEdge);\n        }\n      } // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n\n\n      const current = edge.to;\n      const dep = await this[_nodeFromEdge](edge, null, null, required);\n\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required);\n        continue;\n      } // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n\n\n      if (conflictOK || !required.has(edge.from)) {\n        continue;\n      } // ok, it's the root, or we're in unforced strict mode, so this is bad\n\n\n      this[_failPeerConflict](edge, parentEdge);\n    }\n\n    return node;\n  }\n\n  [_failPeerConflict](edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge);\n\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl);\n  }\n\n  [_explainPeerConflict](edge, currentEdge) {\n    const node = edge.from;\n    const curNode = node.resolve(edge.name);\n    const current = curNode.explain();\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force]\n    };\n  } // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n\n\n  [_resolveLinks]() {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link); // link we never ended up placing, skip it\n\n\n      if (link.root !== this.idealTree) {\n        continue;\n      }\n\n      const tree = this.idealTree.target;\n      const external = !link.target.isDescendantOf(tree); // outside the root, somebody else's problem, ignore it\n\n      if (external && !this[_follow]) {\n        continue;\n      } // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n\n\n      const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);\n\n      if (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location);\n\n        this[_depsQueue].push(link.target);\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]();\n    }\n  }\n\n  [_fixDepFlags]() {\n    process.emit('time', 'idealTree:fixDepFlags');\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk;\n    const flagsSuspect = this[_flagsSuspect];\n    const mutateTree = this[_mutateTree]; // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree);\n    } // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n\n\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree);\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false;\n      this.idealTree.dev = false;\n      this.idealTree.optional = false;\n      this.idealTree.devOptional = false;\n      this.idealTree.peer = false;\n    } // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n\n\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect);\n\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]();\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags');\n  }\n\n  [_idealTreePrune]() {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null;\n    }\n  }\n\n  [_pruneFailedOptional]() {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0];\n      }\n\n      const set = optionalSet(node);\n\n      for (const node of set) {\n        node.parent = null;\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["localeCompare","require","rpj","npa","pacote","cacache","promiseCallLimit","realpath","resolve","dirname","promisify","treeCheck","readdir","fs","lstat","readlink","depth","log","OK","REPLACE","CONFLICT","PlaceDep","debug","fromPath","calcDepFlags","Shrinkwrap","defaultLockfileVersion","Node","Link","addRmPkgDeps","optionalSet","checkEngine","checkPlatform","relpath","_complete","Symbol","_depsSeen","_depsQueue","_currentDep","_updateAll","for","_mutateTree","_flagsSuspect","_workspaces","_prune","_preferDedupe","_legacyBundling","_parseSettings","_initTree","_applyUserRequests","_applyUserRequestsToNode","_inflateAncientLockfile","_buildDeps","_buildDepStep","_nodeFromEdge","_nodeFromSpec","_fetchManifest","_problemEdges","_manifests","_loadWorkspaces","_linkFromSpec","_loadPeerSet","_updateNames","_fixDepFlags","_resolveLinks","_rootNodeFromPackage","_add","_resolvedAdd","_queueNamedUpdates","_queueVulnDependents","_avoidRange","_shouldUpdateNode","resetDepFlags","_loadFailures","_pruneFailedOptional","_linkNodes","_follow","_globalStyle","_globalRootNode","_isVulnerable","_usePackageLock","_rpcache","_stcache","_updateFilePath","_followSymlinkPath","_getRelpathSpec","_retrieveSpecName","_strictPeerDeps","_checkEngineAndPlatform","_checkEngine","_checkPlatform","_virtualRoots","_virtualRoot","_includeWorkspaceRoot","_failPeerConflict","_explainPeerConflict","_edgesOverridden","_peerSetSource","_force","_explicitRequests","_global","_idealTreePrune","module","exports","cls","IdealTreeBuilder","constructor","options","registry","replace","follow","force","global","globalStyle","idealTree","includeWorkspaceRoot","installLinks","legacyPeerDeps","packageLock","strictPeerDeps","workspaces","length","Error","Set","Map","WeakMap","explicitRequests","buildIdealTree","add","rm","process","emit","update","addTracker","finishTracker","node","inventory","values","optional","package","engineStrict","npmVersion","nodeVersion","c","er","warn","code","message","pkgid","required","current","all","Array","isArray","names","complete","preferDedupe","legacyBundling","name","spec","validationError","TypeError","fetchSpec","prune","path","then","pkg","root","reset","lockfileVersion","resolveOptions","meta","Object","assign","loadVirtual","loadedFromDisk","loadActual","tree","target","children","size","originalLockfileVersion","inferFormattingOptions","getChildren","edgesOut","map","edge","to","filter","visit","valid","push","virtualTree","dependencies","real","Cls","extraneous","dev","devOptional","peer","loadOverrides","isLink","nodes","workspaceNodes","appliedRequests","Promise","globalExplicitUpdateNames","nm","catch","updateName","includes","dir","st","isSymbolicLink","auditReport","from","action","get","saveType","saveBundle","rawSpec","isTag","type","mani","manifest","version","filepath","vuln","bundler","getBundler","location","edgesIn","topVulns","nodesTouched","topVuln","entries","simpleRange","topNodes","fixAvailable","isProjectRoot","isWorkspace","isSemVerMajor","breakingMessage","isVulnerable","range","set","n","isTop","inDepBundle","inShrinkwrap","ancient","ancientLockfile","old","heading","queue","startsWith","silly","resolved","integrity","useResolved","id","t","fullMetadata","_id","warning","assertRootOverrides","sort","a","b","shift","bd","bundleDependencies","hasBundle","hasShrinkwrap","has","crackOpen","Arborist","opt","tmp","withTmp","cache","extract","ignoreMissing","tasks","peerSource","peerConflicted","source","virtualRoot","vrEdge","vrDep","parent","dep","satisfies","placeDeps","explicitRequest","updateNames","promises","pd","placed","canPlace","cpd","errors","canPlaceSelf","edgeIn","delete","placeDep","needEvaluation","e","parent_","secondEdge","first","spec2","second","src","sourceReference","reuse","vr","overrides","child","bundled","avoid","checkYarnLock","raw","p","existingNode","error","requiredBy","link","peerEdges","parentEdge","isMine","conflictOK","canReplace","currentEdge","expl","curNode","explain","external","isDescendantOf","unseenLink","fsParent","metaFromDisk","flagsSuspect","mutateTree","needPrune"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"],"sourcesContent":["// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst promiseCallLimit = require('promise-call-limit')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve, dirname } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst readlink = promisify(fs.readlink)\nconst { depth } = require('treeverse')\nconst log = require('proc-log')\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT,\n} = require('../can-place-dep.js')\nconst PlaceDep = require('../place-dep.js')\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst { defaultLockfileVersion } = Shrinkwrap\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst optionalSet = require('../optional-set.js')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol.for('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      follow = false,\n      force = false,\n      global = false,\n      globalStyle = false,\n      idealTree = null,\n      includeWorkspaceRoot = false,\n      installLinks = false,\n      legacyPeerDeps = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.installLinks = installLinks\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode')\n    }\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n\n    this[_includeWorkspaceRoot] = includeWorkspaceRoot\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree) {\n      return this.idealTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0) {\n      options.add = null\n    }\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null\n    }\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      throw new Error('global requires add, rm, or update option')\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  async [_checkEngineAndPlatform] () {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node)\n        this[_checkPlatform](node)\n      }\n    }\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () =>\n      checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict) {\n      c()\n    } else {\n      try {\n        c()\n      } catch (er) {\n        log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = []\n    }\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n\n    // validates list of update names, they must\n    // be dep names only, no semver ranges are supported\n    for (const name of update.names) {\n      const spec = npa(name)\n      const validationError =\n        new TypeError(`Update arguments must not contain package version specifiers\n\nTry using the package name instead, e.g:\n    npm update ${spec.name}`)\n      validationError.code = 'EUPDATEARGS'\n\n      if (spec.fetchSpec !== 'latest') {\n        throw validationError\n      }\n    }\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE') {\n            throw er\n          }\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({\n          path: this.path,\n          lockfileVersion: this.options.lockfileVersion,\n          resolveOptions: this.options,\n        }).then(meta => Object.assign(root, { meta }))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if ((!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) || (this[_global] && this[_updateNames].length)) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size) {\n            root.meta.loadedFromDisk = true\n            // set these so that we don't try to ancient lockfile reload it\n            root.meta.originalLockfileVersion = defaultLockfileVersion\n            root.meta.lockfileVersion = defaultLockfileVersion\n          }\n        }\n        root.meta.inferFormattingOptions(root.package)\n        return root\n      })\n\n      .then(tree => {\n        // search the virtual tree for invalid edges, if any are found add their source to\n        // the depsQueue so that we'll fix it later\n        depth({\n          tree,\n          getChildren: (node) => [...node.edgesOut.values()].map(edge => edge.to),\n          filter: node => node,\n          visit: node => {\n            for (const edge of node.edgesOut.values()) {\n              if (!edge.valid) {\n                this[_depsQueue].push(node)\n                break // no need to continue the loop after the first hit\n              }\n            }\n          },\n        })\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options,\n    })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      loadOverrides: true,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        installLinks: this.installLinks,\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options)\n    } else {\n      const nodes = this.workspaceNodes(tree, this[_workspaces])\n      if (this[_includeWorkspaceRoot]) {\n        nodes.push(tree)\n      }\n      const appliedRequests = nodes.map(\n        node => this[_applyUserRequestsToNode](node, options)\n      )\n      await Promise.all(appliedRequests)\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests')\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]()\n    }\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name)\n          }\n          const dir = resolve(nm, name)\n          const st = await lstat(dir)\n            .catch(/* istanbul ignore next */ er => null)\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir)\n            const real = resolve(dirname(dir), target).replace(/#/g, '%23')\n            tree.package.dependencies[name] = `file:${real}`\n          } else {\n            tree.package.dependencies[name] = '*'\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options)\n    }\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm) {\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options)\n    }\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n      }\n    }\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n    }\n\n    this[_depsQueue].push(tree)\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, { add, saveType = null, saveBundle = false }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec))\n        .then(spec => this[_updateFilePath](spec))\n        .then(spec => this[_followSymlinkPath](spec))\n      spec.tree = tree\n      return spec\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag) {\n      return spec\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`)\n    }\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec)\n    }\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      return this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target\n      spec = npa(`file:${relpath(tree.path, filepath).replace(/#/g, '%23')}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents] (options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      const nodesTouched = new Set()\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          log.warn('audit', `Updating ${name} to ${version}, ` +\n            `which is ${breakingMessage}.`)\n\n          await this[_add](node, { add: [`${name}@${version}`] })\n          nodesTouched.add(node)\n        }\n      }\n      for (const node of nodesTouched) {\n        node.package = node.package\n      }\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport) {\n      return null\n    }\n    const vuln = this.auditReport.get(name)\n    if (!vuln) {\n      return null\n    }\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    // XXX add any invalid edgesOut to the queue\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return\n    }\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    // don't warn if we're not gonna actually write it back anyway.\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    if (ancient || !this.options.lockfileVersion ||\n        this.options.lockfileVersion >= defaultLockfileVersion) {\n      log.warn(heading,\n        `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n    }\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue\n      }\n\n      // if the node's location isn't within node_modules then this is actually\n      // a link target, so skip it. the link node itself will be queued later.\n      if (!node.location.startsWith('node_modules')) {\n        continue\n      }\n\n      queue.push(async () => {\n        log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (\n          !version || resolved.startsWith('file:')\n        )\n        const id = useResolved ? resolved : version\n        const spec = npa.resolve(name, id, dirname(path))\n        const t = `idealTree:inflate:${location}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = defaultLockfileVersion\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target\n    tree.assertRootOverrides()\n    this[_depsQueue].push(tree)\n    // XXX also push anything that depends on a node with a name\n    // in the override list\n    log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]()\n    }\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || localeCompare(a.path, b.path))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]()\n    }\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity,\n        })\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.peerConflicted) {\n        continue\n      }\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??')\n        }\n      })\n\n      tasks.push({ edge, dep })\n    }\n\n    const placeDeps = tasks\n      .sort((a, b) => localeCompare(a.edge.name, b.edge.name))\n      .map(({ edge, dep }) => new PlaceDep({\n        edge,\n        dep,\n\n        explicitRequest: this[_explicitRequests].has(edge),\n        updateNames: this[_updateNames],\n        auditReport: this.auditReport,\n        force: this[_force],\n        preferDedupe: this[_preferDedupe],\n        legacyBundling: this[_legacyBundling],\n        strictPeerDeps: this[_strictPeerDeps],\n        installLinks: this.installLinks,\n        legacyPeerDeps: this.legacyPeerDeps,\n        globalStyle: this[_globalStyle],\n      }))\n\n    const promises = []\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const { placed, edge, canPlace: cpd } = pd\n          // if we didn't place anything, nothing to do here\n          if (!placed) {\n            return\n          }\n\n          // we placed something, that means we changed the tree\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed)\n          }\n          this[_mutateTree] = true\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue\n              }\n              const { from, valid, peerConflicted } = edgeIn\n              if (!peerConflicted && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location)\n                this[_depsQueue].push(edgeIn.from)\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue\n                }\n\n                const { valid, peerConflicted } = edgeIn\n                if (!valid && !peerConflicted) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from)\n                  this[_depsQueue].push(edgeIn.from)\n                }\n              }\n            }\n          }\n\n          /* istanbul ignore if - should be impossible */\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT')\n              throw Object.assign(er, { placeDep: pd })\n            })\n            return\n          }\n\n          // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n          this[_depsQueue].push(placed)\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep)\n            this[_depsQueue].push(dep)\n          }\n\n          // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n          promises.push(...this[_problemEdges](placed).map(e =>\n            this[_fetchManifest](npa.resolve(e.name, e.spec, fromPath(placed, e)))\n              .catch(er => null)))\n        },\n      })\n    }\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to)\n      }\n    }\n\n    await Promise.all(promises)\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional')) {\n      required.add(node)\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n\n    // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node\n    }\n\n    // otherwise, we have to make sure that our peers can go along with us.\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node)\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      installLinks: this.installLinks,\n      legacyPeerDeps: this.legacyPeerDeps,\n      overrides: node.overrides,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null\n      : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name)) {\n          return false\n        }\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to)) {\n          return false\n        }\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap) {\n          return false\n        }\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid) {\n          return true\n        }\n\n        // If the edge is a workspace, and it's valid, leave it alone\n        if (edge.to.isWorkspace) {\n          return false\n        }\n\n        // user explicitly asked to update this package by name, problem\n        if (this[_updateNames].includes(edge.name)) {\n          return true\n        }\n\n        // fixing a security vulnerability with this package, problem\n        if (this[_isVulnerable](edge.to)) {\n          return true\n        }\n\n        // user has explicitly asked to install this package, problem\n        if (this[_explicitRequests].has(edge)) {\n          return true\n        }\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw)\n    } else {\n      log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { installLinks, legacyPeerDeps } = this\n    const isWorkspace = this.idealTree.workspaces && this.idealTree.workspaces.has(spec.name)\n\n    // spec is a directory, link it unless installLinks is set or it's a workspace\n    if (spec.type === 'directory' && (isWorkspace || !installLinks)) {\n      return this[_linkFromSpec](name, spec, parent, edge)\n    }\n\n    // if the spec matches a workspace name, then see if the workspace node will\n    // satisfy the edge. if it does, we return the workspace node to make sure it\n    // takes priority.\n    if (isWorkspace) {\n      const existingNode = this.idealTree.edgesOut.get(spec.name).to\n      if (existingNode && existingNode.isWorkspace && existingNode.satisfies(edge)) {\n        return edge.to\n      }\n    }\n\n    // spec isn't a directory, and either isn't a workspace or the workspace we have\n    // doesn't satisfy the edge. try to fetch a manifest and build a node from that.\n    return this[_fetchManifest](spec)\n      .then(pkg => new Node({ name, pkg, parent, installLinks, legacyPeerDeps }), error => {\n        error.requiredBy = edge.from.location || '.'\n\n        // failed to load the spec, either because of enotarget or\n        // fetch failure of some other sort.  save it so we can verify\n        // later that it's optional, otherwise the error is fatal.\n        const n = new Node({\n          name,\n          parent,\n          error,\n          installLinks,\n          legacyPeerDeps,\n        })\n        this[_loadFailures].add(n)\n        return n\n      })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { installLinks, legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, installLinks, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({ name: a }, { name: b }) => localeCompare(a, b))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const { isProjectRoot, isWorkspace } = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](\n            parentEdge,\n            node.parent,\n            edge,\n            required\n          )\n\n          // hooray! that worked!\n          if (edge.valid) {\n            continue\n          }\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep)) {\n            edge.peerConflicted = true\n            continue\n          }\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to\n      const dep = await this[_nodeFromEdge](edge, null, null, required)\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required)\n        continue\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from)) {\n        continue\n      }\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const current = curNode.explain()\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree) {\n        continue\n      }\n\n      const tree = this.idealTree.target\n      const external = !link.target.isDescendantOf(tree)\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow]) {\n        continue\n      }\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]()\n    }\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree)\n    }\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree)\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]()\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null\n    }\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0]\n      }\n\n      const set = optionalSet(node)\n      for (const node of set) {\n        node.parent = null\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}