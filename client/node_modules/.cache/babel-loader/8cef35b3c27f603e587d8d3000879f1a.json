{"ast":null,"code":"// an object representing the set of vulnerabilities in a tree\n\n/* eslint camelcase: \"off\" */\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst npa = require('npm-package-arg');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst Vuln = require('./vuln.js');\n\nconst Calculator = require('@npmcli/metavuln-calculator');\n\nconst _getReport = Symbol('getReport');\n\nconst _fixAvailable = Symbol('fixAvailable');\n\nconst _checkTopNode = Symbol('checkTopNode');\n\nconst _init = Symbol('init');\n\nconst _omit = Symbol('omit');\n\nconst log = require('proc-log');\n\nconst fetch = require('npm-registry-fetch');\n\nclass AuditReport extends Map {\n  static load(tree, opts) {\n    return new AuditReport(tree, opts).run();\n  }\n\n  get auditReportVersion() {\n    return 2;\n  }\n\n  toJSON() {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1\n        }\n      }\n    };\n\n    for (const node of this.tree.inventory.values()) {\n      const {\n        dependencies\n      } = obj.metadata;\n      let prod = true;\n\n      for (const type of ['dev', 'optional', 'peer', 'peerOptional']) {\n        if (node[type]) {\n          dependencies[type]++;\n          prod = false;\n        }\n      }\n\n      if (prod) {\n        dependencies.prod++;\n      }\n    } // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n\n\n    const vulnerabilities = [];\n\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()]);\n      obj.metadata.vulnerabilities[vuln.severity]++;\n    }\n\n    obj.vulnerabilities = vulnerabilities.sort((_ref, _ref2) => {\n      let [a] = _ref;\n      let [b] = _ref2;\n      return localeCompare(a, b);\n    }).reduce((set, _ref3) => {\n      let [name, vuln] = _ref3;\n      set[name] = vuln;\n      return set;\n    }, {});\n    return obj;\n  }\n\n  constructor(tree) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    const {\n      omit\n    } = opts;\n    this[_omit] = new Set(omit || []);\n    this.topVulns = new Map();\n    this.calculator = new Calculator(opts);\n    this.error = null;\n    this.options = opts;\n    this.tree = tree;\n    this.filterSet = opts.filterSet;\n  }\n\n  async run() {\n    this.report = await this[_getReport]();\n    log.silly('audit report', this.report);\n\n    if (this.report) {\n      await this[_init]();\n    }\n\n    return this;\n  }\n\n  isVulnerable(node) {\n    const vuln = this.get(node.packageName);\n    return !!(vuln && vuln.isVulnerable(node));\n  }\n\n  async [_init]() {\n    process.emit('time', 'auditReport:init');\n    const promises = [];\n\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) {\n        promises.push(this.calculator.calculate(name, advisory));\n      }\n    } // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n\n\n    const advisories = new Set(await Promise.all(promises));\n    const seen = new Set();\n\n    for (const advisory of advisories) {\n      const {\n        name,\n        range\n      } = advisory;\n      const k = `${name}@${range}`;\n      const vuln = this.get(name) || new Vuln({\n        name,\n        advisory\n      });\n\n      if (this.has(name)) {\n        vuln.addAdvisory(advisory);\n      }\n\n      super.set(name, vuln); // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n\n      if (!seen.has(k)) {\n        const p = [];\n\n        for (const node of this.tree.inventory.query('packageName', name)) {\n          if (!shouldAudit(node, this[_omit], this.filterSet)) {\n            continue;\n          } // if not vulnerable by this advisory, keep searching\n\n\n          if (!advisory.testVersion(node.version)) {\n            continue;\n          } // we will have loaded the source already if this is a metavuln\n\n\n          if (advisory.type === 'metavuln') {\n            vuln.addVia(this.get(advisory.dependency));\n          } // already marked this one, no need to do it again\n\n\n          if (vuln.nodes.has(node)) {\n            continue;\n          } // haven't marked this one yet.  get its dependents.\n\n\n          vuln.nodes.add(node);\n\n          for (const {\n            from: dep,\n            spec\n          } of node.edgesIn) {\n            if (dep.isTop && !vuln.topNodes.has(dep)) {\n              this[_checkTopNode](dep, vuln, spec);\n            } else {\n              // calculate a metavuln, if necessary\n              const calc = this.calculator.calculate(dep.packageName, advisory);\n              p.push(calc.then(meta => {\n                if (meta.testVersion(dep.version, spec)) {\n                  advisories.add(meta);\n                }\n              }));\n            }\n          }\n        }\n\n        await Promise.all(p);\n        seen.add(k);\n      } // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n\n\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name);\n        continue;\n      } // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n\n\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes].some(n => advisory.testVersion(n.version));\n\n        if (!relevant) {\n          vuln.deleteAdvisory(advisory);\n        }\n      }\n    }\n\n    process.emit('timeEnd', 'auditReport:init');\n  }\n\n  [_checkTopNode](topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec);\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln);\n      vuln.topNodes.add(topNode);\n    }\n  } // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n\n\n  [_fixAvailable](topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument;\n\n    if (!vuln.testSpec(spec)) {\n      return true;\n    } // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n\n\n    const specObj = npa(spec);\n\n    if (!specObj.registry) {\n      return false;\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec;\n    } // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n\n\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name\n      } = pickManifest(paku, spec, { ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true\n      });\n      return {\n        name,\n        version,\n        isSemVerMajor\n      };\n    } catch (er) {\n      return false;\n    }\n  }\n\n  set() {\n    throw new Error('do not call AuditReport.set() directly');\n  } // convert a quick-audit into a bulk advisory listing\n\n\n  static auditToBulk(report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report)\n      });\n    }\n\n    const bulk = {};\n    const {\n      advisories\n    } = report;\n\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name\n      } = advisory;\n      bulk[name] = bulk[name] || [];\n      bulk[name].push({\n        id,\n        url,\n        title,\n        severity,\n        vulnerable_versions\n      });\n    }\n\n    return bulk;\n  }\n\n  async [_getReport]() {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.options.offline === true || this.tree.inventory.size === 1) {\n      return null;\n    }\n\n    process.emit('time', 'auditReport:getReport');\n\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit], this.filterSet);\n        log.silly('audit', 'bulk request', body); // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n\n        if (!Object.keys(body).length) {\n          return null;\n        }\n\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', { ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return await res.json();\n      } catch (er) {\n        log.silly('audit', 'bulk request failed', String(er.body)); // that failed, try the quick audit endpoint\n\n        const body = prepareData(this.tree, this.options);\n        const res = await fetch('/-/npm/v1/security/audits/quick', { ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return AuditReport.auditToBulk(await res.json());\n      }\n    } catch (er) {\n      log.verbose('audit error', er);\n      log.silly('audit error', String(er.body));\n      this.error = er;\n      return null;\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport');\n    }\n  }\n\n} // return true if we should audit this one\n\n\nconst shouldAudit = (node, omit, filterSet) => !node.version ? false : node.isRoot ? false : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false : omit.size === 0 ? true : !( // otherwise, just ensure we're not omitting this one\nnode.dev && omit.has('dev') || node.optional && omit.has('optional') || node.devOptional && omit.has('dev') && omit.has('optional') || node.peer && omit.has('peer'));\n\nconst prepareBulkData = (tree, omit, filterSet) => {\n  const payload = {};\n\n  for (const name of tree.inventory.query('packageName')) {\n    const set = new Set();\n\n    for (const node of tree.inventory.query('packageName', name)) {\n      if (!shouldAudit(node, omit, filterSet)) {\n        continue;\n      }\n\n      set.add(node.version);\n    }\n\n    if (set.size) {\n      payload[name] = [...set];\n    }\n  }\n\n  return payload;\n};\n\nconst prepareData = (tree, opts) => {\n  const {\n    npmVersion: npm_version\n  } = opts;\n  const node_version = process.version;\n  const {\n    platform,\n    arch\n  } = process;\n  const {\n    NODE_ENV: node_env\n  } = process.env;\n  const data = tree.meta.commit(); // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n\n  return {\n    name: data.name,\n    version: data.version,\n    requires: { ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {})\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env\n    }\n  };\n};\n\nmodule.exports = AuditReport;","map":{"version":3,"names":["localeCompare","require","npa","pickManifest","Vuln","Calculator","_getReport","Symbol","_fixAvailable","_checkTopNode","_init","_omit","log","fetch","AuditReport","Map","load","tree","opts","run","auditReportVersion","toJSON","obj","vulnerabilities","metadata","info","low","moderate","high","critical","total","size","dependencies","prod","dev","optional","peer","peerOptional","inventory","node","values","type","name","vuln","entries","push","severity","sort","a","b","reduce","set","constructor","omit","Set","topVulns","calculator","error","options","filterSet","report","silly","isVulnerable","get","packageName","process","emit","promises","advisories","Object","advisory","calculate","Promise","all","seen","range","k","has","addAdvisory","p","query","shouldAudit","testVersion","version","addVia","dependency","nodes","add","from","dep","spec","edgesIn","isTop","topNodes","calc","then","meta","delete","relevant","some","n","deleteAdvisory","topNode","fixAvailable","paku","packument","testSpec","specObj","registry","subSpec","rawSpec","_isSemVerMajor","isSemVerMajor","before","avoid","avoidStrict","er","Error","auditToBulk","assign","body","JSON","stringify","bulk","id","url","title","vulnerable_versions","module_name","audit","offline","prepareBulkData","keys","length","res","auditRegistry","method","gzip","json","String","prepareData","verbose","isRoot","devOptional","payload","npmVersion","npm_version","node_version","platform","arch","NODE_ENV","node_env","env","data","commit","requires","package","devDependencies","peerDependencies","optionalDependencies","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/audit-report.js"],"sourcesContent":["// an object representing the set of vulnerabilities in a tree\n/* eslint camelcase: \"off\" */\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst pickManifest = require('npm-pick-manifest')\n\nconst Vuln = require('./vuln.js')\nconst Calculator = require('@npmcli/metavuln-calculator')\n\nconst _getReport = Symbol('getReport')\nconst _fixAvailable = Symbol('fixAvailable')\nconst _checkTopNode = Symbol('checkTopNode')\nconst _init = Symbol('init')\nconst _omit = Symbol('omit')\nconst log = require('proc-log')\n\nconst fetch = require('npm-registry-fetch')\n\nclass AuditReport extends Map {\n  static load (tree, opts) {\n    return new AuditReport(tree, opts).run()\n  }\n\n  get auditReportVersion () {\n    return 2\n  }\n\n  toJSON () {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size,\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1,\n        },\n      },\n    }\n\n    for (const node of this.tree.inventory.values()) {\n      const { dependencies } = obj.metadata\n      let prod = true\n      for (const type of [\n        'dev',\n        'optional',\n        'peer',\n        'peerOptional',\n      ]) {\n        if (node[type]) {\n          dependencies[type]++\n          prod = false\n        }\n      }\n      if (prod) {\n        dependencies.prod++\n      }\n    }\n\n    // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n    const vulnerabilities = []\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()])\n      obj.metadata.vulnerabilities[vuln.severity]++\n    }\n\n    obj.vulnerabilities = vulnerabilities\n      .sort(([a], [b]) => localeCompare(a, b))\n      .reduce((set, [name, vuln]) => {\n        set[name] = vuln\n        return set\n      }, {})\n\n    return obj\n  }\n\n  constructor (tree, opts = {}) {\n    super()\n    const { omit } = opts\n    this[_omit] = new Set(omit || [])\n    this.topVulns = new Map()\n\n    this.calculator = new Calculator(opts)\n    this.error = null\n    this.options = opts\n    this.tree = tree\n    this.filterSet = opts.filterSet\n  }\n\n  async run () {\n    this.report = await this[_getReport]()\n    log.silly('audit report', this.report)\n    if (this.report) {\n      await this[_init]()\n    }\n    return this\n  }\n\n  isVulnerable (node) {\n    const vuln = this.get(node.packageName)\n    return !!(vuln && vuln.isVulnerable(node))\n  }\n\n  async [_init] () {\n    process.emit('time', 'auditReport:init')\n\n    const promises = []\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) {\n        promises.push(this.calculator.calculate(name, advisory))\n      }\n    }\n\n    // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n    const advisories = new Set(await Promise.all(promises))\n    const seen = new Set()\n    for (const advisory of advisories) {\n      const { name, range } = advisory\n      const k = `${name}@${range}`\n\n      const vuln = this.get(name) || new Vuln({ name, advisory })\n      if (this.has(name)) {\n        vuln.addAdvisory(advisory)\n      }\n      super.set(name, vuln)\n\n      // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n      if (!seen.has(k)) {\n        const p = []\n        for (const node of this.tree.inventory.query('packageName', name)) {\n          if (!shouldAudit(node, this[_omit], this.filterSet)) {\n            continue\n          }\n\n          // if not vulnerable by this advisory, keep searching\n          if (!advisory.testVersion(node.version)) {\n            continue\n          }\n\n          // we will have loaded the source already if this is a metavuln\n          if (advisory.type === 'metavuln') {\n            vuln.addVia(this.get(advisory.dependency))\n          }\n\n          // already marked this one, no need to do it again\n          if (vuln.nodes.has(node)) {\n            continue\n          }\n\n          // haven't marked this one yet.  get its dependents.\n          vuln.nodes.add(node)\n          for (const { from: dep, spec } of node.edgesIn) {\n            if (dep.isTop && !vuln.topNodes.has(dep)) {\n              this[_checkTopNode](dep, vuln, spec)\n            } else {\n            // calculate a metavuln, if necessary\n              const calc = this.calculator.calculate(dep.packageName, advisory)\n              p.push(calc.then(meta => {\n                if (meta.testVersion(dep.version, spec)) {\n                  advisories.add(meta)\n                }\n              }))\n            }\n          }\n        }\n        await Promise.all(p)\n        seen.add(k)\n      }\n\n      // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name)\n        continue\n      }\n\n      // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes]\n          .some(n => advisory.testVersion(n.version))\n        if (!relevant) {\n          vuln.deleteAdvisory(advisory)\n        }\n      }\n    }\n    process.emit('timeEnd', 'auditReport:init')\n  }\n\n  [_checkTopNode] (topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec)\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln)\n      vuln.topNodes.add(topNode)\n    }\n  }\n\n  // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n  [_fixAvailable] (topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument\n\n    if (!vuln.testSpec(spec)) {\n      return true\n    }\n\n    // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n    const specObj = npa(spec)\n    if (!specObj.registry) {\n      return false\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec\n    }\n\n    // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name,\n      } = pickManifest(paku, spec, {\n        ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true,\n      })\n      return { name, version, isSemVerMajor }\n    } catch (er) {\n      return false\n    }\n  }\n\n  set () {\n    throw new Error('do not call AuditReport.set() directly')\n  }\n\n  // convert a quick-audit into a bulk advisory listing\n  static auditToBulk (report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report),\n      })\n    }\n\n    const bulk = {}\n    const { advisories } = report\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name,\n      } = advisory\n      bulk[name] = bulk[name] || []\n      bulk[name].push({ id, url, title, severity, vulnerable_versions })\n    }\n\n    return bulk\n  }\n\n  async [_getReport] () {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.options.offline === true || this.tree.inventory.size === 1) {\n      return null\n    }\n\n    process.emit('time', 'auditReport:getReport')\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit], this.filterSet)\n        log.silly('audit', 'bulk request', body)\n\n        // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n        if (!Object.keys(body).length) {\n          return null\n        }\n\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n\n        return await res.json()\n      } catch (er) {\n        log.silly('audit', 'bulk request failed', String(er.body))\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options)\n        const res = await fetch('/-/npm/v1/security/audits/quick', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n        return AuditReport.auditToBulk(await res.json())\n      }\n    } catch (er) {\n      log.verbose('audit error', er)\n      log.silly('audit error', String(er.body))\n      this.error = er\n      return null\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport')\n    }\n  }\n}\n\n// return true if we should audit this one\nconst shouldAudit = (node, omit, filterSet) =>\n  !node.version ? false\n  : node.isRoot ? false\n  : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false\n  : omit.size === 0 ? true\n  : !( // otherwise, just ensure we're not omitting this one\n    node.dev && omit.has('dev') ||\n    node.optional && omit.has('optional') ||\n    node.devOptional && omit.has('dev') && omit.has('optional') ||\n    node.peer && omit.has('peer')\n  )\n\nconst prepareBulkData = (tree, omit, filterSet) => {\n  const payload = {}\n  for (const name of tree.inventory.query('packageName')) {\n    const set = new Set()\n    for (const node of tree.inventory.query('packageName', name)) {\n      if (!shouldAudit(node, omit, filterSet)) {\n        continue\n      }\n\n      set.add(node.version)\n    }\n    if (set.size) {\n      payload[name] = [...set]\n    }\n  }\n  return payload\n}\n\nconst prepareData = (tree, opts) => {\n  const { npmVersion: npm_version } = opts\n  const node_version = process.version\n  const { platform, arch } = process\n  const { NODE_ENV: node_env } = process.env\n  const data = tree.meta.commit()\n  // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n  return {\n    name: data.name,\n    version: data.version,\n    requires: {\n      ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {}),\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env,\n    },\n  }\n}\n\nmodule.exports = AuditReport\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}