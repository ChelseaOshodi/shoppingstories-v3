{"ast":null,"code":"const {\n  Request,\n  Response\n} = require('minipass-fetch');\n\nconst Minipass = require('minipass');\n\nconst MinipassFlush = require('minipass-flush');\n\nconst cacache = require('cacache');\n\nconst url = require('url');\n\nconst CachingMinipassPipeline = require('../pipeline.js');\n\nconst CachePolicy = require('./policy.js');\n\nconst cacheKey = require('./key.js');\n\nconst remote = require('../remote.js');\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop); // allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\n\n\nconst KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control']; // allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\n\nconst KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'link', 'location', 'pragma', 'vary']; // return an object containing all metadata to be written to the index\n\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n    // options on which we must match the request and vary the response\n    options: {\n      compress: options.compress != null ? options.compress : request.compress\n    }\n  }; // only save the status if it's not a 200 or 304\n\n  if (response.status !== 200 && response.status !== 304) {\n    metadata.status = response.status;\n  }\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) {\n      metadata.reqHeaders[name] = request.headers.get(name);\n    }\n  } // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n\n\n  const host = request.headers.get('host');\n  const parsedUrl = new url.URL(request.url);\n\n  if (host && parsedUrl.host !== host) {\n    metadata.reqHeaders.host = host;\n  } // if the response has a vary header, make sure\n  // we store the relevant request headers too\n\n\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary'); // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n\n      for (const name of varyHeaders) {\n        if (request.headers.has(name)) {\n          metadata.reqHeaders[name] = request.headers.get(name);\n        }\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name);\n    }\n  }\n\n  return metadata;\n}; // symbols used to hide objects that may be lazily evaluated in a getter\n\n\nconst _request = Symbol('request');\n\nconst _response = Symbol('response');\n\nconst _policy = Symbol('policy');\n\nclass CacheEntry {\n  constructor(_ref) {\n    let {\n      entry,\n      request,\n      response,\n      options\n    } = _ref;\n\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry; // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else {\n      this.key = cacheKey(request);\n    }\n\n    this.options = options; // these properties are behind getters that lazily evaluate\n\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  } // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n\n\n  static async find(request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({\n          entry: A,\n          options\n        });\n        const entryB = new CacheEntry({\n          entry: B,\n          options\n        });\n        return entryA.policy.satisfies(entryB.request);\n      }, {\n        validateEntry: entry => {\n          // clean out entries with a buggy content-encoding value\n          if (entry.metadata && entry.metadata.resHeaders && entry.metadata.resHeaders['content-encoding'] === null) {\n            return false;\n          } // if an integrity is null, it needs to have a status specified\n\n\n          if (entry.integrity === null) {\n            return !!(entry.metadata && entry.metadata.status);\n          }\n\n          return true;\n        }\n      });\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return;\n    } // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n\n\n    if (options.cache === 'reload') {\n      return;\n    } // find the specific entry that satisfies the request\n\n\n    let match;\n\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options\n      });\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry;\n        break;\n      }\n    }\n\n    return match;\n  } // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n\n\n  static async invalidate(request, options) {\n    const key = cacheKey(request);\n\n    try {\n      await cacache.rm.entry(options.cachePath, key, {\n        removeFully: true\n      });\n    } catch (err) {// ignore errors\n    }\n  }\n\n  get request() {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n        ...this.entry.metadata.options\n      });\n    }\n\n    return this[_request];\n  }\n\n  get response() {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: { ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size\n        }\n      });\n    }\n\n    return this[_response];\n  }\n\n  get policy() {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options\n      });\n    }\n\n    return this[_policy];\n  } // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n\n\n  async store(status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {\n      this.response.headers.set('x-local-cache-status', 'skip');\n      return this.response;\n    }\n\n    const size = this.response.headers.get('content-length');\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      integrity: this.options.integrity,\n      integrityEmitter: this.response.body.hasIntegrityEmitter && this.response.body\n    };\n    let body = null; // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject;\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve;\n        cacheWriteReject = reject;\n      });\n      body = new CachingMinipassPipeline({\n        events: ['integrity', 'size']\n      }, new MinipassFlush({\n        flush() {\n          return cacheWritePromise;\n        }\n\n      })); // this is always true since if we aren't reusing the one from the remote fetch, we\n      // are using the one from cacache\n\n      body.hasIntegrityEmitter = true;\n\n      const onResume = () => {\n        const tee = new Minipass();\n        const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts); // re-emit the integrity and size events on our new response body so they can be reused\n\n        cacheStream.on('integrity', i => body.emit('integrity', i));\n        cacheStream.on('size', s => body.emit('size', s)); // stick a flag on here so downstream users will know if they can expect integrity events\n\n        tee.pipe(cacheStream); // TODO if the cache write fails, log a warning but return the response anyway\n\n        cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n        body.unshift(tee);\n        body.unshift(this.response.body);\n      };\n\n      body.once('resume', onResume);\n      body.once('end', () => body.removeListener('resume', onResume));\n    } else {\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts);\n    } // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n\n\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n    this.response.headers.set('x-local-cache-mode', 'stream');\n    this.response.headers.set('x-local-cache-status', status);\n    this.response.headers.set('x-local-cache-time', new Date().toISOString());\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter\n    });\n    return newResponse;\n  } // use the cached data to create a response and return it\n\n\n  async respond(method, options, status) {\n    let response;\n\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response;\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass();\n      const headers = { ...this.policy.responseHeaders()\n      };\n\n      const onResume = () => {\n        const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, {\n          memoize: this.options.memoize\n        });\n        cacheStream.on('error', async err => {\n          cacheStream.pause();\n\n          if (err.code === 'EINTEGRITY') {\n            await cacache.rm.content(this.options.cachePath, this.entry.integrity, {\n              memoize: this.options.memoize\n            });\n          }\n\n          if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') {\n            await CacheEntry.invalidate(this.request, this.options);\n          }\n\n          body.emit('error', err);\n          cacheStream.resume();\n        }); // emit the integrity and size events based on our metadata so we're consistent\n\n        body.emit('integrity', this.entry.integrity);\n        body.emit('size', Number(headers['content-length']));\n        cacheStream.pipe(body);\n      };\n\n      body.once('resume', onResume);\n      body.once('end', () => body.removeListener('resume', onResume));\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers\n      });\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity));\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n    response.headers.set('x-local-cache-mode', 'stream');\n    response.headers.set('x-local-cache-status', status);\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString());\n    return response;\n  } // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n\n\n  async revalidate(request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request)\n    });\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, { ...options,\n        headers: undefined\n      });\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate) {\n        return this.respond(request.method, options, 'stale');\n      }\n\n      throw err;\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options); // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) {\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];\n        }\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata\n        });\n      } catch (err) {// if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n\n      return this.respond(request.method, options, 'revalidated');\n    } // if we got a modified response, create a new entry based on it\n\n\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options\n    }); // respond with the new entry while writing it to the cache\n\n    return newEntry.store('updated');\n  }\n\n}\n\nmodule.exports = CacheEntry;","map":{"version":3,"names":["Request","Response","require","Minipass","MinipassFlush","cacache","url","CachingMinipassPipeline","CachePolicy","cacheKey","remote","hasOwnProperty","obj","prop","Object","prototype","call","KEEP_REQUEST_HEADERS","KEEP_RESPONSE_HEADERS","getMetadata","request","response","options","metadata","time","Date","now","reqHeaders","resHeaders","compress","status","name","headers","has","get","host","parsedUrl","URL","vary","varyHeaders","trim","toLowerCase","split","_request","Symbol","_response","_policy","CacheEntry","constructor","entry","key","find","matches","index","compact","cachePath","A","B","entryA","entryB","policy","satisfies","validateEntry","integrity","err","cache","match","_entry","invalidate","rm","removeFully","method","counter","size","store","includes","storable","set","cacheOpts","algorithms","integrityEmitter","body","hasIntegrityEmitter","cacheWriteResolve","cacheWriteReject","cacheWritePromise","Promise","resolve","reject","events","flush","onResume","tee","cacheStream","put","stream","on","i","emit","s","pipe","promise","then","unshift","once","removeListener","insert","encodeURIComponent","toISOString","newResponse","respond","responseHeaders","byDigest","memoize","pause","code","content","resume","Number","toUTCString","revalidate","revalidateRequest","revalidationHeaders","undefined","mustRevalidate","revalidated","newEntry","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/make-fetch-happen/lib/cache/entry.js"],"sourcesContent":["const { Request, Response } = require('minipass-fetch')\nconst Minipass = require('minipass')\nconst MinipassFlush = require('minipass-flush')\nconst cacache = require('cacache')\nconst url = require('url')\n\nconst CachingMinipassPipeline = require('../pipeline.js')\nconst CachePolicy = require('./policy.js')\nconst cacheKey = require('./key.js')\nconst remote = require('../remote.js')\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = [\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept',\n  'cache-control',\n]\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = [\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-type',\n  'date',\n  'etag',\n  'expires',\n  'last-modified',\n  'link',\n  'location',\n  'pragma',\n  'vary',\n]\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n\n    // options on which we must match the request and vary the response\n    options: {\n      compress: options.compress != null ? options.compress : request.compress,\n    },\n  }\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304) {\n    metadata.status = response.status\n  }\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) {\n      metadata.reqHeaders[name] = request.headers.get(name)\n    }\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host')\n  const parsedUrl = new url.URL(request.url)\n  if (host && parsedUrl.host !== host) {\n    metadata.reqHeaders.host = host\n  }\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary')\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/)\n      for (const name of varyHeaders) {\n        if (request.headers.has(name)) {\n          metadata.reqHeaders[name] = request.headers.get(name)\n        }\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name)\n    }\n  }\n\n  return metadata\n}\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request')\nconst _response = Symbol('response')\nconst _policy = Symbol('policy')\n\nclass CacheEntry {\n  constructor ({ entry, request, response, options }) {\n    if (entry) {\n      this.key = entry.key\n      this.entry = entry\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time\n    } else {\n      this.key = cacheKey(request)\n    }\n\n    this.options = options\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request\n    this[_response] = response\n    this[_policy] = null\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find (request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({ entry: A, options })\n        const entryB = new CacheEntry({ entry: B, options })\n        return entryA.policy.satisfies(entryB.request)\n      }, {\n        validateEntry: (entry) => {\n          // clean out entries with a buggy content-encoding value\n          if (entry.metadata &&\n              entry.metadata.resHeaders &&\n              entry.metadata.resHeaders['content-encoding'] === null) {\n            return false\n          }\n\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null) {\n            return !!(entry.metadata && entry.metadata.status)\n          }\n\n          return true\n        },\n      })\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload') {\n      return\n    }\n\n    // find the specific entry that satisfies the request\n    let match\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options,\n      })\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry\n        break\n      }\n    }\n\n    return match\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate (request, options) {\n    const key = cacheKey(request)\n    try {\n      await cacache.rm.entry(options.cachePath, key, { removeFully: true })\n    } catch (err) {\n      // ignore errors\n    }\n  }\n\n  get request () {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n        ...this.entry.metadata.options,\n      })\n    }\n\n    return this[_request]\n  }\n\n  get response () {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size,\n        },\n      })\n    }\n\n    return this[_response]\n  }\n\n  get policy () {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options,\n      })\n    }\n\n    return this[_policy]\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store (status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (\n      this.request.method !== 'GET' ||\n      ![200, 301, 308].includes(this.response.status) ||\n      !this.policy.storable()\n    ) {\n      this.response.headers.set('x-local-cache-status', 'skip')\n      return this.response\n    }\n\n    const size = this.response.headers.get('content-length')\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      integrity: this.options.integrity,\n      integrityEmitter: this.response.body.hasIntegrityEmitter && this.response.body,\n    }\n\n    let body = null\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve\n        cacheWriteReject = reject\n      })\n\n      body = new CachingMinipassPipeline({ events: ['integrity', 'size'] }, new MinipassFlush({\n        flush () {\n          return cacheWritePromise\n        },\n      }))\n      // this is always true since if we aren't reusing the one from the remote fetch, we\n      // are using the one from cacache\n      body.hasIntegrityEmitter = true\n\n      const onResume = () => {\n        const tee = new Minipass()\n        const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts)\n        // re-emit the integrity and size events on our new response body so they can be reused\n        cacheStream.on('integrity', i => body.emit('integrity', i))\n        cacheStream.on('size', s => body.emit('size', s))\n        // stick a flag on here so downstream users will know if they can expect integrity events\n        tee.pipe(cacheStream)\n        // TODO if the cache write fails, log a warning but return the response anyway\n        cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n        body.unshift(tee)\n        body.unshift(this.response.body)\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n    } else {\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts)\n    }\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    this.response.headers.set('x-local-cache-mode', 'stream')\n    this.response.headers.set('x-local-cache-status', status)\n    this.response.headers.set('x-local-cache-time', new Date().toISOString())\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter,\n    })\n    return newResponse\n  }\n\n  // use the cached data to create a response and return it\n  async respond (method, options, status) {\n    let response\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass()\n      const headers = { ...this.policy.responseHeaders() }\n      const onResume = () => {\n        const cacheStream = cacache.get.stream.byDigest(\n          this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize }\n        )\n        cacheStream.on('error', async (err) => {\n          cacheStream.pause()\n          if (err.code === 'EINTEGRITY') {\n            await cacache.rm.content(\n              this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize }\n            )\n          }\n          if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') {\n            await CacheEntry.invalidate(this.request, this.options)\n          }\n          body.emit('error', err)\n          cacheStream.resume()\n        })\n        // emit the integrity and size events based on our metadata so we're consistent\n        body.emit('integrity', this.entry.integrity)\n        body.emit('size', Number(headers['content-length']))\n        cacheStream.pipe(body)\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers,\n      })\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity))\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    response.headers.set('x-local-cache-mode', 'stream')\n    response.headers.set('x-local-cache-status', status)\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString())\n    return response\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate (request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request),\n    })\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined,\n      })\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate) {\n        return this.respond(request.method, options, 'stale')\n      }\n\n      throw err\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options)\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (\n          !hasOwnProperty(metadata.resHeaders, name) &&\n          hasOwnProperty(this.entry.metadata.resHeaders, name)\n        ) {\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n        }\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata,\n        })\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated')\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options,\n    })\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated')\n  }\n}\n\nmodule.exports = CacheEntry\n"],"mappings":"AAAA,MAAM;EAAEA,OAAF;EAAWC;AAAX,IAAwBC,OAAO,CAAC,gBAAD,CAArC;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,KAAD,CAAnB;;AAEA,MAAMK,uBAAuB,GAAGL,OAAO,CAAC,gBAAD,CAAvC;;AACA,MAAMM,WAAW,GAAGN,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,cAAD,CAAtB;;AAEA,MAAMS,cAAc,GAAG,CAACC,GAAD,EAAMC,IAAN,KAAeC,MAAM,CAACC,SAAP,CAAiBJ,cAAjB,CAAgCK,IAAhC,CAAqCJ,GAArC,EAA0CC,IAA1C,CAAtC,C,CAEA;AACA;AACA;;;AACA,MAAMI,oBAAoB,GAAG,CAC3B,gBAD2B,EAE3B,iBAF2B,EAG3B,iBAH2B,EAI3B,QAJ2B,EAK3B,eAL2B,CAA7B,C,CAQA;AACA;AACA;AACA;;AACA,MAAMC,qBAAqB,GAAG,CAC5B,eAD4B,EAE5B,kBAF4B,EAG5B,kBAH4B,EAI5B,cAJ4B,EAK5B,MAL4B,EAM5B,MAN4B,EAO5B,SAP4B,EAQ5B,eAR4B,EAS5B,MAT4B,EAU5B,UAV4B,EAW5B,QAX4B,EAY5B,MAZ4B,CAA9B,C,CAeA;;AACA,MAAMC,WAAW,GAAG,CAACC,OAAD,EAAUC,QAAV,EAAoBC,OAApB,KAAgC;EAClD,MAAMC,QAAQ,GAAG;IACfC,IAAI,EAAEC,IAAI,CAACC,GAAL,EADS;IAEfpB,GAAG,EAAEc,OAAO,CAACd,GAFE;IAGfqB,UAAU,EAAE,EAHG;IAIfC,UAAU,EAAE,EAJG;IAMf;IACAN,OAAO,EAAE;MACPO,QAAQ,EAAEP,OAAO,CAACO,QAAR,IAAoB,IAApB,GAA2BP,OAAO,CAACO,QAAnC,GAA8CT,OAAO,CAACS;IADzD;EAPM,CAAjB,CADkD,CAalD;;EACA,IAAIR,QAAQ,CAACS,MAAT,KAAoB,GAApB,IAA2BT,QAAQ,CAACS,MAAT,KAAoB,GAAnD,EAAwD;IACtDP,QAAQ,CAACO,MAAT,GAAkBT,QAAQ,CAACS,MAA3B;EACD;;EAED,KAAK,MAAMC,IAAX,IAAmBd,oBAAnB,EAAyC;IACvC,IAAIG,OAAO,CAACY,OAAR,CAAgBC,GAAhB,CAAoBF,IAApB,CAAJ,EAA+B;MAC7BR,QAAQ,CAACI,UAAT,CAAoBI,IAApB,IAA4BX,OAAO,CAACY,OAAR,CAAgBE,GAAhB,CAAoBH,IAApB,CAA5B;IACD;EACF,CAtBiD,CAwBlD;EACA;;;EACA,MAAMI,IAAI,GAAGf,OAAO,CAACY,OAAR,CAAgBE,GAAhB,CAAoB,MAApB,CAAb;EACA,MAAME,SAAS,GAAG,IAAI9B,GAAG,CAAC+B,GAAR,CAAYjB,OAAO,CAACd,GAApB,CAAlB;;EACA,IAAI6B,IAAI,IAAIC,SAAS,CAACD,IAAV,KAAmBA,IAA/B,EAAqC;IACnCZ,QAAQ,CAACI,UAAT,CAAoBQ,IAApB,GAA2BA,IAA3B;EACD,CA9BiD,CAgClD;EACA;;;EACA,IAAId,QAAQ,CAACW,OAAT,CAAiBC,GAAjB,CAAqB,MAArB,CAAJ,EAAkC;IAChC,MAAMK,IAAI,GAAGjB,QAAQ,CAACW,OAAT,CAAiBE,GAAjB,CAAqB,MAArB,CAAb,CADgC,CAEhC;IACA;IACA;IACA;;IACA,IAAII,IAAI,KAAK,GAAb,EAAkB;MAChB;MACA,MAAMC,WAAW,GAAGD,IAAI,CAACE,IAAL,GAAYC,WAAZ,GAA0BC,KAA1B,CAAgC,SAAhC,CAApB;;MACA,KAAK,MAAMX,IAAX,IAAmBQ,WAAnB,EAAgC;QAC9B,IAAInB,OAAO,CAACY,OAAR,CAAgBC,GAAhB,CAAoBF,IAApB,CAAJ,EAA+B;UAC7BR,QAAQ,CAACI,UAAT,CAAoBI,IAApB,IAA4BX,OAAO,CAACY,OAAR,CAAgBE,GAAhB,CAAoBH,IAApB,CAA5B;QACD;MACF;IACF;EACF;;EAED,KAAK,MAAMA,IAAX,IAAmBb,qBAAnB,EAA0C;IACxC,IAAIG,QAAQ,CAACW,OAAT,CAAiBC,GAAjB,CAAqBF,IAArB,CAAJ,EAAgC;MAC9BR,QAAQ,CAACK,UAAT,CAAoBG,IAApB,IAA4BV,QAAQ,CAACW,OAAT,CAAiBE,GAAjB,CAAqBH,IAArB,CAA5B;IACD;EACF;;EAED,OAAOR,QAAP;AACD,CA1DD,C,CA4DA;;;AACA,MAAMoB,QAAQ,GAAGC,MAAM,CAAC,SAAD,CAAvB;;AACA,MAAMC,SAAS,GAAGD,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAME,OAAO,GAAGF,MAAM,CAAC,QAAD,CAAtB;;AAEA,MAAMG,UAAN,CAAiB;EACfC,WAAW,OAAyC;IAAA,IAAvC;MAAEC,KAAF;MAAS7B,OAAT;MAAkBC,QAAlB;MAA4BC;IAA5B,CAAuC;;IAClD,IAAI2B,KAAJ,EAAW;MACT,KAAKC,GAAL,GAAWD,KAAK,CAACC,GAAjB;MACA,KAAKD,KAAL,GAAaA,KAAb,CAFS,CAGT;MACA;MACA;MACA;;MACA,KAAKA,KAAL,CAAW1B,QAAX,CAAoBC,IAApB,GAA2B,KAAKyB,KAAL,CAAW1B,QAAX,CAAoBC,IAApB,IAA4B,KAAKyB,KAAL,CAAWzB,IAAlE;IACD,CARD,MAQO;MACL,KAAK0B,GAAL,GAAWzC,QAAQ,CAACW,OAAD,CAAnB;IACD;;IAED,KAAKE,OAAL,GAAeA,OAAf,CAbkD,CAelD;;IACA,KAAKqB,QAAL,IAAiBvB,OAAjB;IACA,KAAKyB,SAAL,IAAkBxB,QAAlB;IACA,KAAKyB,OAAL,IAAgB,IAAhB;EACD,CApBc,CAsBf;EACA;;;EACiB,aAAJK,IAAI,CAAE/B,OAAF,EAAWE,OAAX,EAAoB;IACnC,IAAI;MACF;MACA,IAAI8B,OAAO,GAAG,MAAM/C,OAAO,CAACgD,KAAR,CAAcC,OAAd,CAAsBhC,OAAO,CAACiC,SAA9B,EAAyC9C,QAAQ,CAACW,OAAD,CAAjD,EAA4D,CAACoC,CAAD,EAAIC,CAAJ,KAAU;QACxF,MAAMC,MAAM,GAAG,IAAIX,UAAJ,CAAe;UAAEE,KAAK,EAAEO,CAAT;UAAYlC;QAAZ,CAAf,CAAf;QACA,MAAMqC,MAAM,GAAG,IAAIZ,UAAJ,CAAe;UAAEE,KAAK,EAAEQ,CAAT;UAAYnC;QAAZ,CAAf,CAAf;QACA,OAAOoC,MAAM,CAACE,MAAP,CAAcC,SAAd,CAAwBF,MAAM,CAACvC,OAA/B,CAAP;MACD,CAJmB,EAIjB;QACD0C,aAAa,EAAGb,KAAD,IAAW;UACxB;UACA,IAAIA,KAAK,CAAC1B,QAAN,IACA0B,KAAK,CAAC1B,QAAN,CAAeK,UADf,IAEAqB,KAAK,CAAC1B,QAAN,CAAeK,UAAf,CAA0B,kBAA1B,MAAkD,IAFtD,EAE4D;YAC1D,OAAO,KAAP;UACD,CANuB,CAQxB;;;UACA,IAAIqB,KAAK,CAACc,SAAN,KAAoB,IAAxB,EAA8B;YAC5B,OAAO,CAAC,EAAEd,KAAK,CAAC1B,QAAN,IAAkB0B,KAAK,CAAC1B,QAAN,CAAeO,MAAnC,CAAR;UACD;;UAED,OAAO,IAAP;QACD;MAfA,CAJiB,CAApB;IAqBD,CAvBD,CAuBE,OAAOkC,GAAP,EAAY;MACZ;MACA;IACD,CA3BkC,CA6BnC;IACA;IACA;;;IACA,IAAI1C,OAAO,CAAC2C,KAAR,KAAkB,QAAtB,EAAgC;MAC9B;IACD,CAlCkC,CAoCnC;;;IACA,IAAIC,KAAJ;;IACA,KAAK,MAAMjB,KAAX,IAAoBG,OAApB,EAA6B;MAC3B,MAAMe,MAAM,GAAG,IAAIpB,UAAJ,CAAe;QAC5BE,KAD4B;QAE5B3B;MAF4B,CAAf,CAAf;;MAKA,IAAI6C,MAAM,CAACP,MAAP,CAAcC,SAAd,CAAwBzC,OAAxB,CAAJ,EAAsC;QACpC8C,KAAK,GAAGC,MAAR;QACA;MACD;IACF;;IAED,OAAOD,KAAP;EACD,CA3Ec,CA6Ef;EACA;;;EACuB,aAAVE,UAAU,CAAEhD,OAAF,EAAWE,OAAX,EAAoB;IACzC,MAAM4B,GAAG,GAAGzC,QAAQ,CAACW,OAAD,CAApB;;IACA,IAAI;MACF,MAAMf,OAAO,CAACgE,EAAR,CAAWpB,KAAX,CAAiB3B,OAAO,CAACiC,SAAzB,EAAoCL,GAApC,EAAyC;QAAEoB,WAAW,EAAE;MAAf,CAAzC,CAAN;IACD,CAFD,CAEE,OAAON,GAAP,EAAY,CACZ;IACD;EACF;;EAEU,IAAP5C,OAAO,GAAI;IACb,IAAI,CAAC,KAAKuB,QAAL,CAAL,EAAqB;MACnB,KAAKA,QAAL,IAAiB,IAAI3C,OAAJ,CAAY,KAAKiD,KAAL,CAAW1B,QAAX,CAAoBjB,GAAhC,EAAqC;QACpDiE,MAAM,EAAE,KAD4C;QAEpDvC,OAAO,EAAE,KAAKiB,KAAL,CAAW1B,QAAX,CAAoBI,UAFuB;QAGpD,GAAG,KAAKsB,KAAL,CAAW1B,QAAX,CAAoBD;MAH6B,CAArC,CAAjB;IAKD;;IAED,OAAO,KAAKqB,QAAL,CAAP;EACD;;EAEW,IAARtB,QAAQ,GAAI;IACd,IAAI,CAAC,KAAKwB,SAAL,CAAL,EAAsB;MACpB,KAAKA,SAAL,IAAkB,IAAI5C,QAAJ,CAAa,IAAb,EAAmB;QACnCK,GAAG,EAAE,KAAK2C,KAAL,CAAW1B,QAAX,CAAoBjB,GADU;QAEnCkE,OAAO,EAAE,KAAKlD,OAAL,CAAakD,OAFa;QAGnC1C,MAAM,EAAE,KAAKmB,KAAL,CAAW1B,QAAX,CAAoBO,MAApB,IAA8B,GAHH;QAInCE,OAAO,EAAE,EACP,GAAG,KAAKiB,KAAL,CAAW1B,QAAX,CAAoBK,UADhB;UAEP,kBAAkB,KAAKqB,KAAL,CAAWwB;QAFtB;MAJ0B,CAAnB,CAAlB;IASD;;IAED,OAAO,KAAK5B,SAAL,CAAP;EACD;;EAES,IAANe,MAAM,GAAI;IACZ,IAAI,CAAC,KAAKd,OAAL,CAAL,EAAoB;MAClB,KAAKA,OAAL,IAAgB,IAAItC,WAAJ,CAAgB;QAC9ByC,KAAK,EAAE,KAAKA,KADkB;QAE9B7B,OAAO,EAAE,KAAKA,OAFgB;QAG9BC,QAAQ,EAAE,KAAKA,QAHe;QAI9BC,OAAO,EAAE,KAAKA;MAJgB,CAAhB,CAAhB;IAMD;;IAED,OAAO,KAAKwB,OAAL,CAAP;EACD,CA/Hc,CAiIf;EACA;;;EACW,MAAL4B,KAAK,CAAE5C,MAAF,EAAU;IACnB;IACA;IACA;IACA,IACE,KAAKV,OAAL,CAAamD,MAAb,KAAwB,KAAxB,IACA,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBI,QAAhB,CAAyB,KAAKtD,QAAL,CAAcS,MAAvC,CADD,IAEA,CAAC,KAAK8B,MAAL,CAAYgB,QAAZ,EAHH,EAIE;MACA,KAAKvD,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,sBAA1B,EAAkD,MAAlD;MACA,OAAO,KAAKxD,QAAZ;IACD;;IAED,MAAMoD,IAAI,GAAG,KAAKpD,QAAL,CAAcW,OAAd,CAAsBE,GAAtB,CAA0B,gBAA1B,CAAb;IACA,MAAM4C,SAAS,GAAG;MAChBC,UAAU,EAAE,KAAKzD,OAAL,CAAayD,UADT;MAEhBxD,QAAQ,EAAEJ,WAAW,CAAC,KAAKC,OAAN,EAAe,KAAKC,QAApB,EAA8B,KAAKC,OAAnC,CAFL;MAGhBmD,IAHgB;MAIhBV,SAAS,EAAE,KAAKzC,OAAL,CAAayC,SAJR;MAKhBiB,gBAAgB,EAAE,KAAK3D,QAAL,CAAc4D,IAAd,CAAmBC,mBAAnB,IAA0C,KAAK7D,QAAL,CAAc4D;IAL1D,CAAlB;IAQA,IAAIA,IAAI,GAAG,IAAX,CAtBmB,CAuBnB;IACA;;IACA,IAAI,KAAK5D,QAAL,CAAcS,MAAd,KAAyB,GAA7B,EAAkC;MAChC,IAAIqD,iBAAJ,EAAuBC,gBAAvB;MACA,MAAMC,iBAAiB,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;QACzDL,iBAAiB,GAAGI,OAApB;QACAH,gBAAgB,GAAGI,MAAnB;MACD,CAHyB,CAA1B;MAKAP,IAAI,GAAG,IAAI1E,uBAAJ,CAA4B;QAAEkF,MAAM,EAAE,CAAC,WAAD,EAAc,MAAd;MAAV,CAA5B,EAA+D,IAAIrF,aAAJ,CAAkB;QACtFsF,KAAK,GAAI;UACP,OAAOL,iBAAP;QACD;;MAHqF,CAAlB,CAA/D,CAAP,CAPgC,CAYhC;MACA;;MACAJ,IAAI,CAACC,mBAAL,GAA2B,IAA3B;;MAEA,MAAMS,QAAQ,GAAG,MAAM;QACrB,MAAMC,GAAG,GAAG,IAAIzF,QAAJ,EAAZ;QACA,MAAM0F,WAAW,GAAGxF,OAAO,CAACyF,GAAR,CAAYC,MAAZ,CAAmB,KAAKzE,OAAL,CAAaiC,SAAhC,EAA2C,KAAKL,GAAhD,EAAqD4B,SAArD,CAApB,CAFqB,CAGrB;;QACAe,WAAW,CAACG,EAAZ,CAAe,WAAf,EAA4BC,CAAC,IAAIhB,IAAI,CAACiB,IAAL,CAAU,WAAV,EAAuBD,CAAvB,CAAjC;QACAJ,WAAW,CAACG,EAAZ,CAAe,MAAf,EAAuBG,CAAC,IAAIlB,IAAI,CAACiB,IAAL,CAAU,MAAV,EAAkBC,CAAlB,CAA5B,EALqB,CAMrB;;QACAP,GAAG,CAACQ,IAAJ,CAASP,WAAT,EAPqB,CAQrB;;QACAA,WAAW,CAACQ,OAAZ,GAAsBC,IAAtB,CAA2BnB,iBAA3B,EAA8CC,gBAA9C;QACAH,IAAI,CAACsB,OAAL,CAAaX,GAAb;QACAX,IAAI,CAACsB,OAAL,CAAa,KAAKlF,QAAL,CAAc4D,IAA3B;MACD,CAZD;;MAcAA,IAAI,CAACuB,IAAL,CAAU,QAAV,EAAoBb,QAApB;MACAV,IAAI,CAACuB,IAAL,CAAU,KAAV,EAAiB,MAAMvB,IAAI,CAACwB,cAAL,CAAoB,QAApB,EAA8Bd,QAA9B,CAAvB;IACD,CAhCD,MAgCO;MACL,MAAMtF,OAAO,CAACgD,KAAR,CAAcqD,MAAd,CAAqB,KAAKpF,OAAL,CAAaiC,SAAlC,EAA6C,KAAKL,GAAlD,EAAuD,IAAvD,EAA6D4B,SAA7D,CAAN;IACD,CA3DkB,CA6DnB;IACA;IACA;IACA;;;IACA,KAAKzD,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,eAA1B,EAA2C8B,kBAAkB,CAAC,KAAKrF,OAAL,CAAaiC,SAAd,CAA7D;IACA,KAAKlC,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,mBAA1B,EAA+C8B,kBAAkB,CAAC,KAAKzD,GAAN,CAAjE;IACA,KAAK7B,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,oBAA1B,EAAgD,QAAhD;IACA,KAAKxD,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,sBAA1B,EAAkD/C,MAAlD;IACA,KAAKT,QAAL,CAAcW,OAAd,CAAsB6C,GAAtB,CAA0B,oBAA1B,EAAgD,IAAIpD,IAAJ,GAAWmF,WAAX,EAAhD;IACA,MAAMC,WAAW,GAAG,IAAI5G,QAAJ,CAAagF,IAAb,EAAmB;MACrC3E,GAAG,EAAE,KAAKe,QAAL,CAAcf,GADkB;MAErCwB,MAAM,EAAE,KAAKT,QAAL,CAAcS,MAFe;MAGrCE,OAAO,EAAE,KAAKX,QAAL,CAAcW,OAHc;MAIrCwC,OAAO,EAAE,KAAKlD,OAAL,CAAakD;IAJe,CAAnB,CAApB;IAMA,OAAOqC,WAAP;EACD,CAhNc,CAkNf;;;EACa,MAAPC,OAAO,CAAEvC,MAAF,EAAUjD,OAAV,EAAmBQ,MAAnB,EAA2B;IACtC,IAAIT,QAAJ;;IACA,IAAIkD,MAAM,KAAK,MAAX,IAAqB,CAAC,GAAD,EAAM,GAAN,EAAWI,QAAX,CAAoB,KAAKtD,QAAL,CAAcS,MAAlC,CAAzB,EAAoE;MAClE;MACA;MACA;MACAT,QAAQ,GAAG,KAAKA,QAAhB;IACD,CALD,MAKO;MACL;MACA;MACA,MAAM4D,IAAI,GAAG,IAAI9E,QAAJ,EAAb;MACA,MAAM6B,OAAO,GAAG,EAAE,GAAG,KAAK4B,MAAL,CAAYmD,eAAZ;MAAL,CAAhB;;MACA,MAAMpB,QAAQ,GAAG,MAAM;QACrB,MAAME,WAAW,GAAGxF,OAAO,CAAC6B,GAAR,CAAY6D,MAAZ,CAAmBiB,QAAnB,CAClB,KAAK1F,OAAL,CAAaiC,SADK,EACM,KAAKN,KAAL,CAAWc,SADjB,EAC4B;UAAEkD,OAAO,EAAE,KAAK3F,OAAL,CAAa2F;QAAxB,CAD5B,CAApB;QAGApB,WAAW,CAACG,EAAZ,CAAe,OAAf,EAAwB,MAAOhC,GAAP,IAAe;UACrC6B,WAAW,CAACqB,KAAZ;;UACA,IAAIlD,GAAG,CAACmD,IAAJ,KAAa,YAAjB,EAA+B;YAC7B,MAAM9G,OAAO,CAACgE,EAAR,CAAW+C,OAAX,CACJ,KAAK9F,OAAL,CAAaiC,SADT,EACoB,KAAKN,KAAL,CAAWc,SAD/B,EAC0C;cAAEkD,OAAO,EAAE,KAAK3F,OAAL,CAAa2F;YAAxB,CAD1C,CAAN;UAGD;;UACD,IAAIjD,GAAG,CAACmD,IAAJ,KAAa,QAAb,IAAyBnD,GAAG,CAACmD,IAAJ,KAAa,YAA1C,EAAwD;YACtD,MAAMpE,UAAU,CAACqB,UAAX,CAAsB,KAAKhD,OAA3B,EAAoC,KAAKE,OAAzC,CAAN;UACD;;UACD2D,IAAI,CAACiB,IAAL,CAAU,OAAV,EAAmBlC,GAAnB;UACA6B,WAAW,CAACwB,MAAZ;QACD,CAZD,EAJqB,CAiBrB;;QACApC,IAAI,CAACiB,IAAL,CAAU,WAAV,EAAuB,KAAKjD,KAAL,CAAWc,SAAlC;QACAkB,IAAI,CAACiB,IAAL,CAAU,MAAV,EAAkBoB,MAAM,CAACtF,OAAO,CAAC,gBAAD,CAAR,CAAxB;QACA6D,WAAW,CAACO,IAAZ,CAAiBnB,IAAjB;MACD,CArBD;;MAuBAA,IAAI,CAACuB,IAAL,CAAU,QAAV,EAAoBb,QAApB;MACAV,IAAI,CAACuB,IAAL,CAAU,KAAV,EAAiB,MAAMvB,IAAI,CAACwB,cAAL,CAAoB,QAApB,EAA8Bd,QAA9B,CAAvB;MACAtE,QAAQ,GAAG,IAAIpB,QAAJ,CAAagF,IAAb,EAAmB;QAC5B3E,GAAG,EAAE,KAAK2C,KAAL,CAAW1B,QAAX,CAAoBjB,GADG;QAE5BkE,OAAO,EAAElD,OAAO,CAACkD,OAFW;QAG5B1C,MAAM,EAAE,GAHoB;QAI5BE;MAJ4B,CAAnB,CAAX;IAMD;;IAEDX,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,eAArB,EAAsC8B,kBAAkB,CAAC,KAAKrF,OAAL,CAAaiC,SAAd,CAAxD;IACAlC,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,oBAArB,EAA2C8B,kBAAkB,CAAC,KAAK1D,KAAL,CAAWc,SAAZ,CAA7D;IACA1C,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,mBAArB,EAA0C8B,kBAAkB,CAAC,KAAKzD,GAAN,CAA5D;IACA7B,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,oBAArB,EAA2C,QAA3C;IACAxD,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,sBAArB,EAA6C/C,MAA7C;IACAT,QAAQ,CAACW,OAAT,CAAiB6C,GAAjB,CAAqB,oBAArB,EAA2C,IAAIpD,IAAJ,CAAS,KAAKwB,KAAL,CAAW1B,QAAX,CAAoBC,IAA7B,EAAmC+F,WAAnC,EAA3C;IACA,OAAOlG,QAAP;EACD,CAvQc,CAyQf;EACA;EACA;;;EACgB,MAAVmG,UAAU,CAAEpG,OAAF,EAAWE,OAAX,EAAoB;IAClC,MAAMmG,iBAAiB,GAAG,IAAIzH,OAAJ,CAAYoB,OAAZ,EAAqB;MAC7CY,OAAO,EAAE,KAAK4B,MAAL,CAAY8D,mBAAZ,CAAgCtG,OAAhC;IADoC,CAArB,CAA1B;;IAIA,IAAI;MACF;MACA;MACA;MACA;MACA,IAAIC,QAAQ,GAAG,MAAMX,MAAM,CAAC+G,iBAAD,EAAoB,EAC7C,GAAGnG,OAD0C;QAE7CU,OAAO,EAAE2F;MAFoC,CAApB,CAA3B;IAID,CATD,CASE,OAAO3D,GAAP,EAAY;MACZ;MACA;MACA;MACA,IAAI,CAAC,KAAKJ,MAAL,CAAYgE,cAAjB,EAAiC;QAC/B,OAAO,KAAKd,OAAL,CAAa1F,OAAO,CAACmD,MAArB,EAA6BjD,OAA7B,EAAsC,OAAtC,CAAP;MACD;;MAED,MAAM0C,GAAN;IACD;;IAED,IAAI,KAAKJ,MAAL,CAAYiE,WAAZ,CAAwBJ,iBAAxB,EAA2CpG,QAA3C,CAAJ,EAA0D;MACxD;MACA,MAAME,QAAQ,GAAGJ,WAAW,CAACC,OAAD,EAAUC,QAAV,EAAoBC,OAApB,CAA5B,CAFwD,CAGxD;MACA;MACA;MACA;;MACA,KAAK,MAAMS,IAAX,IAAmBb,qBAAnB,EAA0C;QACxC,IACE,CAACP,cAAc,CAACY,QAAQ,CAACK,UAAV,EAAsBG,IAAtB,CAAf,IACApB,cAAc,CAAC,KAAKsC,KAAL,CAAW1B,QAAX,CAAoBK,UAArB,EAAiCG,IAAjC,CAFhB,EAGE;UACAR,QAAQ,CAACK,UAAT,CAAoBG,IAApB,IAA4B,KAAKkB,KAAL,CAAW1B,QAAX,CAAoBK,UAApB,CAA+BG,IAA/B,CAA5B;QACD;MACF;;MAED,IAAI;QACF,MAAM1B,OAAO,CAACgD,KAAR,CAAcqD,MAAd,CAAqBpF,OAAO,CAACiC,SAA7B,EAAwC,KAAKL,GAA7C,EAAkD,KAAKD,KAAL,CAAWc,SAA7D,EAAwE;UAC5EU,IAAI,EAAE,KAAKxB,KAAL,CAAWwB,IAD2D;UAE5ElD;QAF4E,CAAxE,CAAN;MAID,CALD,CAKE,OAAOyC,GAAP,EAAY,CACZ;QACA;MACD;;MACD,OAAO,KAAK8C,OAAL,CAAa1F,OAAO,CAACmD,MAArB,EAA6BjD,OAA7B,EAAsC,aAAtC,CAAP;IACD,CAnDiC,CAqDlC;;;IACA,MAAMwG,QAAQ,GAAG,IAAI/E,UAAJ,CAAe;MAC9B3B,OAD8B;MAE9BC,QAF8B;MAG9BC;IAH8B,CAAf,CAAjB,CAtDkC,CA4DlC;;IACA,OAAOwG,QAAQ,CAACpD,KAAT,CAAe,SAAf,CAAP;EACD;;AA1Uc;;AA6UjBqD,MAAM,CAACC,OAAP,GAAiBjF,UAAjB"},"metadata":{},"sourceType":"script"}