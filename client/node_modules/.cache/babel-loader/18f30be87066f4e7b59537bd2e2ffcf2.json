{"ast":null,"code":"// mix-in implementing the loadActual method\nconst {\n  relative,\n  dirname,\n  resolve,\n  join,\n  normalize\n} = require('path');\n\nconst rpj = require('read-package-json-fast');\n\nconst {\n  promisify\n} = require('util');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst walkUp = require('walk-up-path');\n\nconst ancestorPath = require('common-ancestor-path');\n\nconst treeCheck = require('../tree-check.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst realpath = require('../realpath.js');\n\nconst _loadFSNode = Symbol('loadFSNode');\n\nconst _newNode = Symbol('newNode');\n\nconst _newLink = Symbol('newLink');\n\nconst _loadFSTree = Symbol('loadFSTree');\n\nconst _loadFSChildren = Symbol('loadFSChildren');\n\nconst _findMissingEdges = Symbol('findMissingEdges');\n\nconst _findFSParents = Symbol('findFSParents');\n\nconst _resetDepFlags = Symbol('resetDepFlags');\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _topNodes = Symbol('linkTargets');\n\nconst _cache = Symbol('nodeLoadingCache');\n\nconst _loadActual = Symbol('loadActual');\n\nconst _loadActualVirtually = Symbol('loadActualVirtually');\n\nconst _loadActualActually = Symbol('loadActualActually');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets');\n\nconst _actualTreePromise = Symbol('actualTreePromise');\n\nconst _actualTree = Symbol('actualTree');\n\nconst _transplant = Symbol('transplant');\n\nconst _transplantFilter = Symbol('transplantFilter');\n\nconst _filter = Symbol('filter');\n\nconst _global = Symbol.for('global');\n\nconst _changePath = Symbol.for('_changePath');\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor(options) {\n    super(options);\n    this[_global] = !!options.global; // the tree of nodes on disk\n\n    this.actualTree = options.actualTree; // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n\n    this[_actualTreeLoaded] = new Set(); // caches for cached realpath calls\n\n    const cwd = process.cwd(); // assume that the cwd is real enough for our purposes\n\n    this[_rpcache] = new Map([[cwd, cwd]]);\n    this[_stcache] = new Map(); // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n\n    this[_cache] = new Map(); // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n\n    this[_topNodes] = new Set();\n  }\n\n  [_resetDepFlags](tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true;\n      }\n    } // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n\n\n    calcDepFlags(tree, !root);\n    return tree;\n  } // public method\n\n\n  async loadActual() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options,\n      ...options\n    }; // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n\n    return this.actualTree ? this.actualTree : this[_actualTreePromise] ? this[_actualTreePromise] : this[_actualTreePromise] = this[_loadActual](options).then(tree => this[_resetDepFlags](tree, options.root)).then(tree => this.actualTree = treeCheck(tree));\n  }\n\n  async [_loadActual](options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n      forceActual = false\n    } = options;\n    this[_filter] = filter;\n    this[_transplantFilter] = transplantFilter;\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n      const newNodeOrLink = this.path === real ? _newNode : _newLink;\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n        loadOverrides: true\n      });\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing,\n        global\n      });\n    } // not in global mode, hidden lockfile is allowed, load root pkg too\n\n\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n      loadOverrides: true\n    });\n\n    this[_actualTree].assertRootOverrides(); // if forceActual is set, don't even try the hidden lockfile\n\n\n    if (!forceActual) {\n      // Note: hidden lockfile will be rejected if it's not the latest thing\n      // in the folder, or if any of the entries in the hidden lockfile are\n      // missing.\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n        hiddenLockfile: true,\n        resolveOptions: this.options\n      });\n\n      if (meta.loadedFromDisk) {\n        this[_actualTree].meta = meta;\n        return this[_loadActualVirtually]({\n          root\n        });\n      }\n    }\n\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options\n    });\n    this[_actualTree].meta = meta;\n    return this[_loadActualActually]({\n      root,\n      ignoreMissing\n    });\n  }\n\n  async [_loadActualVirtually](_ref) {\n    let {\n      root\n    } = _ref;\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({ ...this.options\n    }).loadVirtual({\n      root: this[_actualTree]\n    });\n    await this[_loadWorkspaces](this[_actualTree]);\n\n    this[_transplant](root);\n\n    return this[_actualTree];\n  }\n\n  async [_loadActualActually](_ref2) {\n    let {\n      root,\n      ignoreMissing,\n      global\n    } = _ref2;\n    await this[_loadFSTree](this[_actualTree]);\n    await this[_loadWorkspaces](this[_actualTree]);\n    await this[_loadWorkspaceTargets](this[_actualTree]);\n\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]();\n    }\n\n    this[_findFSParents]();\n\n    this[_transplant](root);\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree];\n      const actualRoot = tree.isLink ? tree.target : tree;\n      const {\n        dependencies = {}\n      } = actualRoot.package;\n\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath.replace(/#/g, '%23')}` : '*';\n        dependencies[name] = dependencies[name] || def;\n      }\n\n      actualRoot.package = { ...actualRoot.package,\n        dependencies\n      };\n    }\n\n    return this[_actualTree];\n  } // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n\n\n  async [_loadWorkspaceTargets](tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return;\n    }\n\n    const promises = [];\n\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        // workspace overrides use the root overrides\n        const p = this[_loadFSNode]({\n          path,\n          root: this[_actualTree],\n          useRootOverrides: true\n        }).then(node => this[_loadFSTree](node));\n\n        promises.push(p);\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n  [_transplant](root) {\n    if (!root || root === this[_actualTree]) {\n      return;\n    }\n\n    this[_actualTree][_changePath](root.path);\n\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null;\n      }\n    }\n\n    root.replace(this[_actualTree]);\n\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null;\n    }\n\n    this[_actualTree] = root;\n  }\n\n  [_loadFSNode](_ref3) {\n    let {\n      path,\n      parent,\n      real,\n      root,\n      loadOverrides,\n      useRootOverrides\n    } = _ref3;\n\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache]).then(real => this[_loadFSNode]({\n        path,\n        parent,\n        real,\n        root,\n        loadOverrides,\n        useRootOverrides\n      }), // if realpath fails, just provide a dummy error node\n      error => new Node({\n        error,\n        path,\n        realpath: path,\n        parent,\n        root,\n        loadOverrides\n      }));\n    } // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n\n\n    const cached = this[_cache].get(path);\n\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent;\n        return node;\n      });\n    }\n\n    const p = rpj(join(real, 'package.json')) // soldier on if read-package-json raises an error\n    .then(pkg => [pkg, null], error => [null, error]).then(_ref4 => {\n      let [pkg, error] = _ref4;\n      return this[normalize(path) === real ? _newNode : _newLink]({\n        installLinks: this.installLinks,\n        legacyPeerDeps: this.legacyPeerDeps,\n        path,\n        realpath: real,\n        pkg,\n        error,\n        parent,\n        root,\n        loadOverrides,\n        ...(useRootOverrides && root.overrides ? {\n          overrides: root.overrides.getNodeRule({\n            name: pkg.name,\n            version: pkg.version\n          })\n        } : {})\n      });\n    }).then(node => {\n      this[_cache].set(path, node);\n\n      return node;\n    });\n\n    this[_cache].set(path, p);\n\n    return p;\n  } // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n\n\n  [_newNode](options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const {\n      parent,\n      realpath\n    } = options;\n\n    if (!parent) {\n      this[_topNodes].add(realpath);\n    }\n\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1' ? new Promise(res => setTimeout(() => res(new Node(options)), 100)) : new Node(options);\n  }\n\n  [_newLink](options) {\n    const {\n      realpath\n    } = options;\n\n    this[_topNodes].add(realpath);\n\n    const target = this[_cache].get(realpath);\n\n    const link = new Link({ ...options,\n      target\n    });\n\n    if (!target) {\n      this[_cache].set(realpath, link.target); // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n\n\n      return this[_loadFSTree](link.target).then(() => link);\n    } else if (target.then) {\n      target.then(node => link.target = node);\n    }\n\n    return link;\n  }\n\n  [_loadFSTree](node) {\n    const did = this[_actualTreeLoaded];\n    node = node.target; // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node));\n    } // impossible except in pathological ELOOP cases\n\n    /* istanbul ignore if */\n\n\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node);\n    }\n\n    did.add(node.realpath);\n    return this[_loadFSChildren](node).then(() => Promise.all([...node.children.entries()].filter(_ref5 => {\n      let [name, kid] = _ref5;\n      return !did.has(kid.realpath);\n    }).map(_ref6 => {\n      let [name, kid] = _ref6;\n      return this[_loadFSTree](kid);\n    })));\n  } // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n\n\n  [_loadFSChildren](node) {\n    const nm = resolve(node.realpath, 'node_modules');\n    return readdir(nm).then(kids => {\n      return Promise.all( // ignore . dirs and retired scoped package folders\n      kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid)).filter(kid => this[_filter](node, kid)).map(kid => this[_loadFSNode]({\n        parent: node,\n        path: resolve(nm, kid)\n      })));\n    }, // error in the readdir is not fatal, just means no kids\n    () => {});\n  }\n\n  async [_findMissingEdges]() {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map();\n    const tree = this[_actualTree];\n\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path);\n      const depPromises = [];\n\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node));\n\n        if (notMissing) {\n          continue;\n        } // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n\n\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break;\n          }\n\n          const entries = nmContents.get(p) || (await readdir(p + '/node_modules').catch(() => []));\n          nmContents.set(p, entries);\n\n          if (!entries.includes(name)) {\n            continue;\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p) : new Node({\n            path: p,\n            root: node.root,\n            dummy: true\n          });\n\n          this[_cache].set(p, d);\n\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = normalize(`${p}/node_modules/${name}`);\n\n            const cached = this[_cache].get(depPath);\n\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d\n              }).then(node => this[_loadFSTree](node)));\n            }\n          }\n\n          break;\n        }\n      }\n\n      await Promise.all(depPromises);\n    }\n  } // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n\n\n  [_findFSParents]() {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path);\n\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["relative","dirname","resolve","join","normalize","require","rpj","promisify","readdir","walkUp","ancestorPath","treeCheck","Shrinkwrap","calcDepFlags","Node","Link","realpath","_loadFSNode","Symbol","_newNode","_newLink","_loadFSTree","_loadFSChildren","_findMissingEdges","_findFSParents","_resetDepFlags","_actualTreeLoaded","_rpcache","for","_stcache","_topNodes","_cache","_loadActual","_loadActualVirtually","_loadActualActually","_loadWorkspaces","_loadWorkspaceTargets","_actualTreePromise","_actualTree","_transplant","_transplantFilter","_filter","_global","_changePath","module","exports","cls","ActualLoader","constructor","options","global","actualTree","Set","cwd","process","Map","tree","root","node","inventory","values","extraneous","loadActual","then","filter","transplantFilter","ignoreMissing","forceActual","real","path","newNodeOrLink","pkg","loadOverrides","assertRootOverrides","meta","load","hiddenLockfile","resolveOptions","loadedFromDisk","lockfileVersion","loadVirtual","actualRoot","isLink","target","dependencies","package","name","kid","children","entries","def","replace","workspaces","size","promises","has","p","useRootOverrides","push","Promise","all","fsChildren","parent","error","cached","get","dummy","installLinks","legacyPeerDeps","overrides","getNodeRule","version","set","add","env","_TEST_ARBORIST_SLOW_LINK_TARGET_","res","setTimeout","link","did","map","nm","kids","test","nmContents","ancestor","depPromises","edge","edgesOut","notMissing","missing","to","catch","includes","d","depPath","fsParent"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-actual.js"],"sourcesContent":["// mix-in implementing the loadActual method\n\nconst { relative, dirname, resolve, join, normalize } = require('path')\n\nconst rpj = require('read-package-json-fast')\nconst { promisify } = require('util')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst walkUp = require('walk-up-path')\nconst ancestorPath = require('common-ancestor-path')\nconst treeCheck = require('../tree-check.js')\n\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst realpath = require('../realpath.js')\n\nconst _loadFSNode = Symbol('loadFSNode')\nconst _newNode = Symbol('newNode')\nconst _newLink = Symbol('newLink')\nconst _loadFSTree = Symbol('loadFSTree')\nconst _loadFSChildren = Symbol('loadFSChildren')\nconst _findMissingEdges = Symbol('findMissingEdges')\nconst _findFSParents = Symbol('findFSParents')\nconst _resetDepFlags = Symbol('resetDepFlags')\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _topNodes = Symbol('linkTargets')\nconst _cache = Symbol('nodeLoadingCache')\nconst _loadActual = Symbol('loadActual')\nconst _loadActualVirtually = Symbol('loadActualVirtually')\nconst _loadActualActually = Symbol('loadActualActually')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets')\nconst _actualTreePromise = Symbol('actualTreePromise')\nconst _actualTree = Symbol('actualTree')\nconst _transplant = Symbol('transplant')\nconst _transplantFilter = Symbol('transplantFilter')\n\nconst _filter = Symbol('filter')\nconst _global = Symbol.for('global')\nconst _changePath = Symbol.for('_changePath')\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    this[_global] = !!options.global\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set()\n\n    // caches for cached realpath calls\n    const cwd = process.cwd()\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]])\n    this[_stcache] = new Map()\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map()\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set()\n  }\n\n  [_resetDepFlags] (tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true\n      }\n    }\n\n    // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n    calcDepFlags(tree, !root)\n    return tree\n  }\n\n  // public method\n  async loadActual (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree\n      : this[_actualTreePromise] ? this[_actualTreePromise]\n      : this[_actualTreePromise] = this[_loadActual](options)\n        .then(tree => this[_resetDepFlags](tree, options.root))\n        .then(tree => this.actualTree = treeCheck(tree))\n  }\n\n  async [_loadActual] (options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n      forceActual = false,\n    } = options\n    this[_filter] = filter\n    this[_transplantFilter] = transplantFilter\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache])\n      const newNodeOrLink = this.path === real ? _newNode : _newLink\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n        loadOverrides: true,\n      })\n      return this[_loadActualActually]({ root, ignoreMissing, global })\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n      loadOverrides: true,\n    })\n\n    this[_actualTree].assertRootOverrides()\n\n    // if forceActual is set, don't even try the hidden lockfile\n    if (!forceActual) {\n      // Note: hidden lockfile will be rejected if it's not the latest thing\n      // in the folder, or if any of the entries in the hidden lockfile are\n      // missing.\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n        hiddenLockfile: true,\n        resolveOptions: this.options,\n      })\n\n      if (meta.loadedFromDisk) {\n        this[_actualTree].meta = meta\n        return this[_loadActualVirtually]({ root })\n      }\n    }\n\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      lockfileVersion: this.options.lockfileVersion,\n      resolveOptions: this.options,\n    })\n    this[_actualTree].meta = meta\n    return this[_loadActualActually]({ root, ignoreMissing })\n  }\n\n  async [_loadActualVirtually] ({ root }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({ ...this.options }).loadVirtual({\n      root: this[_actualTree],\n    })\n    await this[_loadWorkspaces](this[_actualTree])\n\n    this[_transplant](root)\n    return this[_actualTree]\n  }\n\n  async [_loadActualActually] ({ root, ignoreMissing, global }) {\n    await this[_loadFSTree](this[_actualTree])\n    await this[_loadWorkspaces](this[_actualTree])\n    await this[_loadWorkspaceTargets](this[_actualTree])\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]()\n    }\n    this[_findFSParents]()\n    this[_transplant](root)\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree]\n      const actualRoot = tree.isLink ? tree.target : tree\n      const { dependencies = {} } = actualRoot.package\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath.replace(/#/g, '%23')}` : '*'\n        dependencies[name] = dependencies[name] || def\n      }\n      actualRoot.package = { ...actualRoot.package, dependencies }\n    }\n    return this[_actualTree]\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets] (tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return\n    }\n\n    const promises = []\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        // workspace overrides use the root overrides\n        const p = this[_loadFSNode]({ path, root: this[_actualTree], useRootOverrides: true })\n          .then(node => this[_loadFSTree](node))\n        promises.push(p)\n      }\n    }\n    await Promise.all(promises)\n  }\n\n  [_transplant] (root) {\n    if (!root || root === this[_actualTree]) {\n      return\n    }\n\n    this[_actualTree][_changePath](root.path)\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null\n      }\n    }\n\n    root.replace(this[_actualTree])\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null\n    }\n\n    this[_actualTree] = root\n  }\n\n  [_loadFSNode] ({ path, parent, real, root, loadOverrides, useRootOverrides }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache])\n        .then(\n          real => this[_loadFSNode]({\n            path,\n            parent,\n            real,\n            root,\n            loadOverrides,\n            useRootOverrides,\n          }),\n          // if realpath fails, just provide a dummy error node\n          error => new Node({\n            error,\n            path,\n            realpath: path,\n            parent,\n            root,\n            loadOverrides,\n          })\n        )\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path)\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent\n        return node\n      })\n    }\n\n    const p = rpj(join(real, 'package.json'))\n      // soldier on if read-package-json raises an error\n      .then(pkg => [pkg, null], error => [null, error])\n      .then(([pkg, error]) => {\n        return this[normalize(path) === real ? _newNode : _newLink]({\n          installLinks: this.installLinks,\n          legacyPeerDeps: this.legacyPeerDeps,\n          path,\n          realpath: real,\n          pkg,\n          error,\n          parent,\n          root,\n          loadOverrides,\n          ...(useRootOverrides && root.overrides\n            ? { overrides: root.overrides.getNodeRule({ name: pkg.name, version: pkg.version }) }\n            : {}),\n        })\n      })\n      .then(node => {\n        this[_cache].set(path, node)\n        return node\n      })\n\n    this[_cache].set(path, p)\n    return p\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode] (options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const { parent, realpath } = options\n    if (!parent) {\n      this[_topNodes].add(realpath)\n    }\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1'\n      ? new Promise(res => setTimeout(() => res(new Node(options)), 100))\n      : new Node(options)\n  }\n\n  [_newLink] (options) {\n    const { realpath } = options\n    this[_topNodes].add(realpath)\n    const target = this[_cache].get(realpath)\n    const link = new Link({ ...options, target })\n\n    if (!target) {\n      this[_cache].set(realpath, link.target)\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link)\n    } else if (target.then) {\n      target.then(node => link.target = node)\n    }\n\n    return link\n  }\n\n  [_loadFSTree] (node) {\n    const did = this[_actualTreeLoaded]\n    node = node.target\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node))\n    }\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node)\n    }\n\n    did.add(node.realpath)\n    return this[_loadFSChildren](node)\n      .then(() => Promise.all(\n        [...node.children.entries()]\n          .filter(([name, kid]) => !did.has(kid.realpath))\n          .map(([name, kid]) => this[_loadFSTree](kid))))\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren] (node) {\n    const nm = resolve(node.realpath, 'node_modules')\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n        kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid))\n          .filter(kid => this[_filter](node, kid))\n          .map(kid => this[_loadFSNode]({\n            parent: node,\n            path: resolve(nm, kid),\n          })))\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {})\n  }\n\n  async [_findMissingEdges] () {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map()\n    const tree = this[_actualTree]\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path)\n\n      const depPromises = []\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing &&\n          !(edge.to && (edge.to.dummy || edge.to.parent !== node))\n        if (notMissing) {\n          continue\n        }\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break\n          }\n\n          const entries = nmContents.get(p) ||\n            await readdir(p + '/node_modules').catch(() => [])\n          nmContents.set(p, entries)\n          if (!entries.includes(name)) {\n            continue\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p)\n            : new Node({ path: p, root: node.root, dummy: true })\n          this[_cache].set(p, d)\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = normalize(`${p}/node_modules/${name}`)\n            const cached = this[_cache].get(depPath)\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d,\n              }).then(node => this[_loadFSTree](node)))\n            }\n          }\n          break\n        }\n      }\n      await Promise.all(depPromises)\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents] () {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path)\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p)\n            break\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}