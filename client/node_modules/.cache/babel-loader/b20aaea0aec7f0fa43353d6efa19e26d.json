{"ast":null,"code":"'use strict';\n\nconst url = require('url');\n\nconst gitHosts = require('./git-host-info.js');\n\nconst GitHost = module.exports = require('./git-host.js');\n\nconst LRU = require('lru-cache');\n\nconst cache = new LRU({\n  max: 1000\n});\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:']);\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return;\n  }\n\n  const key = giturl + JSON.stringify(opts || {});\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts));\n  }\n\n  return cache.get(key);\n};\n\nfunction fromUrl(giturl, opts) {\n  if (!giturl) {\n    return;\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl);\n  const parsed = parseGitUrl(url);\n\n  if (!parsed) {\n    return parsed;\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n\n  if (!gitHostName) {\n    return;\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@'); // we ignore auth for shortcuts, so just trim it out\n\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n\n      const lastSlash = pathname.lastIndexOf('/');\n\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash)); // we want nulls only, never empty strings\n\n        if (!user) {\n          user = null;\n        }\n\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return;\n      }\n\n      const segments = gitHostInfo.extract(parsed);\n\n      if (!segments) {\n        return;\n      }\n\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocolToRepresentation(parsed.protocol);\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return;\n    } else {\n      throw err;\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n} // accepts input like git:github.com:user/repo and inserts the // after the first :\n\n\nconst correctProtocol = arg => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n\n  if (knownProtocols.includes(proto)) {\n    return arg;\n  }\n\n  const firstAt = arg.indexOf('@');\n\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//');\n\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1);\n}; // look for github shorthand inputs, such as npm/cli\n\n\nconst isGitHubShorthand = arg => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;\n  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;\n  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;\n  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;\n  const hasSlash = firstSlash > 0; // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;\n}; // attempt to correct an scp style url so that it will parse with `new URL()`\n\n\nconst correctUrl = giturl => {\n  const firstAt = giturl.indexOf('@');\n  const lastHash = giturl.lastIndexOf('#');\n  let firstColon = giturl.indexOf(':');\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity);\n  let corrected;\n\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1); // // and we find our new : positions\n\n    firstColon = corrected.indexOf(':');\n    lastColon = corrected.lastIndexOf(':');\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`;\n  }\n\n  return corrected;\n}; // try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\n\n\nconst parseGitUrl = giturl => {\n  let result;\n\n  try {\n    result = new url.URL(giturl);\n  } catch (err) {}\n\n  if (result) {\n    return result;\n  }\n\n  const correctedUrl = correctUrl(giturl);\n\n  try {\n    result = new url.URL(correctedUrl);\n  } catch (err) {}\n\n  return result;\n};","map":{"version":3,"names":["url","require","gitHosts","GitHost","module","exports","LRU","cache","max","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","knownProtocols","Object","keys","byShortcut","concat","fromUrl","giturl","opts","key","JSON","stringify","has","set","get","isGitHubShorthand","correctProtocol","parsed","parseGitUrl","gitHostShortcut","gitHostDomain","byDomain","hostname","startsWith","gitHostName","gitHostInfo","auth","username","password","committish","user","project","defaultRepresentation","pathname","firstAt","indexOf","lastSlash","lastIndexOf","decodeURIComponent","endsWith","hash","protocols","includes","segments","extract","err","URIError","arg","firstColon","proto","doubleSlash","firstHash","firstSlash","secondSlash","firstSpace","exec","spaceOnlyAfterHash","index","atOnlyAfterHash","colonOnlyAfterHash","secondSlashOnlyAfterHash","hasSlash","doesNotEndWithSlash","doesNotStartWithDot","correctUrl","lastHash","lastColon","Infinity","corrected","result","URL","correctedUrl"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/hosted-git-info/lib/index.js"],"sourcesContent":["'use strict'\nconst url = require('url')\nconst gitHosts = require('./git-host-info.js')\nconst GitHost = module.exports = require('./git-host.js')\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git',\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true,\n}\n\nconst knownProtocols = Object.keys(gitHosts.byShortcut)\n  .concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:'])\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return\n  }\n\n  const key = giturl + JSON.stringify(opts || {})\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts))\n  }\n\n  return cache.get(key)\n}\n\nfunction fromUrl (giturl, opts) {\n  if (!giturl) {\n    return\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl)\n  const parsed = parseGitUrl(url)\n  if (!parsed) {\n    return parsed\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain =\n    gitHosts.byDomain[parsed.hostname.startsWith('www.') ?\n      parsed.hostname.slice(4) :\n      parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocolToRepresentation(parsed.protocol)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (knownProtocols.includes(proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1)\n}\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&\n    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&\n    secondSlashOnlyAfterHash\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  const firstAt = giturl.indexOf('@')\n  const lastHash = giturl.lastIndexOf('#')\n  let firstColon = giturl.indexOf(':')\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity)\n\n  let corrected\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1)\n    // // and we find our new : positions\n    firstColon = corrected.indexOf(':')\n    lastColon = corrected.lastIndexOf(':')\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`\n  }\n\n  return corrected\n}\n\n// try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\nconst parseGitUrl = (giturl) => {\n  let result\n  try {\n    result = new url.URL(giturl)\n  } catch (err) {}\n\n  if (result) {\n    return result\n  }\n\n  const correctedUrl = correctUrl(giturl)\n  try {\n    result = new url.URL(correctedUrl)\n  } catch (err) {}\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}