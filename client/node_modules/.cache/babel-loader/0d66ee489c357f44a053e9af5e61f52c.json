{"ast":null,"code":"const hash = require('./hash.js');\n\nconst semver = require('semver');\n\nconst semverOpt = {\n  includePrerelease: true,\n  loose: true\n};\n\nconst getDepSpec = require('./get-dep-spec.js'); // any fields that we don't want in the cache need to be hidden\n\n\nconst _source = Symbol('source');\n\nconst _packument = Symbol('packument');\n\nconst _versionVulnMemo = Symbol('versionVulnMemo');\n\nconst _updated = Symbol('updated');\n\nconst _options = Symbol('options');\n\nconst _specVulnMemo = Symbol('specVulnMemo');\n\nconst _testVersion = Symbol('testVersion');\n\nconst _testVersions = Symbol('testVersions');\n\nconst _calculateRange = Symbol('calculateRange');\n\nconst _markVulnerable = Symbol('markVulnerable');\n\nconst _testSpec = Symbol('testSpec');\n\nclass Advisory {\n  constructor(name, source) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.source = source.id;\n    this[_source] = source;\n    this[_options] = options;\n    this.name = name;\n\n    if (!source.name) {\n      source.name = name;\n    }\n\n    this.dependency = source.name;\n\n    if (this.type === 'advisory') {\n      this.title = source.title;\n      this.url = source.url;\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`;\n      this.url = null;\n    }\n\n    this.severity = source.severity || 'high';\n    this.versions = [];\n    this.vulnerableVersions = [];\n    this.cwe = source.cwe;\n    this.cvss = source.cvss; // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*' : null;\n    this.id = hash(this);\n    this[_packument] = null; // memoized list of which versions are vulnerable\n\n    this[_versionVulnMemo] = new Map(); // memoized list of which dependency specs are vulnerable\n\n    this[_specVulnMemo] = new Map();\n    this[_updated] = false;\n  } // true if we updated from what we had in cache\n\n\n  get updated() {\n    return this[_updated];\n  }\n\n  get type() {\n    return this.dependency === this.name ? 'advisory' : 'metavuln';\n  }\n\n  get packument() {\n    return this[_packument];\n  } // load up the data from a cache entry and a fetched packument\n\n\n  load(cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object') {\n      throw new TypeError('invalid cached data, expected object');\n    }\n\n    if (!packument || typeof packument !== 'object') {\n      throw new TypeError('invalid packument data, expected object');\n    }\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id\n      });\n    }\n\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name\n      });\n    }\n\n    if (this[_packument]) {\n      throw new Error('advisory object already loaded');\n    } // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n\n\n    if (!this.range || cached.range && cached.range === this.range) {\n      Object.assign(this, cached);\n    }\n\n    this[_packument] = packument;\n    const pakuVersions = Object.keys(packument.versions);\n    const allVersions = new Set([...pakuVersions, ...this.versions]);\n    const versionsAdded = [];\n    const versionsRemoved = [];\n\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v);\n        this.versions.push(v);\n      } else if (!pakuVersions.includes(v)) {\n        versionsRemoved.push(v);\n      }\n    } // strip out any removed versions from our lists, and sort by semver\n\n\n    this.versions = semver.sort(this.versions.filter(v => !versionsRemoved.includes(v)), semverOpt); // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n\n    const unchanged = this.type === 'advisory' ? this.range && this.range === cached.range : !this[_source].updated; // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n\n    this.vulnerableVersions = !unchanged ? [] : semver.sort(this.vulnerableVersions.filter(v => !versionsRemoved.includes(v)), semverOpt);\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this;\n    }\n\n    this[_updated] = true; // test any versions newly added\n\n    if (!unchanged || versionsAdded.length) {\n      this[_testVersions](unchanged ? versionsAdded : this.versions);\n    }\n\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt); // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n\n    if (this.type === 'metavuln') {\n      this[_calculateRange]();\n    }\n\n    return this;\n  }\n\n  [_calculateRange]() {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = [];\n    this.versions = semver.sort(this.versions, semverOpt);\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt);\n\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]];\n\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++;\n            continue;\n          }\n\n          break;\n        }\n\n        if (vr.length > 1) {\n          vr[1] = this.versions[v];\n        } else {\n          vr.push(this.versions[v]);\n        }\n\n        v++;\n        vulnVer++;\n      } // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n\n\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1];\n        ranges.push(vr[1] === tail ? `>=${vr[0]}` : vr[0] === vr[1] ? vr[0] : vr.join(' - '));\n      }\n    }\n\n    const metavuln = ranges.join(' || ').trim();\n    this.range = !metavuln ? '<0.0.0-0' : semver.simplifyRange(this.versions, metavuln, semverOpt);\n  } // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n\n\n  testVersion(version) {\n    let spec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const sv = String(version);\n\n    if (this[_versionVulnMemo].has(sv)) {\n      return this[_versionVulnMemo].get(sv);\n    }\n\n    const result = this[_testVersion](version, spec);\n\n    if (result) {\n      this[_markVulnerable](version);\n    }\n\n    this[_versionVulnMemo].set(sv, !!result);\n\n    return result;\n  }\n\n  [_markVulnerable](version) {\n    const sv = String(version);\n\n    if (!this.vulnerableVersions.includes(sv)) {\n      this.vulnerableVersions.push(sv);\n    }\n  }\n\n  [_testVersion](version, spec) {\n    const sv = String(version);\n\n    if (this.vulnerableVersions.includes(sv)) {\n      return true;\n    }\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt);\n    } // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n\n\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec\n      }\n    };\n\n    if (!spec) {\n      spec = getDepSpec(mani, this.dependency);\n    } // no dep, no vuln\n\n\n    if (spec === null) {\n      return false;\n    }\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true;\n    }\n\n    const bd = mani.bundleDependencies;\n    const bundled = bd && bd.includes(this[_source].name); // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n\n    const avoid = this[_source].range;\n\n    if (bundled) {\n      return semver.intersects(spec, avoid, semverOpt);\n    }\n\n    return this[_source].testSpec(spec);\n  }\n\n  testSpec(spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo];\n\n    if (memo.has(spec)) {\n      return memo.get(spec);\n    }\n\n    const res = this[_testSpec](spec);\n\n    memo.set(spec, res);\n    return res;\n  }\n\n  [_testSpec](spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec);\n\n      if (!satisfies) {\n        continue;\n      }\n\n      if (!this.testVersion(v)) {\n        return false;\n      }\n    } // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n\n\n    return true;\n  }\n\n  [_testVersions](versions) {\n    if (!versions.length) {\n      return;\n    } // set of lists of versions\n\n\n    const versionSets = new Set();\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt))); // start out with the versions grouped by major and minor\n\n    let last = versions[0].major + '.' + versions[0].minor;\n    let list = [];\n    versionSets.add(list);\n\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor;\n\n      if (k !== last) {\n        last = k;\n        list = [];\n        versionSets.add(list);\n      }\n\n      list.push(v);\n    }\n\n    for (const set of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and set[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and set[set.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the set, then start there instead.\n      let h = 0;\n      const origHeadVuln = this.testVersion(set[h]);\n\n      while (h < set.length && /-/.test(String(set[h]))) {\n        h++;\n      } // don't filter out the whole list!  they might all be pr's\n\n\n      if (h === set.length) {\n        h = 0;\n      } else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++) {\n          this[_markVulnerable](set[hh]);\n        }\n      }\n\n      let t = set.length - 1;\n      const origTailVuln = this.testVersion(set[t]);\n\n      while (t > h && /-/.test(String(set[t]))) {\n        t--;\n      } // don't filter out the whole list!  might all be pr's\n\n\n      if (t === h) {\n        t = set.length - 1;\n      } else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = set.length - 1; tt > t; tt--) {\n          this[_markVulnerable](set[tt]);\n        }\n      }\n\n      const headVuln = h === 0 ? origHeadVuln : this.testVersion(set[h]);\n      const tailVuln = t === set.length - 1 ? origTailVuln : this.testVersion(set[t]); // if head and tail both vulnerable, whole list is thrown out\n\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++) {\n          this[_markVulnerable](set[v]);\n        }\n\n        continue;\n      } // if length is 2 or 1, then we marked them all already\n\n\n      if (t < h + 2) {\n        continue;\n      }\n\n      const mid = Math.floor(set.length / 2);\n      const pre = set.slice(0, mid);\n      const post = set.slice(mid); // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1]);\n\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop();\n\n          if (midVuln) {\n            this[_markVulnerable](v);\n          }\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0]);\n\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift();\n\n          if (midVuln) {\n            this[_markVulnerable](v);\n          }\n        }\n      }\n\n      versionSets.add(pre);\n      versionSets.add(post);\n    }\n  }\n\n}\n\nmodule.exports = Advisory;","map":{"version":3,"names":["hash","require","semver","semverOpt","includePrerelease","loose","getDepSpec","_source","Symbol","_packument","_versionVulnMemo","_updated","_options","_specVulnMemo","_testVersion","_testVersions","_calculateRange","_markVulnerable","_testSpec","Advisory","constructor","name","source","options","id","dependency","type","title","url","severity","versions","vulnerableVersions","cwe","cvss","range","vulnerable_versions","Map","updated","packument","load","cached","TypeError","Object","assign","Error","expected","actual","pakuVersions","keys","allVersions","Set","versionsAdded","versionsRemoved","v","includes","push","sort","filter","unchanged","length","ranges","vulnVer","vr","test","tail","join","metavuln","trim","simplifyRange","testVersion","version","spec","sv","String","has","get","result","set","satisfies","mani","dependencies","validRange","bd","bundleDependencies","bundled","avoid","intersects","testSpec","memo","res","versionSets","map","parse","last","major","minor","list","add","k","h","origHeadVuln","hh","t","origTailVuln","tt","headVuln","tailVuln","mid","Math","floor","pre","slice","post","midVuln","pop","shift","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/metavuln-calculator/lib/advisory.js"],"sourcesContent":["const hash = require('./hash.js')\nconst semver = require('semver')\nconst semverOpt = { includePrerelease: true, loose: true }\nconst getDepSpec = require('./get-dep-spec.js')\n\n// any fields that we don't want in the cache need to be hidden\nconst _source = Symbol('source')\nconst _packument = Symbol('packument')\nconst _versionVulnMemo = Symbol('versionVulnMemo')\nconst _updated = Symbol('updated')\nconst _options = Symbol('options')\nconst _specVulnMemo = Symbol('specVulnMemo')\nconst _testVersion = Symbol('testVersion')\nconst _testVersions = Symbol('testVersions')\nconst _calculateRange = Symbol('calculateRange')\nconst _markVulnerable = Symbol('markVulnerable')\nconst _testSpec = Symbol('testSpec')\n\nclass Advisory {\n  constructor (name, source, options = {}) {\n    this.source = source.id\n    this[_source] = source\n    this[_options] = options\n    this.name = name\n    if (!source.name) {\n      source.name = name\n    }\n\n    this.dependency = source.name\n\n    if (this.type === 'advisory') {\n      this.title = source.title\n      this.url = source.url\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`\n      this.url = null\n    }\n\n    this.severity = source.severity || 'high'\n    this.versions = []\n    this.vulnerableVersions = []\n    this.cwe = source.cwe\n    this.cvss = source.cvss\n\n    // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*'\n      : null\n\n    this.id = hash(this)\n\n    this[_packument] = null\n    // memoized list of which versions are vulnerable\n    this[_versionVulnMemo] = new Map()\n    // memoized list of which dependency specs are vulnerable\n    this[_specVulnMemo] = new Map()\n    this[_updated] = false\n  }\n\n  // true if we updated from what we had in cache\n  get updated () {\n    return this[_updated]\n  }\n\n  get type () {\n    return this.dependency === this.name ? 'advisory' : 'metavuln'\n  }\n\n  get packument () {\n    return this[_packument]\n  }\n\n  // load up the data from a cache entry and a fetched packument\n  load (cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object') {\n      throw new TypeError('invalid cached data, expected object')\n    }\n\n    if (!packument || typeof packument !== 'object') {\n      throw new TypeError('invalid packument data, expected object')\n    }\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id,\n      })\n    }\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name,\n      })\n    }\n    if (this[_packument]) {\n      throw new Error('advisory object already loaded')\n    }\n\n    // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n    if (!this.range || cached.range && cached.range === this.range) {\n      Object.assign(this, cached)\n    }\n\n    this[_packument] = packument\n\n    const pakuVersions = Object.keys(packument.versions)\n    const allVersions = new Set([...pakuVersions, ...this.versions])\n    const versionsAdded = []\n    const versionsRemoved = []\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v)\n        this.versions.push(v)\n      } else if (!pakuVersions.includes(v)) {\n        versionsRemoved.push(v)\n      }\n    }\n\n    // strip out any removed versions from our lists, and sort by semver\n    this.versions = semver.sort(this.versions.filter(v =>\n      !versionsRemoved.includes(v)), semverOpt)\n\n    // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n    const unchanged = this.type === 'advisory'\n      ? this.range && this.range === cached.range\n      : !this[_source].updated\n\n    // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n    this.vulnerableVersions = !unchanged ? []\n      : semver.sort(this.vulnerableVersions.filter(v =>\n        !versionsRemoved.includes(v)), semverOpt)\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this\n    }\n\n    this[_updated] = true\n\n    // test any versions newly added\n    if (!unchanged || versionsAdded.length) {\n      this[_testVersions](unchanged ? versionsAdded : this.versions)\n    }\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt)\n\n    // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n    if (this.type === 'metavuln') {\n      this[_calculateRange]()\n    }\n\n    return this\n  }\n\n  [_calculateRange] () {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = []\n    this.versions = semver.sort(this.versions, semverOpt)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt)\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]]\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++\n            continue\n          }\n          break\n        }\n        if (vr.length > 1) {\n          vr[1] = this.versions[v]\n        } else {\n          vr.push(this.versions[v])\n        }\n        v++\n        vulnVer++\n      }\n      // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1]\n        ranges.push(vr[1] === tail ? `>=${vr[0]}`\n          : vr[0] === vr[1] ? vr[0]\n          : vr.join(' - '))\n      }\n    }\n    const metavuln = ranges.join(' || ').trim()\n    this.range = !metavuln ? '<0.0.0-0'\n      : semver.simplifyRange(this.versions, metavuln, semverOpt)\n  }\n\n  // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n  testVersion (version, spec = null) {\n    const sv = String(version)\n    if (this[_versionVulnMemo].has(sv)) {\n      return this[_versionVulnMemo].get(sv)\n    }\n\n    const result = this[_testVersion](version, spec)\n    if (result) {\n      this[_markVulnerable](version)\n    }\n    this[_versionVulnMemo].set(sv, !!result)\n    return result\n  }\n\n  [_markVulnerable] (version) {\n    const sv = String(version)\n    if (!this.vulnerableVersions.includes(sv)) {\n      this.vulnerableVersions.push(sv)\n    }\n  }\n\n  [_testVersion] (version, spec) {\n    const sv = String(version)\n    if (this.vulnerableVersions.includes(sv)) {\n      return true\n    }\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt)\n    }\n\n    // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec,\n      },\n    }\n\n    if (!spec) {\n      spec = getDepSpec(mani, this.dependency)\n    }\n\n    // no dep, no vuln\n    if (spec === null) {\n      return false\n    }\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true\n    }\n\n    const bd = mani.bundleDependencies\n    const bundled = bd && bd.includes(this[_source].name)\n    // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n    const avoid = this[_source].range\n\n    if (bundled) {\n      return semver.intersects(spec, avoid, semverOpt)\n    }\n\n    return this[_source].testSpec(spec)\n  }\n\n  testSpec (spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo]\n    if (memo.has(spec)) {\n      return memo.get(spec)\n    }\n\n    const res = this[_testSpec](spec)\n    memo.set(spec, res)\n    return res\n  }\n\n  [_testSpec] (spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec)\n      if (!satisfies) {\n        continue\n      }\n      if (!this.testVersion(v)) {\n        return false\n      }\n    }\n    // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n    return true\n  }\n\n  [_testVersions] (versions) {\n    if (!versions.length) {\n      return\n    }\n\n    // set of lists of versions\n    const versionSets = new Set()\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt)))\n\n    // start out with the versions grouped by major and minor\n    let last = versions[0].major + '.' + versions[0].minor\n    let list = []\n    versionSets.add(list)\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor\n      if (k !== last) {\n        last = k\n        list = []\n        versionSets.add(list)\n      }\n      list.push(v)\n    }\n\n    for (const set of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and set[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and set[set.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the set, then start there instead.\n      let h = 0\n      const origHeadVuln = this.testVersion(set[h])\n      while (h < set.length && /-/.test(String(set[h]))) {\n        h++\n      }\n\n      // don't filter out the whole list!  they might all be pr's\n      if (h === set.length) {\n        h = 0\n      } else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++) {\n          this[_markVulnerable](set[hh])\n        }\n      }\n\n      let t = set.length - 1\n      const origTailVuln = this.testVersion(set[t])\n      while (t > h && /-/.test(String(set[t]))) {\n        t--\n      }\n\n      // don't filter out the whole list!  might all be pr's\n      if (t === h) {\n        t = set.length - 1\n      } else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = set.length - 1; tt > t; tt--) {\n          this[_markVulnerable](set[tt])\n        }\n      }\n\n      const headVuln = h === 0 ? origHeadVuln\n        : this.testVersion(set[h])\n\n      const tailVuln = t === set.length - 1 ? origTailVuln\n        : this.testVersion(set[t])\n\n      // if head and tail both vulnerable, whole list is thrown out\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++) {\n          this[_markVulnerable](set[v])\n        }\n        continue\n      }\n\n      // if length is 2 or 1, then we marked them all already\n      if (t < h + 2) {\n        continue\n      }\n\n      const mid = Math.floor(set.length / 2)\n      const pre = set.slice(0, mid)\n      const post = set.slice(mid)\n\n      // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1])\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop()\n          if (midVuln) {\n            this[_markVulnerable](v)\n          }\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0])\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift()\n          if (midVuln) {\n            this[_markVulnerable](v)\n          }\n        }\n      }\n\n      versionSets.add(pre)\n      versionSets.add(post)\n    }\n  }\n}\n\nmodule.exports = Advisory\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}