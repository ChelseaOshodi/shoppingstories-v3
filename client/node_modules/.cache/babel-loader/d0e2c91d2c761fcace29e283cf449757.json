{"ast":null,"code":"const {\n  fixer\n} = require('normalize-package-data');\n\nconst npmFetch = require('npm-registry-fetch');\n\nconst npa = require('npm-package-arg');\n\nconst semver = require('semver');\n\nconst {\n  URL\n} = require('url');\n\nconst ssri = require('ssri');\n\nconst publish = async (manifest, tarballData, opts) => {\n  if (manifest.private) {\n    throw Object.assign(new Error(`This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`), {\n      code: 'EPRIVATE'\n    });\n  } // spec is used to pick the appropriate registry/auth combo\n\n\n  const spec = npa.resolve(manifest.name, manifest.version);\n  opts = {\n    defaultTag: 'latest',\n    // if scoped, restricted by default\n    access: spec.scope ? 'restricted' : 'public',\n    algorithms: ['sha512'],\n    ...opts,\n    spec\n  };\n  const reg = npmFetch.pickRegistry(spec, opts);\n  const pubManifest = patchManifest(manifest, opts); // registry-frontdoor cares about the access level,\n  // which is only configurable for scoped packages\n\n  if (!spec.scope && opts.access === 'restricted') {\n    throw Object.assign(new Error(\"Can't restrict access to unscoped packages.\"), {\n      code: 'EUNSCOPED'\n    });\n  }\n\n  const metadata = buildMetadata(reg, pubManifest, tarballData, opts);\n\n  try {\n    return await npmFetch(spec.escapedName, { ...opts,\n      method: 'PUT',\n      body: metadata,\n      ignoreBody: true\n    });\n  } catch (err) {\n    if (err.code !== 'E409') {\n      throw err;\n    } // if E409, we attempt exactly ONE retry, to protect us\n    // against malicious activity like trying to publish\n    // a bunch of new versions of a package at the same time\n    // and/or spamming the registry\n\n\n    const current = await npmFetch.json(spec.escapedName, { ...opts,\n      query: {\n        write: true\n      }\n    });\n    const newMetadata = patchMetadata(current, metadata);\n    return npmFetch(spec.escapedName, { ...opts,\n      method: 'PUT',\n      body: newMetadata,\n      ignoreBody: true\n    });\n  }\n};\n\nconst patchManifest = (_manifest, opts) => {\n  const {\n    npmVersion\n  } = opts; // we only update top-level fields, so a shallow clone is fine\n\n  const manifest = { ..._manifest\n  };\n  manifest._nodeVersion = process.versions.node;\n\n  if (npmVersion) {\n    manifest._npmVersion = npmVersion;\n  }\n\n  fixer.fixNameField(manifest, {\n    strict: true,\n    allowLegacyCase: true\n  });\n  const version = semver.clean(manifest.version);\n\n  if (!version) {\n    throw Object.assign(new Error('invalid semver: ' + manifest.version), {\n      code: 'EBADSEMVER'\n    });\n  }\n\n  manifest.version = version;\n  return manifest;\n};\n\nconst buildMetadata = (registry, manifest, tarballData, opts) => {\n  const {\n    access,\n    defaultTag,\n    algorithms\n  } = opts;\n  const root = {\n    _id: manifest.name,\n    name: manifest.name,\n    description: manifest.description,\n    'dist-tags': {},\n    versions: {},\n    access\n  };\n  root.versions[manifest.version] = manifest;\n  const tag = manifest.tag || defaultTag;\n  root['dist-tags'][tag] = manifest.version;\n  const tarballName = `${manifest.name}-${manifest.version}.tgz`;\n  const tarballURI = `${manifest.name}/-/${tarballName}`;\n  const integrity = ssri.fromData(tarballData, {\n    algorithms: [...new Set(['sha1'].concat(algorithms))]\n  });\n  manifest._id = `${manifest.name}@${manifest.version}`;\n  manifest.dist = { ...manifest.dist\n  }; // Don't bother having sha1 in the actual integrity field\n\n  manifest.dist.integrity = integrity.sha512[0].toString(); // Legacy shasum support\n\n  manifest.dist.shasum = integrity.sha1[0].hexDigest(); // NB: the CLI always fetches via HTTPS if the registry is HTTPS,\n  // regardless of what's here.  This makes it so that installing\n  // from an HTTP-only mirror doesn't cause problems, though.\n\n  manifest.dist.tarball = new URL(tarballURI, registry).href.replace(/^https:\\/\\//, 'http://');\n  root._attachments = {};\n  root._attachments[tarballName] = {\n    content_type: 'application/octet-stream',\n    data: tarballData.toString('base64'),\n    length: tarballData.length\n  };\n  return root;\n};\n\nconst patchMetadata = (current, newData) => {\n  const curVers = Object.keys(current.versions || {}).map(v => semver.clean(v, true)).concat(Object.keys(current.time || {}).map(v => semver.valid(v, true) && semver.clean(v, true)).filter(v => v));\n  const newVersion = Object.keys(newData.versions)[0];\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    const {\n      name: pkgid,\n      version\n    } = newData;\n    throw Object.assign(new Error(`Cannot publish ${pkgid}@${version} over existing version.`), {\n      code: 'EPUBLISHCONFLICT',\n      pkgid,\n      version\n    });\n  }\n\n  current.versions = current.versions || {};\n  current.versions[newVersion] = newData.versions[newVersion];\n\n  for (const i in newData) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (const j in newData[i]) {\n          current[i] = current[i] || {};\n          current[i][j] = newData[i][j];\n        }\n\n        break;\n      // copy\n\n      default:\n        current[i] = newData[i];\n        break;\n    }\n  }\n\n  return current;\n};\n\nmodule.exports = publish;","map":{"version":3,"names":["fixer","require","npmFetch","npa","semver","URL","ssri","publish","manifest","tarballData","opts","private","Object","assign","Error","code","spec","resolve","name","version","defaultTag","access","scope","algorithms","reg","pickRegistry","pubManifest","patchManifest","metadata","buildMetadata","escapedName","method","body","ignoreBody","err","current","json","query","write","newMetadata","patchMetadata","_manifest","npmVersion","_nodeVersion","process","versions","node","_npmVersion","fixNameField","strict","allowLegacyCase","clean","registry","root","_id","description","tag","tarballName","tarballURI","integrity","fromData","Set","concat","dist","sha512","toString","shasum","sha1","hexDigest","tarball","href","replace","_attachments","content_type","data","length","newData","curVers","keys","map","v","time","valid","filter","newVersion","indexOf","pkgid","i","j","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/libnpmpublish/lib/publish.js"],"sourcesContent":["const { fixer } = require('normalize-package-data')\nconst npmFetch = require('npm-registry-fetch')\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { URL } = require('url')\nconst ssri = require('ssri')\n\nconst publish = async (manifest, tarballData, opts) => {\n  if (manifest.private) {\n    throw Object.assign(\n      new Error(`This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`),\n      { code: 'EPRIVATE' }\n    )\n  }\n\n  // spec is used to pick the appropriate registry/auth combo\n  const spec = npa.resolve(manifest.name, manifest.version)\n  opts = {\n    defaultTag: 'latest',\n    // if scoped, restricted by default\n    access: spec.scope ? 'restricted' : 'public',\n    algorithms: ['sha512'],\n    ...opts,\n    spec,\n  }\n\n  const reg = npmFetch.pickRegistry(spec, opts)\n  const pubManifest = patchManifest(manifest, opts)\n\n  // registry-frontdoor cares about the access level,\n  // which is only configurable for scoped packages\n  if (!spec.scope && opts.access === 'restricted') {\n    throw Object.assign(\n      new Error(\"Can't restrict access to unscoped packages.\"),\n      { code: 'EUNSCOPED' }\n    )\n  }\n\n  const metadata = buildMetadata(reg, pubManifest, tarballData, opts)\n\n  try {\n    return await npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: metadata,\n      ignoreBody: true,\n    })\n  } catch (err) {\n    if (err.code !== 'E409') {\n      throw err\n    }\n    // if E409, we attempt exactly ONE retry, to protect us\n    // against malicious activity like trying to publish\n    // a bunch of new versions of a package at the same time\n    // and/or spamming the registry\n    const current = await npmFetch.json(spec.escapedName, {\n      ...opts,\n      query: { write: true },\n    })\n    const newMetadata = patchMetadata(current, metadata)\n    return npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: newMetadata,\n      ignoreBody: true,\n    })\n  }\n}\n\nconst patchManifest = (_manifest, opts) => {\n  const { npmVersion } = opts\n  // we only update top-level fields, so a shallow clone is fine\n  const manifest = { ..._manifest }\n\n  manifest._nodeVersion = process.versions.node\n  if (npmVersion) {\n    manifest._npmVersion = npmVersion\n  }\n\n  fixer.fixNameField(manifest, { strict: true, allowLegacyCase: true })\n  const version = semver.clean(manifest.version)\n  if (!version) {\n    throw Object.assign(\n      new Error('invalid semver: ' + manifest.version),\n      { code: 'EBADSEMVER' }\n    )\n  }\n  manifest.version = version\n  return manifest\n}\n\nconst buildMetadata = (registry, manifest, tarballData, opts) => {\n  const { access, defaultTag, algorithms } = opts\n  const root = {\n    _id: manifest.name,\n    name: manifest.name,\n    description: manifest.description,\n    'dist-tags': {},\n    versions: {},\n    access,\n  }\n\n  root.versions[manifest.version] = manifest\n  const tag = manifest.tag || defaultTag\n  root['dist-tags'][tag] = manifest.version\n\n  const tarballName = `${manifest.name}-${manifest.version}.tgz`\n  const tarballURI = `${manifest.name}/-/${tarballName}`\n  const integrity = ssri.fromData(tarballData, {\n    algorithms: [...new Set(['sha1'].concat(algorithms))],\n  })\n\n  manifest._id = `${manifest.name}@${manifest.version}`\n  manifest.dist = { ...manifest.dist }\n  // Don't bother having sha1 in the actual integrity field\n  manifest.dist.integrity = integrity.sha512[0].toString()\n  // Legacy shasum support\n  manifest.dist.shasum = integrity.sha1[0].hexDigest()\n\n  // NB: the CLI always fetches via HTTPS if the registry is HTTPS,\n  // regardless of what's here.  This makes it so that installing\n  // from an HTTP-only mirror doesn't cause problems, though.\n  manifest.dist.tarball = new URL(tarballURI, registry).href\n    .replace(/^https:\\/\\//, 'http://')\n\n  root._attachments = {}\n  root._attachments[tarballName] = {\n    content_type: 'application/octet-stream',\n    data: tarballData.toString('base64'),\n    length: tarballData.length,\n  }\n\n  return root\n}\n\nconst patchMetadata = (current, newData) => {\n  const curVers = Object.keys(current.versions || {})\n    .map(v => semver.clean(v, true))\n    .concat(Object.keys(current.time || {})\n      .map(v => semver.valid(v, true) && semver.clean(v, true))\n      .filter(v => v))\n\n  const newVersion = Object.keys(newData.versions)[0]\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    const { name: pkgid, version } = newData\n    throw Object.assign(\n      new Error(\n        `Cannot publish ${pkgid}@${version} over existing version.`\n      ), {\n        code: 'EPUBLISHCONFLICT',\n        pkgid,\n        version,\n      })\n  }\n\n  current.versions = current.versions || {}\n  current.versions[newVersion] = newData.versions[newVersion]\n  for (const i in newData) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (const j in newData[i]) {\n          current[i] = current[i] || {}\n          current[i][j] = newData[i][j]\n        }\n        break\n\n      // copy\n      default:\n        current[i] = newData[i]\n        break\n    }\n  }\n\n  return current\n}\n\nmodule.exports = publish\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}