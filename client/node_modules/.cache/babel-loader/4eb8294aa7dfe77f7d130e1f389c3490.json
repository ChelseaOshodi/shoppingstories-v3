{"ast":null,"code":"// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\nconst fs = require('fs');\n\nconst promisify = require('util').promisify;\n\nconst readlink = promisify(fs.readlink);\nconst lstat = promisify(fs.lstat);\n\nconst {\n  resolve,\n  basename,\n  dirname\n} = require('path');\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n\n  /* istanbul ignore next */\n  if (depth > 2000) {\n    throw eloop(path);\n  }\n\n  path = resolve(path);\n\n  if (rpcache.has(path)) {\n    return Promise.resolve(rpcache.get(path));\n  }\n\n  const dir = dirname(path);\n  const base = basename(path);\n\n  if (base && rpcache.has(dir)) {\n    return realpathChild(dir, base, rpcache, stcache, depth);\n  } // if it's the root, then we know it's real\n\n\n  if (!base) {\n    rpcache.set(dir, dir);\n    return Promise.resolve(dir);\n  } // the parent, what is that?\n  // find out, and then come back.\n\n\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() => realpathCached(path, rpcache, stcache, depth + 1));\n};\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) {\n    return Promise.resolve(stcache.get(path));\n  }\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st);\n    return st;\n  });\n  stcache.set(path, p);\n  return p;\n}; // This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\n\n\nconst eloop = path => Object.assign(new Error(`ELOOP: too many symbolic links encountered, stat '${path}'`), {\n  errno: -62,\n  syscall: 'stat',\n  code: 'ELOOP',\n  path: path\n});\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir); // that unpossible\n\n  /* istanbul ignore next */\n\n  if (typeof realdir === 'undefined') {\n    throw new Error('in realpathChild without parent being in realpath cache');\n  }\n\n  const realish = resolve(realdir, base);\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish);\n      return realish;\n    }\n\n    return readlink(realish).then(target => {\n      const resolved = resolve(realdir, target);\n\n      if (realish === resolved) {\n        throw eloop(realish);\n      }\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1);\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real);\n      return real;\n    });\n  });\n};\n\nmodule.exports = realpathCached;","map":{"version":3,"names":["fs","require","promisify","readlink","lstat","resolve","basename","dirname","realpathCached","path","rpcache","stcache","depth","eloop","has","Promise","get","dir","base","realpathChild","set","then","lstatCached","p","st","Object","assign","Error","errno","syscall","code","realdir","realish","isSymbolicLink","target","resolved","real","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/@npmcli/arborist/lib/realpath.js"],"sourcesContent":["// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\n\nconst fs = require('fs')\nconst promisify = require('util').promisify\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst { resolve, basename, dirname } = require('path')\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n  /* istanbul ignore next */\n  if (depth > 2000) {\n    throw eloop(path)\n  }\n\n  path = resolve(path)\n  if (rpcache.has(path)) {\n    return Promise.resolve(rpcache.get(path))\n  }\n\n  const dir = dirname(path)\n  const base = basename(path)\n\n  if (base && rpcache.has(dir)) {\n    return realpathChild(dir, base, rpcache, stcache, depth)\n  }\n\n  // if it's the root, then we know it's real\n  if (!base) {\n    rpcache.set(dir, dir)\n    return Promise.resolve(dir)\n  }\n\n  // the parent, what is that?\n  // find out, and then come back.\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() =>\n    realpathCached(path, rpcache, stcache, depth + 1))\n}\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) {\n    return Promise.resolve(stcache.get(path))\n  }\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st)\n    return st\n  })\n  stcache.set(path, p)\n  return p\n}\n\n// This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\nconst eloop = path =>\n  Object.assign(new Error(\n    `ELOOP: too many symbolic links encountered, stat '${path}'`), {\n    errno: -62,\n    syscall: 'stat',\n    code: 'ELOOP',\n    path: path,\n  })\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir)\n  // that unpossible\n  /* istanbul ignore next */\n  if (typeof realdir === 'undefined') {\n    throw new Error('in realpathChild without parent being in realpath cache')\n  }\n\n  const realish = resolve(realdir, base)\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish)\n      return realish\n    }\n\n    return readlink(realish).then(target => {\n      const resolved = resolve(realdir, target)\n      if (realish === resolved) {\n        throw eloop(realish)\n      }\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1)\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real)\n      return real\n    })\n  })\n}\n\nmodule.exports = realpathCached\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}