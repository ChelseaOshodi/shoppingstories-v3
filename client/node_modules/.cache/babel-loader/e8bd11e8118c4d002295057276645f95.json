{"ast":null,"code":"const util = require('util');\n\nconst _data = Symbol('data');\n\nconst _delete = Symbol('delete');\n\nconst _append = Symbol('append');\n\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/); // replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\n\n\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/);\n\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket;\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean);\n  }\n\n  return [str];\n};\n\nconst parseKeys = key => {\n  const sqBracketItems = new Set();\n  sqBracketItems.add(_append);\n\n  const parseSqBrackets = str => {\n    const index = sqBracketsMatcher(str); // once we find square brackets, we recursively parse all these\n\n    if (index) {\n      const preSqBracketPortion = index[1]; // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n\n      /* eslint-disable-next-line no-new-wrappers */\n\n      const foundKey = new String(index[2]);\n      const postSqBracketPortion = index[3]; // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n\n      sqBracketItems.add(foundKey); // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n\n      return [...parseSqBrackets(preSqBracketPortion), foundKey, ...(postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : [])];\n    } // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n\n\n    return replaceAppendSymbols(str);\n  };\n\n  const res = []; // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n\n  const sqBracketKeys = parseSqBrackets(key.trim());\n\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k)) {\n      res.push(k);\n    } else {\n      // splits the dot-sep property names and add them to the list of keys\n\n      /* eslint-disable-next-line no-new-wrappers */\n      for (const splitKey of k.split('.')) {\n        res.push(String(splitKey));\n      }\n    }\n  } // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n\n\n  return res;\n};\n\nconst getter = _ref => {\n  let {\n    data,\n    key\n  } = _ref;\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key);\n  let _data = data;\n  let label = '';\n\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {\n        code: 'EINVALIDSYNTAX'\n      });\n    } // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n\n\n    const maybeIndex = Number(k);\n\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k];\n        return acc;\n      }, {});\n      return _data;\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k]) {\n        return undefined;\n      } // otherwise sets the next value\n\n\n      _data = _data[k];\n    }\n\n    label += k;\n  } // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n\n\n  if (Array.isArray(_data) && _data.length <= 1) {\n    _data = _data[0];\n  }\n\n  return {\n    [key]: _data\n  };\n};\n\nconst setter = _ref2 => {\n  let {\n    data,\n    key,\n    value,\n    force\n  } = _ref2;\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key);\n\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN;\n\n    try {\n      maybeIndex = Number(_key);\n    } catch (err) {}\n\n    if (!Number.isNaN(maybeIndex)) {\n      _key = maybeIndex;\n    } // creates new array in case key is an index\n    // and the array obj is not yet defined\n\n\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append;\n    const dataHasNoItems = !Object.keys(_data).length;\n\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data)) {\n      _data = [];\n    } // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n\n\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex) {\n      _data = { ..._data\n      };\n    } // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n\n\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(new Error(`Can't use append syntax in non-Array element`), {\n          code: 'ENOAPPEND'\n        });\n      }\n\n      _key = _data.length;\n    } // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n\n\n    const next = () => {\n      const haveContents = !force && _data[_key] != null && value !== _delete;\n      const shouldNotOverrideLiteralValue = !(typeof _data[_key] === 'object'); // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n\n      const shouldNotAddPropsToArrays = typeof keys[0] !== 'symbol' && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]));\n      const overrideError = haveContents && shouldNotOverrideLiteralValue;\n\n      if (overrideError) {\n        throw Object.assign(new Error(`Property ${_key} already exists and is not an Array or Object.`), {\n          code: 'EOVERRIDEVALUE'\n        });\n      }\n\n      const addPropsToArrayError = haveContents && shouldNotAddPropsToArrays;\n\n      if (addPropsToArrayError) {\n        throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {\n          code: 'ENOADDPROP'\n        });\n      }\n\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {};\n    }; // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n\n\n    if (keys.length) {\n      _data[_key] = setKeys(next(), keys.shift());\n    } else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data)) {\n          _data.splice(_key, 1);\n        } else {\n          delete _data[_key];\n        }\n      } else {\n        // finally, sets the value in its right place\n        _data[_key] = value;\n      }\n    }\n\n    return _data;\n  };\n\n  setKeys(data, keys.shift());\n};\n\nclass Queryable {\n  constructor(obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(new Error('Queryable needs an object to query properties from.'), {\n        code: 'ENOQUERYABLEOBJ'\n      });\n    }\n\n    this[_data] = obj;\n  }\n\n  query(queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '') {\n      return {\n        '': this[_data]\n      };\n    }\n\n    const q = query => getter({\n      data: this[_data],\n      key: query\n    });\n\n    if (Array.isArray(queries)) {\n      let res = {};\n\n      for (const query of queries) {\n        res = { ...res,\n          ...q(query)\n        };\n      }\n\n      return res;\n    } else {\n      return q(queries);\n    }\n  } // return the value for a single query if found, otherwise returns undefined\n\n\n  get(query) {\n    const obj = this.query(query);\n\n    if (obj) {\n      return obj[query];\n    }\n  } // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n\n\n  set(query, value) {\n    let {\n      force\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force\n    });\n  } // deletes the value of the property found at `query`\n\n\n  delete(query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete\n    });\n  }\n\n  toJSON() {\n    return this[_data];\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Queryable;","map":{"version":3,"names":["util","require","_data","Symbol","_delete","_append","sqBracketsMatcher","str","match","replaceAppendSymbols","matchEmptyBracket","pre","post","filter","Boolean","parseKeys","key","sqBracketItems","Set","add","parseSqBrackets","index","preSqBracketPortion","foundKey","String","postSqBracketPortion","res","sqBracketKeys","trim","k","has","push","splitKey","split","getter","data","keys","label","Object","assign","Error","code","maybeIndex","Number","Array","isArray","isInteger","reduce","acc","i","undefined","length","setter","value","force","setKeys","_key","NaN","err","isNaN","keyIsAnArrayIndex","dataHasNoItems","next","haveContents","shouldNotOverrideLiteralValue","shouldNotAddPropsToArrays","overrideError","addPropsToArrayError","shift","splice","Queryable","constructor","obj","query","queries","q","get","set","delete","toJSON","inspect","custom","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/utils/queryable.js"],"sourcesContent":["const util = require('util')\nconst _data = Symbol('data')\nconst _delete = Symbol('delete')\nconst _append = Symbol('append')\n\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/)\n\n// replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/)\n\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean)\n  }\n\n  return [str]\n}\n\nconst parseKeys = key => {\n  const sqBracketItems = new Set()\n  sqBracketItems.add(_append)\n  const parseSqBrackets = str => {\n    const index = sqBracketsMatcher(str)\n\n    // once we find square brackets, we recursively parse all these\n    if (index) {\n      const preSqBracketPortion = index[1]\n\n      // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n      /* eslint-disable-next-line no-new-wrappers */\n      const foundKey = new String(index[2])\n      const postSqBracketPortion = index[3]\n\n      // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n      sqBracketItems.add(foundKey)\n\n      // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n      return [\n        ...parseSqBrackets(preSqBracketPortion),\n        foundKey,\n        ...(postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : []),\n      ]\n    }\n\n    // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n    return replaceAppendSymbols(str)\n  }\n\n  const res = []\n  // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n  const sqBracketKeys = parseSqBrackets(key.trim())\n\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k)) {\n      res.push(k)\n    } else {\n      // splits the dot-sep property names and add them to the list of keys\n      /* eslint-disable-next-line no-new-wrappers */\n      for (const splitKey of k.split('.')) {\n        res.push(String(splitKey))\n      }\n    }\n  }\n\n  // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n  return res\n}\n\nconst getter = ({ data, key }) => {\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key)\n  let _data = data\n  let label = ''\n\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {\n        code: 'EINVALIDSYNTAX',\n      })\n    }\n\n    // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n    const maybeIndex = Number(k)\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k]\n        return acc\n      }, {})\n      return _data\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k]) {\n        return undefined\n      }\n\n      // otherwise sets the next value\n      _data = _data[k]\n    }\n\n    label += k\n  }\n\n  // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n  if (Array.isArray(_data) && _data.length <= 1) {\n    _data = _data[0]\n  }\n\n  return {\n    [key]: _data,\n  }\n}\n\nconst setter = ({ data, key, value, force }) => {\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key)\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN\n    try {\n      maybeIndex = Number(_key)\n    } catch (err) {}\n    if (!Number.isNaN(maybeIndex)) {\n      _key = maybeIndex\n    }\n\n    // creates new array in case key is an index\n    // and the array obj is not yet defined\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append\n    const dataHasNoItems = !Object.keys(_data).length\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data)) {\n      _data = []\n    }\n\n    // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex) {\n      _data = { ..._data }\n    }\n\n    // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(new Error(`Can't use append syntax in non-Array element`), {\n          code: 'ENOAPPEND',\n        })\n      }\n      _key = _data.length\n    }\n\n    // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n    const next = () => {\n      const haveContents = !force && _data[_key] != null && value !== _delete\n      const shouldNotOverrideLiteralValue = !(typeof _data[_key] === 'object')\n      // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n      const shouldNotAddPropsToArrays =\n        typeof keys[0] !== 'symbol' && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]))\n\n      const overrideError = haveContents && shouldNotOverrideLiteralValue\n      if (overrideError) {\n        throw Object.assign(\n          new Error(`Property ${_key} already exists and is not an Array or Object.`),\n          { code: 'EOVERRIDEVALUE' }\n        )\n      }\n\n      const addPropsToArrayError = haveContents && shouldNotAddPropsToArrays\n      if (addPropsToArrayError) {\n        throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {\n          code: 'ENOADDPROP',\n        })\n      }\n\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {}\n    }\n\n    // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n    if (keys.length) {\n      _data[_key] = setKeys(next(), keys.shift())\n    } else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data)) {\n          _data.splice(_key, 1)\n        } else {\n          delete _data[_key]\n        }\n      } else {\n        // finally, sets the value in its right place\n        _data[_key] = value\n      }\n    }\n\n    return _data\n  }\n\n  setKeys(data, keys.shift())\n}\n\nclass Queryable {\n  constructor (obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(new Error('Queryable needs an object to query properties from.'), {\n        code: 'ENOQUERYABLEOBJ',\n      })\n    }\n\n    this[_data] = obj\n  }\n\n  query (queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '') {\n      return { '': this[_data] }\n    }\n\n    const q = query =>\n      getter({\n        data: this[_data],\n        key: query,\n      })\n\n    if (Array.isArray(queries)) {\n      let res = {}\n      for (const query of queries) {\n        res = { ...res, ...q(query) }\n      }\n      return res\n    } else {\n      return q(queries)\n    }\n  }\n\n  // return the value for a single query if found, otherwise returns undefined\n  get (query) {\n    const obj = this.query(query)\n    if (obj) {\n      return obj[query]\n    }\n  }\n\n  // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n  set (query, value, { force } = {}) {\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force,\n    })\n  }\n\n  // deletes the value of the property found at `query`\n  delete (query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete,\n    })\n  }\n\n  toJSON () {\n    return this[_data]\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Queryable\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}